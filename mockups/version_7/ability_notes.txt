04/08/19

It's been a while since we talked about game-design. Over the past couple weeks, we've been doing some development -- some actual programming -- regarding the implementation of our game's Dynamic Rule System. Now that it's fully-functional, it's time to start developing other aspects of our game. The problem is that we need to review how we want for these aspects to behave.

I think our first order of business is to start working on 'abilities,' which are the actions your units can take in battle to consume AP. Think of these like the four 'moves' that Pokemon have.

To test the Dynamic Rule System, I created a very simple ability called 'Slap' which I think already nails down some CORE concepts about abilities, but we also had some more in-depth, complicated aspects that I'd like to review and attempt to development.

Let's review what we know about Abilities:
    * Abilities belong to 'classes'.
    * Abilities always consume the Leader's AP.
    * Abilities may consume resources from the unit or carry some cost.
    * A unit's 'MP' attribute is designed specifically as a resource for
      abilities to consume.
    * The use of abilities is the core of our combat gameplay. The idea is
      to choose them carefully and use them to give yourself an advantage in
      battle, and to use them over and over until you win.
    * Aside from dealing direct damage to enemy resources, abilities will
      also engage the Dynamic Rule System by implementing favorable rules
      for your party and disfavorable rules for the opponent party.
    * As a side-effect, some abilities may implement rules that are DIS-
      FAVORABLE for YOUR party or FAVORABLE for the ENEMY party. This could
      be the result of an ability 'backfiring' or just as a cost for an
      otherwise powerful ability.

    * We talked at depth before about how much 'chance' should play a role
      in the core mechanics of using abilities. One thing that we discussed
      was the idea of an 'effectiveness' gradient. Maybe this would be a
      good time to review that.
    * Every ability has 3 levels of effectiveness: 'glancing' effectiveness,
      'normal' effectiveness, and 'critical 'effectiveness.
    * When an ability is used, a dice is rolled to determine effectiveness.
    * Attributes on both the AGGRESSOR and DEFENDER will have an impact on
    * How wide the areas are for the dice-roll to land in any of those three
      levels.
    * These attributes are 'Skill' on the aggressor and 'Parry' on the
      defender (these names both suck, let's reconsider as time goes on).


I guess the moral of the story, today, is that we need to take our 'Slap' demonstrative ability and give it three effectiveness levels and see how we're gonna handle that dice-roll.

At first, we're not gonna fuck around with 'Skill' and 'Parry' attributes. We're just gonna roll a dice and choose a tier to activate when an ability is used.

Even at first, we want to determine a way to weight this randomness -- and that's something that I've had trouble with in the past: randomness weighting. There's many ways to do it and I've never been 100% satisfied that I've found the best way, programatically.

Enough developing: let's talk about DESIGN again. How are we going to calculate effectiveness. We have to change the weights of 'critical' and 'glancing' based on the interplay between the aggressor's Skill attribute and the defender's Parry attribute.

If an aggressor's Skill attribute is substantially higher than the defender's Parry attribute, we're going to have a HIGHER chance of getting a critical and a LOWER chance of getting a glancing hit.

If the defender's Parry attribute is substantially higher than the aggressor's Skill attribute, we're going to have a LOWER chance of getting a critical and a HIGHER chance of getting a glancing hit.

If they're even... Then we fall-back on some default weighting.

What if there was a MINIMUM CHANCE to GLANCE or CRIT. Let's say that we can simply get a 'interplay' value just from combining our 'parry' and 'skill':

Vencabot has 20 Skill
Kenny has 25 Parry

Effectiveness multiplier would be -5.

So, as this number goes into the negatives, we reduce our chance to crit UNTIL IT HITS ITS MINIMUM. You're gonna always have a chance to crit, but the chance bottoms out. Once that chance bottoms out, your chance to GLANCE goes UP. So, what we're really talking about is our chance to 'normal' shrinking. The more dramatic our 'effectiveness multiplier' becomes, the smaller our chance to 'normal' becomes.

Positive multipliers would work the opposite way: your chance to 'glance' would go down until IT hits a minimum, and then your chance to crit would start to go up, eating into your chance to 'normal'.

If our multiplier is 0 (Vencabot has 20 Skill and Kenny has 20 Parry), what are our default weights and how far are they from the MINIMUM weights?

I think, because we're working with a multiplier with 0 -- which is probably gonna be somewhat rare -- maybe we should have more dynamism: higher chances to glance and crit than we've been working with.

15% Glance (minimum 5%)
70% Normal
15% Crit (minimum 5%)

I wanna make a note that the WHOLE POINT of the 'effectiveness system' is to mitigate saltiness, because, unlike some RPGs where 'crit damage' is a pre-baked calculation, our abilities have THREE DIFFERENT FORMS: a 'glancing' form, a 'normal' form, and a 'crit' form, and all three are unique to every ability.

Therefore, you can always choose to use abilities where there isn't a whole lot of variance between the forms. Or you could choose to use abilities where there's a dramatic difference between the forms. So, it's in the player's hands how much they want to lean or be victim to the random effectiveness.

The downside of having lower 'default' values for Glancing and Crit would be that, as you grow your character to have higher Parry or Skill, there's less Crit and Glancing to TAKE AWAY.

The UPSIDE of having lower 'default' values for Glancing and Crit, is there they can grow MORE. It really depends on how extreme we expect the differences to be between an aggressor's Skill and a defender's Parry -- and what I will say is that, looking at how we've designed growth and attributes so far, it does seem somewhat likely that there could be a very large gap (multiplier). So perhaps it would make more sense to have the 'default' values be somewhat rare and then, as that multiplier goes up, we get higher likelihoods to get 'glancing' or 'crit'.

The next step would be to fine-tune the multiplier, but let's not fuck with that, because that really is dependent on character growth, which we haven't looked at yet: we don't know if a normal level for Skill would be '10' or '10,000'. We don't have a sense of scale.

So let's just mock this up and see where we're at.

For our mock-up, let's assume that '5' is a normal amount for Parry or Skill, and let's say that having twice the value of your opponent's attribute will give you a 50% chance to crit (or glance, depending on if you're attacking or defending).

We made some good progress: the next step will be to create a method which takes this 'effectiveness augmentor' (or whatever you want to call it) and returns weights. Since we're lowering ONE weight to a certain level before we start to RAISE the other weight, there's going to be a little bit of coding involved.

## side note: I forgot to fuck around with 'cure conditions' for our DynamicRule system. So, we're not really complete on that, yet.




04/15/2019

Let's make a to-do list for what I want to accomplish with the game this week.

So far, we've created a lot of mock-ups for the games most-complex mechanics (at least, seems to me). They've been proofs-of-concept just to demonstrate that some of this stuff is workable. Now, I want to look at battle in a more wholistic way; I want to actually start creating a full battle that can play out from start to finish with respect for the mechanics that we've discussed during our game-design streams.

So, a few things we're gonna need:

We're going to need Leaders, with their own attributes.

We're going to need to flesh out the Battle object with respect for which Units are in the 'ring' and in the back row.

We're going to need to flesh out the Units with more Attributes, including their slots for Dynamics.

Before we implement Leaders, let's flesh out our existing objects: Battles and Units.

I take that back. Let's get a very simple mock-up Leader object and use that for some Dynamics just to prove that it works. We're not gonna fuck around with giving them permanent Dynamics or AP limitations or their own abilities just yet.

## I'm not totally satisfied with the hierarchy of data in our battle so far. The 'BattleParty' needs a list of units, and the BattleUnits need to know their BattleParty. Futhermore, we're introducing a Leader object, which needs to know the Party that it's leading -- but, at the same time, the Party needs to know who its leader is. It'd be nice to come up with some way to make these objects less dependent on each other.

## Let's talk about hierarchy: it seems to me that, so far, the Battle object is the highest-level object we have (of course), and then, below that, we have the Parties. That makes sense to me: the units know what party they're a part of, but not what battle they're apart of (because we're managing state). The units don't need to know what battle they're a part of, because they know which party they belong to and the party knows what battle it belongs to.

## That being the case, the Leader doesn't really need to know what units it's leading or what battle it's a part of. As long as it knows its own BattleParty, it has access to the Battle object and the BattleUnits through that BattleParty. So, the hierarchy of data is sort of like this:

          Battle
            |
       BattleParty
           | |
BattleLeader BattleUnit

## Because the costs of using Abilities in our game can be so complex, it sort of necessitates not being able to abstract away the code of paying those costs. What I mean is, it would make sense, from an object-oriented standpoint, to give each Ability an 'ap_cost' attribute -- and then, when a BattleUnit tries to use an Ability, it could automatically subtract that AP cost from the Leader.

That makes sense. It would make sense if the gimmick our game wasn't that rules are so dynamic. Because, what if the costs of an ability change based on circumstance? What if you had an ability with a description like such:

Desperate Slap: If used when the leader's AP is at max, it costs 4 AP to use. If used when the leader's AP is below max, it costs 2 AP to use.

In that case -- and it seems very reasonable -- the Leader is punished for using Desperate Slap at the start of their turn. Because of dynamic systems like this one, I feel like we don't really have the luxury of implementing an 'ap_cost' attribute in an object-oriented way. Instead, it seems as though we need to implement the subtraction of costs into the actual code of using every individual Ability. That seems lame, from OOP standpoint, but it does make our mechanics more flexible.

I'm gonna make a new DynamicRule and we're gonna call it "NerdStamina." If the leader's AP drops below 3, every unit on their team loses 30% of their attack power. I'm trying to make a Rule that brings the new 'leaders' into play.

Right now, we've made our mock-up work under the assumption that we would only ever have one action take place in the battle. Now, we're taking more than one action per battle (as you would expect), and I'm finding that we need to reset the Battle's DynamicRule's recurrence_counter's. The question is, when is the best time to do that?

It would be done between player actions.

But how do we calculate that. How do we know when the player has done an action.

Well, it would be after the unit uses an ability. Leaders can also use abilities, including switching units. So... maybe... we need a better way to universally understand that a 'battle action' has taken place. We want to restore the Rules' recurrence_counter's after an action takes place.

Maybe, temporarily, it would just make sense to give the Battle object a 'reset_rule_counters' method that we can call between actions.

Final thoughts for the day: we implented a 'leader' object which has an AP value that we can consume when we use abilities. We made our first rule that cares about the leader and their AP, and we also, for the first time, took advantage of the fact that our DynamicRules are INSTANCES, which means that we can use them to save persistent data about how they've been triggered in the past to alter how they behave when triggered subsequently. So that's kind of cool.

We also implemented a method for our Battle objects to reset the recurrence counters of all of the rules to be called between 'actions'. It'd be nice to have this be automated, but, for that, we'd need a way to know when an action is being used.

I mean, fuck -- we could fix that right now. We should just append 'battle.reset_dynamic_recurrence' to the end of our battle_3.UnitAbility.use method.

For next time, we need to add a lot of attributes for BattleUnits and Battles, at the very least: including a 'ring' in the battle for units to populate and some slots for the BattleUnits to be under the influence of a LIMITED NUMBER of Dynamics. This is something that me and Kenny talked about as a way to balance the Dynamic system: have there be a limit to how many rules a single unit can be subject to.


04/17/19

First of all, I want to program a 'ring' into the 'Battle' object, so that we know which party members from each team are currently 'active' in the battle.

That means adding a new attribute to the Battle object (or would it be the 'Party' object??? It would be the Party object) and making some new Rules that would only target the unit in the ring.

I've mentioned in the past that a big difficulty with object-oriented programming is knowing how to divide and share responsibility. I think it'd make more sense for the 'ring' attribute to belong to the Party objects, in the long-term. It really is all about how you're deciding to abstract your ideas to make your current and future objects behave.

It would make more sense to give the 'in_ring' attribute to a Party object, because the Battle already has two parties and so figuring out who's in the ring would be as trivial as iterating through the Parties and reading their 'in_ring' attribute. What's cool about this is that it would work even if, hypothetically, we had 3 or 4 or 10 parties in the battle.

Furthermore, if the battle had a 'in_ring' attribute, it would need to be some kind of list, because we'd have two units in the ring for two teams. And then, to figure out which team those units are ON, we'd need to iterate through the in_ring list and read their .party attribute. It's just a little bit sloppier.

It makes more sense to have the 'in_ring' attribute belong to the Party objects.

Now that our BattleParty objects have a method for swapping units into the ring, we're going to expand upon that, later -- fuck it. Let's do it now.

Point_units have been implemented (in-ring units), so now we need to design some Rules that take advantage of this. I want 1 Rule that only affects the point_unit of a certain party, and so we want to change our point_unit mid-fight to see if the rule applies not to a PARTICULAR unit but to whoever is currently in the ring.

I want 1 Rule which only affects units who AREN'T in the ring.

I want 1 Rule which triggers when a painted unit is swapped INTO the ring.

Let's create a 'poison cloud' rule which subtracts HP from both point-units every turn? We don't have turns working yet. We could fix that first? Turns would be implemented at the Battle object level. The Battle would have an attribute: current_turn. Now, would current_turn refer to a Leader? Or a party? It doesn't really matter, but that's exactly why we need to consider this carefully: which would make more sense in the long-term.

The parties can't have a 'next_turn' method, because they don't strictly know (without going through their .battle attribute) what the other party is. So, if we're going to do a 'next_turn' method, it should definitely belong to the Battle object. Only the Battle object knows all of the parties.

I just had a horrible vision, dude. It strikes me that we probably want to have Rules that are triggered whenever leader AP is restored (never mind) by unnatural means, such as when an Ability is used that has a chance to restore AP when it crits. I don't want for these rules to get triggered when the turns roll over and the AP is restored back to maximum.

But that's fine, because DynamicEvents have 'perpetrators' for that very reason. If an AP restoration is perpetrated by an Ability, that would trigger the rule -- and it'd ignore the DynamicEvent if it was perpetrated by a turn-change.

It is REALLY ANNOYING that our 'DynamicAttributes' can't be read directly, because they're objects. To get the value of a DynamicAttribute, we have to use DynamicAttribute.value. That's pretty frustrating. Is there a way around that? I thought about it, before, and I couldn't think of a solution. for now, we'll continue using .value.

The thing to do to re-implement DynamicAttributes in a more readable way would be to override __setattr__ of the OWNER object -- NOT of the DynamicAttribute object, which would no longer even be necessary.

So, in object-oriented programming, Objects have 'attributes,' which are values that belong to that object.

So, if we have a 'protagonist' in a JRPG, he has an 'HP' attribute, and that value is constantly changing, but it belongs to the protagonist.

Because the gimmick of our game is that, wheenver a value changes in battle, it can trigger RULES, we created a new type of object which abstractly represents the same concept as an object attribute: a 'DynamicAttribute'.

This way, we can bind behavior to whenever the DynamicAttribute gets updated. So, instead of saying:

protagonist.hp = protagonist.hp - 10

We would say:

protagonist.hp = DynamicAttribute(self, "hp", 100)
protagonist.hp.update(protagonist.hp.value - 10, monster)

The problem with this is that we can't just say something simple like:
print(f"Your protagonist's health is currently at {protagonist.hp}.")

We can't say that because protagonist.hp is NOT an integer. It's a DynamicAttribute. So, instead, we need to say:

print(f"Your protagonist's health is currently at {protagonist.hp.value}.")

Because .value is an attribute of the DynamicAttribute object which refers to its current 'value'.

This works fine, but it's sort of confusing to read because we're intentionally abstracting away the default object-oriented behavior of the language. That's the problem. We're abstractly re-assigning a value, but we're not actually using Python's built-in assignment tools: we made our assignment tools that can trigger Rules. This necessitates an object with a method to do that, and so, when referring to the protagonist's actual HP integer, we need to refer to the 'value' attribute of this DynamicAttribute object -- and that's confusing, because we want to think of 'hp' as an integer.

But I think I have the solution. The solution would be to COMPLETELY GET RID OF the DynamicAttribute object and instead create a DynamicObject class which overrides __setattr__ . Whenever one of its attributes gets changed, it calls the method which has been, up to this point, DynamicAttribute.update().

We don't need an object which abstracts the idea of an 'attribute that can trigger things when changed.'

We need an object which says, 'if you change one of my attributes, things can get triggered'.

The problem with this idea is that, if we just use simple assignment to trigger Rules we don't have any way of knowing who perpetrated the change, and that's super important to our mechanisms.

If I say:

protagonist.hp.update(protagonist.hp.value - 10, monster)

We know that the monster lowered the protagonist's health.

However, if I just say,

protagonist.hp = protagonist.hp - 10

We don't have way of knowing how or why or who lowered that value, and that's super important to our mechanisms.

I'm not gonna have time to fix this today. Let's take a few minutes and think about if there's any solution to this issue. Can we possibly abstract away the DynamicAttribute object by replacing it with true Python object-oriented utilities via the __setattr__ method. Can we possibly have these Rules be triggered by __setattr__ when __setattr__'s only arguments are the NAME of the attribute ("hp") and the NEW VALUE (protagonist.hp - 10).

Is it important that we know WHO changed the protagonist's HP. The obvious answer is YES, obviously. We use DynamicAttribute.update to create these DynamicEvent objects which sort of act as reports to tell the rules what just happened.

With __setattr__, we could create and manage EVERY ASPECT of our current DynamicEvent report EXCEPT FOR the 'perpetrated_by' attribute.

We have to have the full report to make the rules work, and a huge part of that report is not only WHOSE value GOT changed, but WHO initiated that change.

If KReichJr attacks Vencabot and Vencabot's HP gets lowered, we're gonna need for Rules to know that Kenny is the attacker. That's pretty much the whole point of the dynamic system. We have this report that gets generated and which all of our Rules read to decide if they want to trigger or not. The report explains:

Who is the target of this change.
What attribute got changed.
What was that attribute's value, before.
What is that attribute's value, now.
Who initiated this change.

From __setattr__, we can get ALL of this data except for the last part.

I'm sad to say that it seems like our solution is the best solution for our problem considering our unique needs. In order to trigger rules whenever an attribute is changed, we need to generate this report which we're calling DynamicEvent. To generate that report, we just can't rely on a simple, vanilla, object-oriented attribute assignment.

If we say,

protagonist.hp = protagonist.hp - 10

We just can't load in information about HOW or WHY or WHO lowered that value. We NEED some kind of special object with special methods that simulate 'assignment'. In our case, we're using an object called DynamicAttribute which simulates a vanilla, object-oriented 'attribute' but which you DON'T assign using the assignment operator; instead, you assign it using a special method, 'update,' which requires that you supply the identity of whoever is 'perpetrating' that change.

I was really hoping to negate the necessity for 'protagonist.hp.value,' but it seems that we don't really have that luxury.

I mean, would it make more sense to just give 'DynamicObject' the method 'update(),' and then, when we changed the protagonist's health, it would be like this:

# This is what I want, but it doesn't supply a perpetrator.
protagonist.hp = protagonist.hp - 10

# We have this. The hp attribute is not an integer, but a DynamicAttribute.
protagonist.hp.update(protagonist.hp.value - 10, monster)

# We could do this, but it's the same issue, really.
# This way, we can access protagonist.hp as an integer, but we still can't
# assign directly to HP. It's the same problem, though; it's unintuitive.
# If, one time, you forget to call protagonist.update_attr and instead call
# protagonist.hp =, then Rules won't get triggered.
# This way makes more sense. It's more clear what's going on. It's saying
# very explicitly, "update this value but also do some other things (check
# rules)." Basically, we're creating our own __setattr__ method, except that
# it takes a perpetrator argument.
protagonist.update_attr("hp", protagonist.hp - 10, monster)

We gotta play 3rd Strike, but I guess, for our next sit-down with this, it probably would make sense to replace DynamicAttribute with DynamicObject. DynamicObjects can have their attributes updated through a method, 'update_attr', which explicitly checks rules.

protag.hp = protag.hp - perp.damage

That doesn't work because, to override __add__, we would need to override 'integer', in this case.

We gotta end the stream. We'll definitely sleep on it. I still think that the most elegant way is closer to what we've been doing, but maybe we would go toward having DynamicObjects with an update_attr method instead of DynamicAttributes with an update method.

But it's definitely worth looking at subclasses 'int' and seeing if we want to override the behavior of straight-up numbers so that we can add them together and get special information out of it. Worth looking at it.

04/18/19

Now that we've replaced the old 'DynamicAttribute' way of handling the rules with the 'DynamicObjects,' we've solved our problem of having to access attribute values using object.attribute_name.value .

So, the old way of updating an attribute in such a way that it would trigger rules was like this:

my_unit.hp.update(new_hp_value, enemy)

The problem with this was that, in order to see how much HP 'my_unit' currently had, we had to access it like this:

my_unit.hp.value

With this NEW way, if we want to update a value in such a way that it would trigger rules, we do it like this:

my_unit.update_w_rules("hp", new_hp_value, enemy)

And then we can access the unit's current HP like this:

my_unit.hp

I think that's a little more elegant. It's a little bit more clear what's going on. It's much easier to access attributes in a sensible way. The only downside is that we STILL can't just use vanilla assignment -- but that's probably for the best, really. I mean, it's very important with object-oriented programming to minimize 'side-effects' -- that's a danger of 'state'. When you start overriding 'addition' and 'subtraction' and, if we could, 'assignment' so that it does OTHER things aside from what you see on the tin, then that's probably not a good idea.

It probably makes sense to use an overt method for triggering rules when a value is changed. That way, anyone looking at the code can tell that's what it's supposed to do. Otherwise, if we COULD override assignment to do the same thing, it might be easier to read AT FIRST:

my_unit.hp = new_value

But then it might be confusing when crazy shit starts happening just because we made an assignment (if we could do that). So having a separate method probably makes sense.

DynamicObjects need to know their own list of Rules. The Rules are subservient to the Battle object. Does the Battle object need to be a DynamicObject.

Well, yes. Yes it does. Let's say that we could somehow re-construe 'active_party' as an attribute of the parties, themselves. Like, party.is_active = boolean. Even if we could do that, I don't think there's a way to have a Rule like this if the Battle is not a DynamicObject:

Status Quo: Whenever a new Rule is added by Party B, Party A gets their health restored.

For this reason, I think it makes sense for the Battle object to be a DynamicObject.

But. A problem arises. So far, our DynamicObject.update_w_rules method assumes that all of DynamicObject's attributes are immutable. It takes the old value and replaces it with a new value. That doesn't really work for mutable objects, such as lists, which might change and require rules to be triggered when a new value is appended to them. Is that going to be a problem?

Well, the first thought is that every attribute of a DynamicObject that's going to trigger rules MUST BE TREATED AS IMMUTABLE. This is a necessity because so much of the 'report' system, based on DynamicEvent, is founded on the idea of comparing the OLD VALUE to the NEW VALUE. We're always gonna need to know what the OLD VALUE was and what the NEW VALUE is. That's super important to the very basis of the Dynamic Rule system.

So, if you have something like a LIST -- like, let's say that you have a Rule that gets triggered whenever an item is added to the leader's inventory. In order to compare the old list to the new list, we need to have two different lists: so, we're talking about mutable objects being treated as immutable. We almost might as well just use tuples.

I'm not sure if that's a problem. I don't necessary THINK that's a problem, except for what I just got done saying about the DynamicObjects needing access to a permanent, mutable reference to the current battle's rules. THAT BEING SAID, we also just found out that the battle's 'list' of rules is actually a dictionary.

So, maybe the dictionary is what gets passed in to DynamicObject and the DICTIONARY never changes. It just contains a before and after phase.

The Battle object has a dictionary, 'Battle.rule_phases'. It's a dictionary of phase-names to the lists of DynamicRules that are checked on that phase.

As a DynamicObject, we could call 'update_w_rules' on it -- BUT WE COULD NOT use that method to change a List of rules, because the Lists of rules are not attributes of our DynamicObject: they're values in a Dict which is an attribute of our object.

So, as of right now, if we wanted for a Rule to trigger when a new rule is added to battle, it would need to work like this:

new_rule_phases = {}
new_rule_phases["before"] = battle.rule_phases["before"].copy()
new_rule_phases["after"] = battle.rule_phases["after"].copy()
new_rule_phases["after"].append(some_new_rule)
battle.update_w_rules("rule_phases", new_rule_phases, perpetrator)

We have to treat it as being immutable. We have to make a whole new dictionary with whole new lists and replace the old dictionary of lists.

It's kind of ugly, right now, but I think that's mostly because we have this dictionary, "rule_phases," when maybe we just need to use attributes. That's one major reason it looks ugly. Maybe we should do something more like this:

battle.before_rules
battle.after_rules

Instead of,

battle.rule_phases = {"before": [], "after": []}

Having a dictionary for rule_phases is kind of wasteful, because we're just matching a string to a value -- and that's exactly what object.__dict__ is for. If we're just matching a name to a value, we might as well make it a attribute. It's not like we're going to be dynamically adding in more keys to this dictionary.

On the other hand, I think that having a dictionary of phases makes it more clear how we process the rules. Because attributes have no order (technically, neither do dictionaries, but at least they have a visible order in the source code). We treat both phases equally, just one after the other. So, by having two totally separate attributes, you sort of lose that relationship -- abstractly, they're the same thing, just different phases.

Here's my idea: what we need is a new type of object, 'RuleSet'. RuleSet has attributes:

RuleSet.before
RuleSet.after

What's cool about RuleSet is that it can be a DynamicObject. So, when RuleSet.before or RuleSet.after is updated, we can trigger Rules. And, by virtue of being a classed object, RuleSet is mutable -- so we can pass in a RuleSet when defining a DynamicObject.

But hang on though. How do we pass the RuleSet as its own RuleSet.

Let's go implement that.

Today, in review, we really drastically changed the way that our dynamic_system library is laid out and the way that it behaves, internally. The result is that its API has effectively changed, although it works mostly similarly. The 'battle' library is completely broken by these changes and needs to be adapted to the new dynamic_system. Also, our actual mock-up at 'rules_and_events' mostly needs to have its example DynamicRules updates to match the method-name changes of dynamic_system.DynamicRule .

It should be a relatively quick porting job, but we don't really have time to do that right now. That'll be our project for Monday: get everything working again, so that it's as effective as it was BEFORE -- but with much cleaner internal code.



04/22/19

We have a problem. Understandably, our new Ruleset object has two attributes -- 'before' and 'after' -- which reference lists of DynamicRules to be checked on those phases.

To this end, we removed the old 'check_phase' attribute from the DynamicRules, themselves. They don't need to know their own check-phase.

But, if the DynamicRule object doesn't have a tag that we can use to find out its check-phase, how do we know which list of Ruleset to add that Rule to at the start of battle (or any other time).

It seems to me like the DynamicRules DO need to have some way to communicate when they're supposed to checked. So... That seems a bit redundant considering that our Rulesets also have 'before' and 'after' lists.

On the DynamicRules, the 'check_phase' attribute could be thought of as a 'tag,' because it's not an attribute in the sense that the Rule, ITSELF, will ever access that attribute. Usually when you have an object and it has attributes you're going to be using those attributes in the methods of that object.

In this case, it's just important that other objects which play with the DynamicRules be able to tell when that Rule is supposed to checked.

Let's review the basics of the 'dynamic rule system' and then talk about how our code is laid out.

In many JRPGs, characters can inflict and be inflicted with 'status changes': 'poison', 'paralyze', etc. Also, they can use 'buffs' to give themselves and their allies a temporary boost to some attribute.

The central gimmick of our game's combat system is that these status changes take on a much more significant role. For one thing, every status change can be complex beyond what we're used to seeing in JRPGs.

Instead of having a vanilla 'poison' attribute, we're talking about having a 'DynamicRule' that says something these along these lines, which some kind of 'rogue' class might have inflicted upon their opponent:

When the inflicted target uses any skill to heal an ally, they take damage equal to the amount that their ally recovered.

That's a 'dynamic rule'. The idea beyond inflicting these 'status changes' is to limit your opponent's options and to strengthen your own team's dynamic. Buffs behave the same way:

Whenever the target gains attack power, they also gain defense.

As you might imagine, implementing a system like this, in OOP (or otherwise), is an interesting challenge -- because we're talking about being able to dynamically alter the rules of the game, itself.

The solution that we've come up with is what I'm going to show on-screen right now.


This stream, today, hasn't been a huge success in terms of making progress, and a part of that is, coming back from the weekend, I'm not 100% sure of where the version 4 mock-up begins and the version 3 mock-up ends

The big changes in the version 4 mock-up are as follows:

DynamicAttributes are being traded for DynamicObjects.
We're implementing 'Ruleset' objects, which manage all of the rules in a battle.

Because of those two changes, we need to re-write all of our existing test DynamicRules: Invincible, Hench, ExtraDamage, Persistence, Rage, MagicMan, OldManGenes.

Where we're at, right now, is how do we append new DynamicRules to this Ruleset.

I think that DynamicRules still need a 'check_phase' attribute. They need this attribute because, when we add the rule to the game, we need to know what phase to append it to. It's kind of sloppy, it's kind of ugly, it's kind of redundant. I don't like it.

One solution, at least as far as REDUNDANCY, is to have the Rules in a Ruleset all be a part of 1 list -- and then, when you're checking the 'before' phase or the 'after' phase, you just use a list comprehension to create those phases.

Let's make a very simple "append rule" method and fix the DynamicRules to have a check_phase attribute.

Just to celebrate Penguin joining the stream (and because I'm on the fence myself), we'll go with having only one list of Rules.

I have a problem. When should the recurrence counters be reset?

The obvious solution would be to reset them once the 'after' phase is completed.

But I'm not sure that's what we want, because the main thing that DynamicRules do is CREATE OTHER UPDATES which, in turn TRIGGER OTHER RULES. So, if one update completes and the recurrence counters get reset, couldn't that cause bugs with other updates happening at the same time? I want to say yes, but I can't prove it.

If I have two rules that read as such:
"If Vencabot takes damage, he loses attack power."
"If Vencabot loses attack power, he takes damage."

That's an infinite loop, and that's why we implement the recurrence counter.

Let's draw up an order-of-operations for if the recurrence counters were reset after a successful update.

We propose an event where Vencabot takes damage.
Nothing triggers in the Before phase.
In the after Phase, we update Vencabot's attack power.
We propose a change to Vencabot's attack power.
Nothing triggers in the Before phase.
In the after Phase, we update Vencabot's HP.
In the before phase, nothing happens.
In the After phase, we try to reduce his attack power, but we're at the recurrence limit.
Now that Vencabot's attack power has been updated, recurrence counters get reset.

THE BUG HAPPENS RIGHT HERE. If we DID have more Rules than just those two, we would have a problem with recurrence counters being reset after his attack power was updated.

Now that Vencabot's HP has been updated, recurrence counters get reset.


But the 'update' happens in the SAME THREAD. So, we don't reach the end of the first 'After' phase until we're done processing this attack power update.

So, we can't reset recurrence_counters after a successful update. We have to reset them once all updates on all phases are complete.

So, this is a job for an object much greater than what we're working with, now. Basically, the recurrence_counters would need to be reset between unit turns -- and, right now, we don't have a mechanism for moving between unit turns or otherwise completing an entire action.

Well, I mean. That's a problem. We could implement this 'recurrence_counter reset' at the end of every Ability in the game. But, the problem with that is that we have actions the player can take which aren't strictly 'UnitAbilities', such as Swapping team members, using items -- attempting to flee from combat or whatever -- which should be able to trigger Rules (and, by extension, reset recurrence_counters).

Basically, we might need some kind of parent object which abstractly represents an entire 'action'. An action that can trigger rules -- and, when it's over, the recurrence_counters get reset.

For now -- for mock-up version 4 -- let's just reset them MANUALLY. We're gonna reset the recurrence_counters manually.

Our dynamic_system_4 library is complete for mock-up 4, as of now.
battle_4 objects need porting. They still use 'DynamicAttributes' instead of 'DynamicObjects'. That's our project for Wednesday.

Once that's ported over, we'll need to rewrite rules_and_events_4 somewhat drastically especially to change the way that our existing 'test rules' operate.



04/24/18

Today, we're porting over the battle_4.py so that it's compatible with dynamic_system_4.py -- and that means, mostly, taking situations where we were using DynamicAttributes and replacing them with situations where we can use DynamicObjects. The other big change is that we're using Rulesets, now, with our Battles.

One thing that I want to point out right away is that we need to temporarily dial-back our features to accommodate the changes for the version 4 mock-up. A lot of the problems that we had with Version 3 which necessitated the move to Version 4 are problems that we're not going to be prepared to handle, yet, until we get our old mock-up battle running, again.

So, that means that we're not fucking around with turn-taking yet -- alternating turns between parties. We're just going with a mock-up where somebody is slapping somebody else 4 times in a row.

So far, in our code -- considering that we now have a 'Ruleset' object -- our Battle object is entirely pointless. Before, the Battle object's main job was to contain the DynamicRules -- but, now, Rulesets do this. Of course, I think, in the very near future, we're going to need more from the Battle object -- especially when it comes to accessing all of the Units that are currently in battle.

For now, though, we could probably do without it.

Maybe, the thing to do -- with respect for where this code is HEADED -- would be to create a DynamicRule, today, which necessitates the use of a Battle object.

The most fundamental purpose of the Battle object would be to -- I don't know. Let's make a list, real quick, of what sorts of data would sensibly be contained in a 'Battle' object -- an object which represents the STATE of the current battle.

A Battle object would have data regarding:
    * What parties are taking place in the battle.
    * What the battle's ruleset is.
    * Outside of the MECHANICAL aspect of battle, it might contain data
      regarding presentation: what sort of environment the battle takes
      place in.
    * Maybe information regarding whose turn it is and methods for in-
      crementing turns.

If the Battle is, itself, a DynamicObject, then it inherently knows the Ruleset.

It's important to have some object at the top of hierarchy which knows all of the parties in battle.

Lemme dial that back: we only have TWO parties in battle. I'm getting ahead of myself. Sometimes I think that, with how far we've abstracted a lot of our battle code, so far, we could hypothetically easily create battles with more than two parties. I feel like, as long  as we stay on this course of abstraction, that would be trivial. But as soon as we start to INFORM our DECISIONS to maintain the possibility of many-teamed battles, we're going off-course.

We have two parties. It's still important that we have an object at the top of this hierarchy that knows both parties, because we need that in order to have Rules like this:

If Unit A is healed by Ally Unit B, then a random enemy unit takes damage.

That sounds like a very simple rule considering our mechanics so far, but the problem is that Unit B healing Unit A generates a DynamicEvent report -- and, since neither of those units is on the OTHER team, the Rule receiving that report has no way to access the other team.

Maybe I'm going about this wrong. This is a bugbear of object-oriented programming, in general. This is a problem of state. Is it actually wise to be able to access a random unit on Party B when you're only given a unit from Party A. Why should a function be able to mess with Party B if it's only given a unit from Party A as an argument.

Maybe this is not indicative of us needing a top-level object. Maybe it's indicative of the fact that we need to re-assess the way that our functions are doing their jobs. Is there a way that we can better-manage the arguments that we're providing to our functions so that it's more clear how data is being accessed.

Here's what I do know: DynamicRules need to have access to EVERYTHING in a battle. Yeah, they get a report in the way of DynamicEvent and they can use that report to DECIDE what they want to do -- but their access to the battle shouldn't be limited to what they have in that report. That's a problem I just realized that we have. It should go without saying that any DynamicRule should have access to every single object in a battle.

What's cool about this revelation is that it makes you think about how VERY FEW OPERATIONS in battle actually need access to all of this data. It helps us to trim down our state.

Like, why should every Unit have some kind of reference to every other object in battle. I'm pretty sure it would never, EVER need that. I'm starting to think that, really, only TWO things need access to everything in a battle: the RULES and whatever code we use for the INTERFACE. The player needs to be able to do things like TARGET ANY UNIT that they want for an ability. The player needs to be able to CHECK ALL OF THE RULES.

So the PLAYER needs access to all of this stuff. And the RULES need access to all of this stuff.

I'm pretty sure no other object in battle -- be it a 'Party' or a 'Leader Unit' or a 'Battle Unit' actually need to know jack shit. I think we're giving these objects WAY too much access to data. We need to trim down our state.

Let's re-examine the way that DynamicRules are instantiated. Because I want for them to have EXPLICIT ACCESS to everything in a battle.

Before we even start taking DynamicRules apart, let's look at our other battle objects and decide if they fucking EVER need access to their parent objects. Maybe we could have a true hierarchy where slave objects are not even aware of their master object. That would cut down on SO much redundancy.

Why do we have a Party object which has Units and a Leader when we could just have a Leader object which knows its subordinates.

Mock-up version 4: no more Parties. Instead, we just have LeaderUnits, and they have subordinates.

For some reason, we have our Units set up so that they can have more than one ability by the same name. One Unit could know two different moves that are called 'slap,' and they could be both totally different moves.

I'm not sure I'm about it. I had this idea of moves that have VARIATIONS. The idea was that, if "Pikachu" learns 'Thunder Shock' at level 30, then maybe different Pikachus would learn fundamentally different takes on 'Thunder Shock' at level 30, as a way to make each pikachu more unique.

I still think that's a cool idea, but do they REALLY need to all have the same name. If we have 5 variations on Thunder Shock, couldn't we call them different stuff, like, at level 30, a Pikachu might learn:

Super Thunder Shock
Poisonous Thunder Shock
Sticky Thunder Shock
Cruel Thunder Shock

We could give them different names but have them be variations on the same ability. I don't think it's a good idea at ANY point in our development to entertain the notion tha ta single unit might have more than one ability with the same exact name.

So, I'm just going to change the Unit's ability attribute to a list. Yeah, it means that we won't be able to access it, INTERNALLY, by name, any more -- but we can fix that later.

Is it safe to say, for the purpose of managing state, that an object should only manage data that's unique to that object. That sounds right when I say it like that. I mean, internally, there's really no good reason that a unit should need to have a list of its own abilities -- or, if it does, the ability doesn't need access to its owner.

What if we moved UnitAbility.use(targets), to, BattleUnit.use(ability, targets).

Now, the ability doesn't need to know who its owner is, necessarily.

Let me ask a very important question to the future of how our objects are instantiated:

DO WE NEED TO INSTANTIATE ABILITIES. Should they just be classes that are never truly instantiated -- class methods, class attributes. What is unique about one Slap compared to another.

The obvious answer is that, if we want for units to be able to POWER UP or LEVEL UP their abilities, which would not be unusual in a JRPG, then they need to be instantiated.

But I mean, OTHERWISE, no, right? We don't need for there to be 10 different 'slaps' floating around.

I want a structured concept of an 'ability,' but I just want one of them. I want for there to be only one 'Slap'.

Would it make more sense to have a class, Slap, and INSTANTIATE IT ONCE PER BATTLE (or whatever -- per game sitting, per launch -- per state), or would it make more sense to create a CLASS and then just use its CLASS ATTRIBUTES and CLASS METHODS to get our job done -- or is there a third option that I'm not aware of?

With this new approach, an Ability is just three functions:

_use_glancing
_use_normal
_use_critical

These functions should have access to each other (so they're probably methods) so that _use_critical can just run _use_normal and then do something extra. It could almost just be one function. It's just that every 'Ability' can occur 3 different ways.

With my education, it just seems like you would want to make a class with class attributes (if necessary) and class methods. And you would never instantiate that class. It's just... the fact that you would never need __init__ is what makes me feel like maybe it shouldn't be a class.

Maybe I just need a dict like:

slap = {"_use_glancing": some_callable, "_use_normal": some_callable, "_use_critical": some_callable}

The problem with this is that the functions can't access each other. Also, in terms of architecture, we now have to define our Abilities like so:

def slap_use_glancing(user, targets):
    pass

def slap_use_normal(user, targets):
    pass

def slap_use_critical(user, targets):
    pass

slap = {"use_glancing": slap_use_glancing, "use_normal": slap_use_normal, "use_critical": slap_use_critical}


singleton Slap:
    def method_1(single, arguments):
        pass




Abilities should have access to the whole battle. Even if the explicit 'target' is Unit B, the ability might want to splash damage to a random opponent -- or a random unit. We could have an Ability defined as such:

Big Shell: "Hits target for massive damage but at the risk of misfire damage to a random unit on the field."

So yeah, you target a particular unit, or units, or whatever -- but Abilities still need access to the state of the battle.

We have a problem. An interesting problem. We just got done talking for like an hour about how Abilities don't need to be instantiated -- but if Abilities are gonna have access to the current state of the battle, they gotta be instantiated.

Maybe it would make more sense to give the 'battle' object as an argument to use_glancing, use_normal, and use_critical.

But, we have a problem. An architectural problem.

Never mind.

The problem with giving the 'battle' as an argument to use_* is that the Unit doesn't know what battle it's a part of.

Are we being overly cautious? When you're working with object-oriented design I feel like it's a battle between over-relying on state and under-relying on state.

I'm gonna make a hard rule: NO. REDUNDANT. REFERENCES. That's where we're drawing the line.

Right now, with our Rules behaving as they do, ABILITIES CAN BE PERPETRATORS. That way, we can say,

Steel Cheek: If Unit_A is Slapped, they will take 0 damage.

We've lost this rule:

Steel Cheek: If Unit_A is Slapped by Unit B, they will take 0 damage.

Maybe it does make more sense for a report like DynamicEvent to supply more information: the PERPETRATOR and WHAT THEY DID.

Before, because Abilities were instances that knew their owner, we could INFER the actual unit using the ability knowing only the ability that was used. But now we don't have that luxury.

But I kind of like the idea that Abilities are things that you DO, and, as such, they don't really need to be instantiated. So maybe the perpetrator could be the UNIT, and then there's another attribute of this report which explains what Ability was used.

The problem with this is that, historically, 'perpetrators' haven't always been Units, either. For instance, a perp might be a Rule.

If we have a Rule that says,

"If Unit_A takes damage, then they gain attack power," sure, it could be triggered by Unit_B using Slap -- but it could also be triggered by a Rule that says, "Every unit on Party A takes 1 damage every turn."

I mean, it seems like we definitely have a limited number of objects that can be a perpetrator.

Before, only Units, Abilities, and Rules could be perpetrators of a DynamicEvent.

Now, I'm feeling like we have two types of perpetrators: Units and Rules. If the perp is a Unit, we also report what Ability they used.

Maybe a part of solving this problem would necessitate looking at a Rule like this. We couldn't make this rule work, before:

"If Unit_A takes damage from a Rule implemented as a result of Unit_B using Poison Slap."

This requires a report more complex than we've ever fucked with. We need to know what ABILITY implemented the Rule and we need to know what UNIT used that ability.

It'd be ideal if the Rules were, like abilities, just a static class. In our mockup-3 code, the Rules were also instances because they needed to know --

The Rules have to be instances, because they might need things like arbitrary counters, and they definitely have a 'cure condition' which is going to be updating over time.

So, the Rules could save some data regarding what ABILITY SPAWNED THEM and what UNIT used that ability. That's a luxury we can afford because Rules need to be instances.

But that same design doesn't follow for Abilities, which seem to be working more-or-less just fine without being instances.

The good thing is, with this trail of logic, ALL REPORTS WOULD DEFINITELY have a perpetrating unit and a perpetrating ability, right? Maybe not.

So, basically, where we're at is we're re-examining our DynamicEvent report system. I think, we have two options presented to us:
    * Go back to having 'redundant references' between objects, which means
      that object A has a reference to object B and object B has a reference
      to object A. This is what we had before, I've done this with many
      other projects in the past. It's just mad ugly and can cause some
      terrible bugs.

    * The other option is to somehow give more information in our
      DynamicEvent reports and ideally make it uniform in some way.


Maybe there is no way to make it uniform. Maybe we just need different kinds of reports depending on what sort of object is abstractly 'perpetrating' the attribute change.

Maybe we need a different format of report of Unit A's HP is lowered by rule Poison vs if Unit A's HP is lowered by being Slapped by Unit B.

Penguin's talking about a 'foreign key' to associate things together.

Maybe he's saying that the Leader doesn't need to know the Subordinate and the Subordinate doesn't need to know the Leader. Instead, they both know the Battle, and the Battle has a dict of leader -> units.

That way, you don't even necessarily have a hierarchy of data: you have a sort of CENTRAL structure that coordinates all of the objects that orbit it.

class Leader:
    def __init__(self):
        self.suboordinate = None

class Suboordinate:
    def __init__(self):
        self.leader = None

leader = Leader()
suboordinate = Suboordinate()

suboordinate.leader = leader
leader.suboordinate = suboordinate


At some point in your code, you do:

suboordinate.leader = leader

But you forget to do

leader.suboordinate = suboordinate

To solve this problem, on the leader, I used to have a method:

class Leader:
    def __init__(self):
        self.suboordinate = None

    def append_suboordinate(self, suboordinate):
        self.suboordinate = suboordinate
        suboordinate.leader = self


04/25/19



04/29/19

So, the order of the Rules is significant when determining whether or not they'll trigger, which can be confusing for the player. For instance, if 'Invincible' is triggered before 'Hench,' Hench will not trigger -- because Hench will only trigger if the target_unit was going to do damage.

So, if Invincible triggers first, then the attack isn't going to do damage, which prevents Hench from recognizing that an attack was attempted.

That's fine. We can just word 'Hench's trigger condition as, "If an attack would have done damage, damage is doubled."

That's great, BUT, with our new and improved DynamicEvent report system, we can actually go back in time and see that an attack WAS attempted even if the damage is going to be absorbed.

So, maybe we should use that extra knowledge to make it more clear to the player what's happening.

If KreichJr has a rule on him that says, "If Vencabot attacks KReichJr, Vencabot takes poison damage." I don't want Hench to affect the poison damage. Is there a way, given our current DynamicEvent reporting system, that I can implement this?

What's the difference in DynamicEvents if Vencabot is dealing extra damage from Hench vs if he's dealing extra damage from Poison?

Well, actually, that should work fine -- because the extra damage from Hench REPLACES the original damage. The extra damage from poison ADDS NEW DAMAGE. So, that answers my question about whether or not the 'original event' can have a triggering_rule. The answer is "yes."

In the case of poison, the ORIGINAL EVENT would have a triggering_rule value.

GOOD NEWS! It seems as though our new Dynamic Rule System is fully functional -- not only insofar as being as feature-rich as it was before, but also such that we can implement all new kinds of rules and features (including custom error messages when a rule fails to trigger in a situation where a player might have expected it to trigger).

That means that, next time (Wednesday), we should go about experimenting with Rules that we couldn't have gotten working before, including Rules that are triggered when different Leaders get their turns, or even some example Rules where we maximize the complexity of our reports (DynamicEvent), which would be worded along the lines of:

"Vencabot gains HP when KReichJr triggers Persistence by attacking Zanzhu with Slap three times."

We need to find situations where we'd WANT to trigger Rules where, up to this point, we haven't been able to, such as:

On a turn change.
When a new Rule is added to the ruleset.



05/01/19

So, last night I was thinking about the way that our Rules are currently working, internally. Right now, they're split up into three main methods which can be overridden when defining a Rule:

'will_trigger_on' is a method that returns True or False depending on whether or not the Rule will trigger on a certain DynamicEvent.

The 'trigger' method is separate from that just so that we have some tidiness, internally. I think it's a bit nicer to be able to see, separately WHAT triggers a Rule and then what it does when it's triggered.

Finally, we have an optional 'fail' method, which is triggered only when will_trigger_on returns False. It can take the same DynamicEvent and return a custom error message (or animation or whatever) depending on WHY the Rule failed to trigger (especially in situations where the player may have expected it to trigger).

That's all well and good, but it strikes me that this rigid structure -- this rigid abstraction -- of Rules either "triggering" or "not triggering" -- this binary -- limits what we can do with our Rules.

For instance, what if I want to have a DynamicRule which gets more severe if a secondary condition is met.

Let's give an example:

Vencabot takes poison damage after every action he takes. If Vencabot is healed by another unit, the poison's severity increases.

So, in this case, we have a sort of double-decker Rule. It's "triggered" in two different situations, with two different results:

Vencabot takes an action. -> He takes damage.
Vencabot is healed by another unit. -> The poison's severity increases.

With our current mechanisms in place, perhaps the most sensible thing to do would be to split this over two different Rules.

But my thinking, last night, was that it would make sense to de-standardize the whole 3-method DynamicRule override.

Instead, we would have only ONE standard method, which would be called something like, "process_event". You feed it a DynamicEvent, and, instead of returning True or False, it will automatically call any number of methods based on the event that it gets.

That's much simpler. Although it would be nice to have a standard so that all Rules look the same, to some extent, it does sort of limit what we can do with our rules -- and that's been something that we've been butting our heads against for a long time, now. The balance between maintaining clear-to-read 'standards' but also keeping the 'dynamic' part of 'dynamic rule system'.

I think the best compromise would be to have Rules with this one standardized method, "process_event". Then everything else could be unique to that Rule.

But what I didn't think of, last night, was the possibility that we could split these complex Rules over more than one Rule. Right off the bat, I don't think this is the best solution, but I don't want to write it off until I consider the pros and cons thoroughly.

Pros of splitting complex Rules over multiple, simpler rules:
* We can keep the Rules internally standardized with a simple 'trigger' method. When it triggers, it triggers; it can't trigger in a variety of ways.

* It might be simpler for the player to read. It means that individual rules are easier to parse, and it's easier to understand what's going on when an action takes place because each summary of a rule is simpler.

Vencabot takes damage every time he takes an action. The damage is increased every time his HP is healed.

Vencabot takes damage every time he takes an action. (Poison)
Vencabot's Poison increases in severity whenever his HP is healed.

The cons of splitting complex Rules over multiple, simpler rules:
* It means that we need more Rules to describe what might be, conceptually, a single idea.

* It might add problems when we consider that Kenny and I have been working with different ways to balance Rules. The idea that I've settled on is to limit the number of Rules that a single unit can be subject to at once, and that means that, if we have multiple, simpler rules, we're gonna hit that limit a lot faster and may need to reconsider this as a balancing method.

* If we have Rules that are directly impacting Rules, we may need a way to communicate to the player exactly what Rule we're talking about. In the example above, we had to clarify that the first Rule is called 'Poison' so that we could later clarify that Vencabot's 'Poison' is what's going to be increasing in severity.



Much to my surprise, putting the pros and cons side-by-side makes me realize that there really isn't that big of a difference between the two options. Maybe de-standardizing Rules isn't as much of a benefit as I first expecting. I would say that the REAL difficulty with splitting complex Rules into simpler Rules is that it becomes difficult to decide how to limit rule-stacking on a single unit.

The way to deal with that would be to consider the SECOND Rule in our example ("Vencabot's Poison increases in severity when his HP is healed") to not be stacked on VENCABOT but rather to be stacked on the POISON -- as though Rules, themselves, could have slots where they take on other Rules.

Is that a more elegant solution? Maybe.

Before we go too deep down that rabbit hole, let's consider what I expected to be a standard feature of all Rules: 'trap' conditions and 'cure' conditions.

When we were discussing everything we could explore with the Dynamic Rule System, we talked about how, instead of just 'curing' or 'dispelling' a Rule using some kind of Final Fantasy'esque "Dispel" or "Remedy", Rules should be curable BY those but also by fulfilling conditions, such as, "5 turns pass," or, "Vencabot is swapped to the back row." It could be anything. It could be, "Vencabot's curse is cured when he's attacked 3 times." It could be anything. That would be a 'cure condition'.

'Trap conditions' would be situations where a Rule has NO EFFECT when it's put into play, but it would be THREATENING the affecting team by saying something like, "If Vencabot attacks 3 times, he'll become subject to poison for 10 turns."

In that case, we're limiting what Vencabot can do not BY inflicting poison but by inflicting the THREAT of poison.

So, one option, programming-wise, would be to standardize these 'trap' and 'cure' conditions as a part of the DynamicRule object.

But it was during my meditions about this that it struck me that perhaps it would make more sense to destandardize the DynamicRule object and allow each Rule to decide, on its own, how to process any given Event with any number of conditions and results.

Because, like I mentioned earlier, having a standardized 'trap' and 'cure' conditions doesn't cover the possibility of a condition that increases or decreases the SEVERITY of some effect. Maybe, under a certain condition, the TARGET of an affect is changed. Because these Rules are truly meant to be 'dynamic,' I feel like, to maintain the most freedom, we need to limit how much standardization we do between them.

On the other hand, one thing I've found in some of my previous projects is that, when you refuse to standardize a mechanism so that it can be as FLEXIBLE as possible, what you end up with is a situation where you actually have no objects or anything concrete. Things become so abstract that you're essentially just re-writing the language that you're composing your code in.

So, what we end up with is essentially two possibilities:
We allow for COMPLEX RULES which take a DynamicEvent and process it FREELY. We do away with the abstraction of the 'triggered' or 'un-triggered' binary and, instead, allow every Rule to do whatever it pleases with a certain Event. That seems reasonable, to me -- and powerful.

Or we could enforce SIMPLICITY on INDIVIDUAL rules, but have them be able to STACK ON EACH OTHER. So, considering things like 'cure conditions,' 'trap conditions', 'severity change conditions,' 'target change conditions' -- all of these things. You could stack them, as MULTIPLE RULES, like this:

Vencabot takes poison damage after every action he takes.
    - Rule is supressed until he attacks 3 times.
    - Rule is cured after he is attacked 3 times.
    - Rule changes target to whoever heals Vencabot.

All four of these rules can only trigger under a single circumstance and have a single effect. So, we can maintain the 'triggered' or 'untriggered' binary. It is quite simple to read. That's an advantage.

I'm starting to see that a problem with THIS mechanism is that, when you have Rules that change the effect of other Rules, it becomes difficult to know what order to process the rules in. How does the first sub-rule -- the trap condition -- suppress poison. For one thing, it wouldn't be written that way. It'd be written such that the Trap Condition is the PRIMARY RULE, and it later 'creates' or 'initiates' the poison rule.

But that doesn't really answer my question about Rules stacking on other Rules. Supposing that we do allow for Rules to stack on other Rules (which I think is very sensible), what if we had a Rule that suppressed another Rule until some condition was met. How would we go about doing that?

The most obvious way to suppress a Rule would be to simply give every DynamicRule a flag -- True or False -- which communicates whether or not it's suppressed. We definitely need more standard attributes for Rules, including their Severity level, which is a mechanism that I do want to be standard across Rules: the ability to raise or reduce severity.

We still have this problem of ORDER of operations when you're talking about Rules which affect other Rules.

I mean, maybe there is no problem there: maybe it's just first-come, first-served like we've been doing. I can't immediately imagine a situation where that would be a problem.

What's cool about THIS method -- keeping Rules simple, individually, but having them stack on each other -- is that it opens up a whole new class of unit abilities where we can manipulate existing rules. Like, we do want to have a class which could have an ability like, "choose a rule to suppress for 3 turns." That makes sense.

Maybe we want a class with an ability like, "change the cure-condition of a rule," or something like that.

I feel like, even if we have super-complex rules, we're going to need to allow rules to stack on rules, and we're going to need to STANDARDIZE some situations.

We can't get away with NOT standardizing things like TRAP CONDITIONS or CURE CONDITIONS, because we need to be able to have abilities which EXTEND trap conditions and SHORTEN cure conditions.

I would say that the MAIN disadvantage of splitting complex Rules into an arbitrary number of SIMPLE Rules is that it becomes a bit more difficult to convey to the player that this 'package' of Rules all conveys a single concept.

But, I don't necessarily think that's a big issue.

To clarify what I mean, I'm imagining a UI for the player to peruse to understand what Rules are in play in the current battle -- and, now that I think about it, this isn't a problem that's unique to 'rules-stacking-on-rules'. Our Dynamic Rule System IS so dynamic, by design, and creating a UI that makes it easy for the players to understand what Rules are in play is going to be a challenge.

Maybe, instead of going into too much code, today -- we've only got another forty minutes, here -- maybe we should begin musing about UI and maybe make some decisions about how this system is going to play out based on that. With DynamicRules being hypothetically so complex, what is an effective way to communicate what Rules are currently in play so that the player can make decisions effectively and understand the flow of battle.

Taking WORKING examples from the genre, you would TYPICALLY have STATUS CHANGES be AFFIXED to a UNIT. Usually, this is communicated with an icon over the unit's head and probably some entry on their 'status' page.

That's how you would handle traditional Poison, and Blind, and Protect, and all of these abstract 'status changes' which are one of the closest things to our idea for DynamicRules.

It's been brought up that DynamicRules also have some similarity to the 'Law' system in Final Fantasy Tactics Advance and its sequel. In those games, the only way to know what Laws are in play are by bringing up a special 'Laws' screen which just lists them, top-to-bottom. But it should be noted that this only works because Laws don't target any individual unit AND there's a very limited number of them per battle. You typically would have less than 10 laws per battle, and they're pretty easy to explain on a single line.

Let me propose an abstraction: CAN WE SAY that EVERY RULE has a TARGET? In the past, I've considered that, and I've usually just defaulted on, "No," you can't strictly say that every Rule has a target.

But maybe, if we think more about it, we'll decide that it isn't true. Maybe every Rule could be said to strictly have a target. That we could, in terms of UI, 'attach' that Rule to.

It goes without saying that some Rules target a specific unit. In our example above, "If Vencabot takes an action, he takes damage," it's clear that this Rule relates strictly to Vencabot. In a UI, we could definitely be forgiven for putting an icon over Vencabot's head or putting some kind of entry on Vencabot's status page that says that he's under the affect of this Rule.

If any unit heals another unit, a random unit on either team will die.

In the past, I've said that this kind of Rule would be said to apply to "the battlefield." So, if "the battlefield" has a status page, we could put that Rule there.

So, what are our targets?
A Unit.
A Battlefield.
A Party (leader?).

That seems fair. I don't think that there's any Rule that I could come up with that couldn't be said to target one of those three things. So, if each of those three things has a 'status' page, we could list the rules that are affecting them there.

If the Unit has a status page where you can view the Rules they're exclusively under the affect of,

And the Party has a status page where you can view the Rules it's exclusively under the affect of,

And the Battlefield has a status page where you can view the Rules it's exclusively under the affect of,

Then we can expect for the player to not have too much difficulty keeping track of what Rules are in play.

Not that we NECESSARILY need Rules this complex if it's going to fuck up our whole UI, but what about a Rule like this:

If Unit A (Party A) and Unit B (Party A) and Unit C (Party B) and Unit D (Party B) heal another unit a COMBINED NUMBER of 4 times, then Unit E (Party A) and Unit F (Party B) are killed.

That's a super-complex rule. It 'targets' 6 different units, split among both parties. I guess that would be a 'battlefield' rule, right? Or could it be said to be a Rule that essentially 'individually' targets those 6 units.

For balance reasons, this would probably need to be a Battlefield rule, and let's talk about Balance real quick.

A few weeks ago, it came to me and Kenny's notice that, by stacking a few VERY SIMPLE RULES, you can break this game -- like, super easily. The example we gave was something like this:

We have a 'priest' unit, and it's casting buffs on our team.

Vencabot takes 20% less damage from physical attacks.
Vencabot takes 20% less damage from physical attacks for 5 turns.
Vencabot takes 10% less damage from enemy units A, B, and C.

That all could hypothetically be cast in a single turn. And that's just one example. When you have as many ideas for DynamicRules and the abilities and classes that inflict them as we do, it stands to reason that breaking the game becomes trivial. Any time you can stack Rule A and Rule B on a single unit, you're risking breaking the whole game.

We'd developed this idea for WEEKS before this very simple revelation hit us.

A solution that we came up with, which I think is pretty elegant, is that we need to LIMIT THE NUMBER OF RULES WHICH INDIVIDUALLY TARGET ANY SPECIFIC OBJECT, whether it be a UNIT, a PARTY, or a BATTLEFIELD.

But there's more.

If we did that, STRICTLY, we have a problem where we have to start abstracting Rules as being either 'buffs' or 'nerfs,' which creates this binary that's contrary to the very idea of a Rule's dynamism. Because many Rules are going to have a very serious trade-off, like, "Vencabot does double damage but 1/4 is reflected back at him." Is that a buff or a nerf? I can imagine situations where that'd be inflicted on Vencabot by an ALLY and other situations where it might be inflicted on Vencabot by an ENEMY.

So, what we thought of was this: every kind of object can have a limited number of Rules inflicted upon it BY EACH PARTY.

So, Vencabot can only have one Rule inflicted upon him by his ALLIES and only one inflicted upon him by his ENEMIES at one time. The same would be true of each Party and the Battlefield; there's a limit to how much control EACH PARTY can inflict over each type of object.

This also solves the problem that we would've had regarding 'blocking' if we limited the number of rules that a single object could be under the influence of but we DIDN'T keep track of whether they were inflicted by an ALLY or an ENEMY.

For instance, let's say that we set a 'rule-cap' for each unit at 3 rules.

Well, on the first turn, the party inflicts three 'buffs' on Vencabot. Now, he's immune to 'nerfs' on the enemy turn. That's a problem.

So, intead, we limit the number of rules that can be inflicted on Vencabot by the ALLIES and the ENEMIES.

Speaking of UI, supposing that we're limiting the number of Rules, in battle, based on what object they're affecting, it's fair to say that you would peruse the current rules, in battle, by looking at various 'status screens' for the Unit, the Party, and the Battlefield. And maybe we could put icons over the heads of Units and, for the Party, an icon over the head of the Party Leader -- and, for the battlefield, icons in the corner in something.

I think that, UI-wise, it's not going to be a herculean task to keep track of what-all rules are currently in play. We can manage that.

To step back to our original question, then: yes, Rules can be said to have a specific target. And the three possible target-types would be "unit," "party," and "battlefield". And we would balance Rules -- and the whole Dynamic Rule System -- by limiting the number of Rules that any PARTY can inflict on any of those targets.

It strikes me that we have to add one more possible target type to that list: "unit", "party", "battlefield", and RULE. Because Rules can target other Rules.

SO, maybe we can even STANDARDIZE the SLOTS -- maybe not, but maybe -- that a given Rule has to entertain other Rules.

As a rough draft, a Rule could have THESE SLOTS for other Rules:

A 'cure' condition. This Rule will determine when the parent Rule falls out of play.

A 'trap' condition. This Rule will determine when the parent Rule comes INTO play.

A 'severity increase' condition. This Rule will determine when the parent Rule increases in severity.

A 'severity decrease' condition. This Rule will determine when the parent Rule decreases in severity.

It's a little bit abstract, but I think we would need some sort of wiggle-room for a Rule such as,

"Vencabot takes damage after every action he does. If Vencabot is healed, this curse moves to the unit that healed him."

For sub-rules like that one -- and probably countless others -- I feel like we can't really set aside a standard 'slot,' so maybe it makes sense for us to not have ANY standard slots for sub-rules. We just have parent Rules and sub-rules which affect that Rule. That makes more sense, because then we could have more than one 'severity increase' condition.

Lemme raise another abstract question. If Rules and Sub-Rules are the same object type, it stands to reason that sub-rules could have sub-rules attached to them. WOULD THAT MAKE SENSE?

Well, I would say that it makes sense for a sub-rule like, "If Vencabot is healed, his healer takes on this curse," could take on a sub-rule like, "Is cured after 3 turns." That's a sub-rule with a sub-rule DYNAMICALLY ATTACHED TO IT.

Okay, let's clarify one thing, here: sub-rules SIMPLY CAN NOT be SO dynamic and SO abstract that they can necessarily apply to ANY OTHER RULE. DynamicRules are objects which are invited to have their own, non-standard attributes, and we do want for sub-rules to be able to play with those... right?

What's an example of a DynamicRule which would need its own, non-standard attribute to do its job correctly, and can we make a sub-rule which affects THAT PARENT RULE EXCLUSIVELY which wouldn't work on other Rules.

"Every 3rd turn, Vencabot takes damage."

This Rule needs an internal counter for how many turns have passed since Vencabot last took damage from it. Very simple, but a necessary, non-standard attribute that this Rule instance needs to keep track of.

Now, what if we wanted a sub-rule like this:

"Slow Poison: Every 3rd turn, Vencabot takes damage."
"If Vencabot's HP is healed, Slow Poison takes affect every 2nd turn."

So now, we have a situation where the SUB-RULE is manipulating the PARENT-RULE in a way that wouldn't necessarily TRANSLATE to other Parent Rules. We could probably abstract this out so that, "If Vencabot's HP is healed, the severity of the parent Rule increases," which we could have wired up in Slow Poison so that, if its severity increases, it takes affect more often.

But that's just one example. I feel like it's safe to say that not every sub-rule is going to be able to apply to every parent rule.

So, what we NEED to do is decide on a LIMITED SET of UNIVERSALLY USEFUL attributes that EVERY RULE needs to take into account. That would maximize the dynamism of these relationships BETWEEN parent and sub-rules.

For instance, if every Rule has a TARGET, we can change that target. This and other considerations I've been making makes it clear that we're going to need to start TAGGING Rules so that we can understand how they work, at a glance, and match them up APPROPRIATELY with other sub-rules.

Every Rule has a TARGET, and it has a flag regarding whether its target is a UNIT, a PARTY, a BATTLEFIELD or ANOTHER RULE.

Every Rule has a SEVERITY LEVEL between 1 and 10. '1' would be 'barely taking affect' and '10' would be 'a very dramatic affect'. So, EVERY RULE would take into account its CURRENT SEVERITY when triggered. This way, we could dynamically change the severity of a Rule and have it play out in interesting ways.

We need a flag that defines whether or not the Rule is currently 'suppressed'. These Rules would be VISIBLE on a status screen because their suppression is TEMPORARY. It's visible, it's in-play, but it will not be triggered. We would neither either a 'suppressed' flag or an 'active' flag, depending on which boolean we want.

We need, like, a 'type' flag? To communicate -- for instance. Let's say that we have a Healer class which has an ability that can REDUCE THE SEVERITY OF A CURE-CONDITION.

Some Rules:
Vencabot takes 10 damage at every turn change.
    - Parent Rule is cured after 10 turns.

We would want a Healer class which could use an ability to REDUCE THE SEVERITY of that cure-condition. Boom, the priest casts a spell, and now:

Vencabot takes 10 damage at every turn change.
    - Parent Rule is cured after 3 turns.

We have reduced the severity of the cure-condition. So, for this Priest's ability to MAKE SENSE, we NEED to TAG the sub-rule with some kind of 'cure_condition' tag. We need to tag rules so that we understand how we can interact with them.

So, these tags SHOULD NOT NECESSARILY BE INDIVIDUAL ATTRIBUTES, because we're gonna need an arbitrary number of tags. So, we can use these tags, as a list, to give other Rules and Abilities an idea of how they can interact with each other.

This idea actually solves a problem I've been having for a LONG TIME about Rules, and that's kind of cool. For instance, let's say that you have a priest ability that says, "Cures Rules that deal HP damage over time." Up to this point, we've had no way of communicating, at the programmatic-level, which Rules "deal HP damage over time." Because that's kind of an abstract idea. For instance, what is "time"? When a unit takes an action? When a turn ends? Also, we really have no way of INTROSPECTING which Rules are doing HP damage.

The idea of 'tags' solves this: we can just tag Rules with, "deals_hp_damage_over_time," and then ANY ABILITY or ANY RULE which excusively targets Rules which deal damage over time now know that this Rule is an applicable target.

So, yeah, Rules need to have a .tags attribute where we can apply tags that other Rules and abilities can look for.

Also, Rules need a get_description() method. We could supply a .description attribute, as a string, but, because Rules are instances with attributes that might change over time, it makes more sense to get_description() and get a string back which might be different every time.

Let's talk about the direction of our coding for tomorrow:

Rules need some standardized attributes:
    .severity
    .is_active
    .tags
    .get_description()
    .target_type
    .affected_by

Instead of having a 'target' attribute, the Objects which ARE the targets have a list of Rules that are targetting them. The 'targets' that a Rule saves, internally, could be totally different from the 'targets' that it has, ABSTRACTLY, for the purpose of balance. But it does need a tag for what kind of target it takes, and that should be standardized.

BattleUnits, BattleLeaders, and Battles need:
    .affected_by (a dict of parties mapped to the Rules inflicted by them)
    .rule_limits (a dict of parties mapped to the int limit for that party)

We know that we're limiting the number of Rules that a single Unit can be under the effect of PER PARTY. Vencabot can be affected by two rules inflicted by Party A and two rules inflicted by Party B.

At this point, we should port our existing Rules to take advantage of 'severity'. Then, we need to start coming up with and testing sub-rules and situations where we're dynamically messing with severity and other attributes of Rules.



05/02/19

So, today I'm adding some new features to the DynamicRule objects. In particular, we're adding 'tags' and 'severity' -- and that means changing our existing test rules so that they take advantage of these new features.

So, first, let's go through our existing rules and implement severity, and then we'll test that.

A couple of problems just came to mind regarding the flexibility of rules.
    1.) Is it possible to record when a ability crits, for rules like,
        "If Vencabot gets a crit, he loses health."
    2.) Is it possible to record when a rule triggers, for rules like,
        "If Rage triggers 3 times, Rage is removed from the ruleset."

These are situations where we would need some kind of 'report' to trigger Rules that we haven't accommodated in our DynamicEvent system. DynamicEvents always and only record when an attribute is changed. That makes sense, for the most part. We could even use it to record turn-changes by having, like, battle.current_turn be a dynamic attribute.

But there are some situations, I feel, where it would make sense to trigger rules when an OBJECT ATTRIBUTE couldn't be said to be strictly CHANGING.

Like, can we change an attribute when getting a crit? Maybe. Sounds kind of hack'ish.

Can we change an attribute when a Rule triggers. Maybe. Sounds kind of hack'ish.

In the latter example, we could just standardize a mechanism where Rules record how many times they've been triggered.

Maybe. It's. Worth. Recording the EFFECTIVENESS of an ability when reporting on it for DynamicEvents.

Right now, DynamicEvents record quite a lot of data about the CAUSE of the event:

DynamicEvent.perpetrated_by : the UNIT who 'perpetrated' the attribute
                              change.

DynamicEvent.using_ability : the ABILITY that was used to change the
                             attribute.

DynamicEvent.triggering_rule : the RULE which was triggered by the ability.

So, maybe we just need another report attribute, "with effectiveness".

DynamicEvent.perpetrated_by
DynamicEvent.using_ability
DynamicEvent.at_effectiveness
DynamicEvent.triggering_rule

It seems reasonable, to me, to give every DynamicRule a counter for how many times its been triggered. When this number goes up, we can run other Rules which would trigger when that rule is triggered.

Time for some salty notes.

I just noticed that current DynamicRules aren't given a 'Battle' object as an argument upon instantiation. But, in a previous rant, I established that, just like with Abilities, every Rule must, by definition, have access to a Battle object -- because it needs to be able to change things in the battle.

Or does it?

I mean, Rules are given arbitrary arguments, right now. If a Rule needs access to a Battle, we can give it a Battle. None of our existing Rules require access to a Battle.

Which raises a question: is it okay for every Rule to take arbitrary arguments? I don't think that it's okay for ABILITIES to take arbitrary arguments, because they ALL NEED TO BE 'used' IN THE SAME CONTEXT. In the same way.

But Rules are 'initiated' during Abilities, so, in that 'use_ability' code, we can instantiate Rules however we please.

So, by that logic, Rules don't necessarily need to have Battle arguments and, furthermore, they don't necessarily need to have ANY particular arguments: their instantiation can be completely customized during 'use_ability'.

We're ending our game-dev stream, so let's take some notes about what we accomplished, today:

We enhanced both the DynamicRule and the DynamicEvent objects.

DynamicRules became, themselves, DynamicObjects, which means that when their 'severity' and 'triggered_counter' change values, they can trigger other Rules.

Also, we implemented 'severity' and tags and demonstrated that both are working. We created an ability, "Blood Song," which increases the severity of all rules in the current battle which increase attack power. We used tags to understand which rules raise attack power, and we made sure that these rules will give the target unit more attack power based on how severe the rule currently is.

We added a new report to our DynamicEvent objects, "at_severity". This records whether the 'with_ability' was Glancing, Normal, or Critical. Now, we can trigger certain rules based on whether or not an ability was a crit, such as, "Whenever Vencabot gets a Crit, he loses 10 health."



05/06/19

Today, I want to get Rules stacking upon other Rules. In particular, I want to play with 'cure conditions' and 'trap conditions'. I also want to implement a Rule which temporarily 'seals' or... what was the word I was using? Anyway, a Rule which can subdue other Rules for as long as it's active.

So, we're gonna have rules stacking on rules stacking on rules.

We still don't have a way for Rules to trigger on a turn-change, or 'on any action'. Like a poison that would trigger whenever a unit uses any ability.

I want to make a 'poison' which damages the target every time they use an ability. Then, I want to create a rule which subdues that poison until a certain condition is met.

Poison works. I want to make a new Rule which can SEAL ANY RULE for the length of 3 ACTIONS taken by Party A.

I want to make a new ability which inflicts this Rule upon the battlefield.

I'm gonna make a new ability called Seal Rule.

We have a conundrum. The abstraction of a rule being 'cured' isn't necessarily as simple as removing it from the rule list.

What about situations where a rule being 'cured' would change something attributes back to 'normal'?

Well, actually, that problem ISN'T a problem if you think about rules in the correct way. Rules always DO something when triggered, and they don't do anything if they AREN'T triggered. So, I'm looking at 'seal rule' entirely the wrong way.

Rules DON'T need an 'is_active' attribute. You don't seal a rule by making it 'inactive'. You seal a Rule by PREVENTING IT FROM DOING WHAT IT WANTS TO DO.

You can pretty easily do this by just checking the 'triggering_rule' attribute of a DynamicEvent. If the 'triggering_rule' is the target_rule, you need to prevent it from doing it's thing. So, for a Rule to be sealed by another Rule, the SEALING RULE would definitely have to come after the SEALED RULE in the rule-order.

But that stands to reason; if you're going to initiate a rule to prevent another rule from taking place, it would necessarily come after.

I have a conceptual problem that probably needs addressing. What if I wanted to have a Rule that is as follows:

All Rules which alter HP damage are ineffectual.

I don't know if that sort of Rule is possible with our current setup. Because, if Hench came after this rule in the rule-order, its effect could not be prevented.

You can't prevent a rule that comes later in the rule-order from altering a dynamicevent.

For the first time, we're talking about rules that target other rules, and I'm starting to see some unexpected difficulties arising.

Let's not worry about that for now, because we don't have time; that's a very abstract problem that we're going to need to put a pin in and come back to later.

##### RULES CANNOT PREVENT ANOTHER RULE WHICH COMES LATER IN THE RULE-ORDER FROM ALTERING A DYNAMICEVENT. ######

We can still 'seal' the effect of a Rule that was put into the rule-order beforehand. We just can't, right now, put a rule into play which will pre-emptively alter the affects of a Rule that's added to the ruleset later.

If we want to prevent the effect of a Rule, we have to look at the .triggering_rule attribute of a DynamicEvent and 'prevent' that event from occuring. It seems to me like there's two ways to do this:

1.) Prevent the change all together by doing:
    dynamic_event.replace_value(dynamic_event.__dict__[dynamic_event.attr_name], self)

That would disable the event by turning the NEW VALUE into whatever the value was ORIGINALLY.

But that's not necessarily what we want to do.

We don't want to replace the event's value with whatever it was ORIGINALLY. We want to replace it with whatever it was going to be BEFORE THE TARGETED RULE KICKED IN.

So, what we really want to do is step backward through the event's timeline until we reach a point before the targeted_rule kicked in and then replace the event's value with THAT value.

So, we need to do OPTION 2 if we can go back in time far enough that the rule hadn't triggered, yet.

We need to do OPTION 1 if we can't: the ORIGINAL EVENT was created by this triggering_rule.

I WANT THE OLD_VALUE OF THE FIRST DYNAMICEVENT WITH TRIGGERING_RULE TARGET_RULE.

I WANT ROLLED_BACK_EVENT TO BE THE FIRST DYNAMICEVENT WITH TRIGGERING_RULE TARGET_RULE.

I WANT TO STOP REPLACING ROLLED_BACK_EVENT AS SOON AS THE EVENT THAT IT REPLACES NO LONGER HAS TRIGGERING_RULE TARGET_RULE.

### OUR DYNAMICRULES NEED TO KNOW THE EFFECTIVENESS OF WITH_ABILITY. ###


When Vencabot uses Seal Rule, he does two things:
He adds a Rule to the Ruleset, "Seal Rule".
he adds a Rule to the Ruleset, "Fade Rule".

AFTER BOTH OF THESE THINGS HAPPEN, hang on... hang on...

Why isn't Poison triggering twice? Vencabot is effectively 'doing' two things in a single turn. Poison should be triggering twice. I don't WANT it to trigger twice, but I just realized that there's a bug that should be causing it to trigger twice. Because it's NOT triggering twice, that means that our BUG has a BUG.

Nevermind. When we use an ability, we reset the recurrence_counter AFTER the ability is complete. So, Poison CAN'T trigger twice in the time between when an ability STARTS and when an ability ENDS.

WHEN VENCABOT USES SEAL RULE, HE DOES TWO THINGS:
HE ADDS A RULE TO THE RULESET, "SEAL RULE".
HE ADDS A RULE TO THE RULESET, "FADE RULE".

AFTER BOTH OF THESE THINGS HAPPEN, POISON TRIGGERS. no, no, no. Poison only triggers after the FIRST event, which is Seal Rule being added.

Vencabot takes Poison Damage.

AFTER THAT, we add Fade Rule.

So, the solution to this problem... I'm not sure that "solution" is the right word... but we could make this behave the way we expect by stealthily adding 'Seal Rule' and then overtly adding 'Fade Rule'.

But actually, the thing to do would be to add them both, overtly, but at the same time.

So, the reason that I decided to add them both overtly, INDIVIDUALLY, is because, when you have a Rule that's triggered whenever a Rule is added to the ruleset, you would expect for it to trigger twice if more than one rule is being added.

But, in this case, CONCEPTUALLY, the rules ARE being added together. So, I'm going to add them both at ONCE, overtly. This would trigger rules that occur whenever a rule is added. If that rule really wants to trigger once for every new rule, it can check, itself, how many rules were just added.

So, the solution is to add both Seal Rule and Fade Rule at the same time.

Everything's working fine. Next time, I want to try to implement THIS rule:

"All effects from Rules which alter HP damage are negated."

That's going to be a challenge.


05/15/19

Back from Texas Showdown. It's been about a week since we last did any programming. Let's first of all create a new text document to contain our 'test abilities'. In the past, we had all of our 'test rules' within the main 'rules_and_events.py' module, but they become so complex and numerous that it made more sense to separate them out.

Now, we're sort of in the same position for Abilities. They're taking up a lot of space in our rules_and_events.py module, so why don't we move them to their own module just to make things a bit tidier.

Why did we decide that Abilities shouldn't be instantiated? I think it was just because we wanted to avoid the problem of 'redundant references,' which is something that I decided was important to the sanity of our architecture. It makes me wonder if the benefits of going with instantiated ability classes would outweigh the problems caused by redundant references -- or even if there's some way that we could implement ability instantiation without needing to rely on redundant references.

What if we reversed the hierarchy of our object tree? Would that make the problem of 'redundant references' a bit easier to deal with? Like, what if, instead of the 'battle' object having parties and the parties having units, we just had a bunch of loose units and THEY had parties and the parties had a battle.

The reason why it's difficult to implement a Rule like "All Rules which damage HP have their effects negated" is that a Rule can only 'prevent' or 'roll back' an event which is triggered BEFORE that Rule is checked.

So, it'd be trivial to implement a Rule like:
"All preceding Rules which damage HP have their effects negated."

However, inhibiting event-updates that occur AFTER a given rule in the ruleset might be impossible with our current mechanisms.

They have to ALTER HP damage -- not inflict HP damage. Stopping a NEW event, such as damage infliction, is trivial. Stopping an ALTERATION is much more difficult.

But why is that, necessarily? Can we make Events into DynamicObjects so that updating them can trigger rules...? That immediately seems like a bad idea, but maybe it isn't that bad.

Like, it makes sense for DynamicRules to be able to trigger whenever damage is altered. That makes sense, to me. But I feel like we're getting so meta that there's gonna be some weird difficulties that arise from trying to do something like that.

I feel like this would require a re-imagining of our DynamicEvent system, but maybe that's for the best. Maybe this cause is worth fighting for. On the other hand, I really like our current DynamicEvent system -- where you can sort of walk back in time to find the previous versions of events. Could we somehow do both...? Maybe not.

Well now wait a minute. Maybe all we'd really need to do is make DynamicEvent a DynamicObject and then... do:

my_event.update("replaced_by", new_event, etc., etc.)

That would effectively trigger rules whenever an event is replaced. That's what you want.

Before we commit to this notion, let's examine whether or not there are any other benefits -- or pitfalls -- to making DynamicEvents into DynamicObjects.

DynamicEvents are pretty immutable. The only attribute they have which is ever meant to change is 'replaced_by'. Would it make more sense to have some kind of external, 'timeline' object which is just a list of the event's progress? I think that would make a lot more sense.

my_event.timeline = [self]

and then, when you use my_event.replace_value(new_value, triggering_rule)

And then, whenever we update the timeline, we can get the newest version very easily.

Well, no, no, no. That defeats the purpose of what I'm trying to accomplish, here. The idea would be to make the timeline a DynamicObject so that the DynamicEvent could be immutable. Is that something that we could accomplish or that we'd want to accomplish?

If we were to make a 'timeline' into a DynamicObject, would it really have any other attributes that would be interesting to see?

We would never subtract an event from the timeline. Also, let's consider whether or not we really need to know the entire timeline of an events alterations.

This is where things are going to get really abstract and probably where we're going to end this stream so that we can play some 3rd Strike.

Would it make more sense to just have an 'original event' attribute and not worry about a whole timeline. Would any Rule really benefit from being able to see the entire timeline of an event's changing? So far, we've used the 'original_event' attribute to understand what the event was SUPPOSED to do. And, of course, the most up-to-date version of the event is what's going to actually END UP HAPPENING.

Are the events in the middle actually worthwhile?

Yeah, they are. And here's why:

We have a Rule which says, "If Vencabot was going to do 10 damage and that damage is negated, he gets pissed off."

We have another Rule which says, "If Vencabot is going to do 3 damage, he'll do 10 damage instead."

Vencabot slaps dixxucker for 3 damage.
So, he's going to do 10 damage instead.
But Dixx is invincible (as you'd expect), so Vencabot does 0 damage.

Our first Rule sees that Vencabot is going to do 0 damage. It checks the ORIGINAL_EVENT to see if Vencabot was going to do 10 damage, but he was only going to do 3 damage, so Vencabot doesn't get pissed off.

That's a bug.

We need to be able to see the ENTIRE TIMELINE of an event's alterations in order to understand that Vencabot was going to do 10 damage but the damage was negated.

And what's cool about this is that it works with any number of rules. We could have a situation like this; here's our ruleset:

If Vencabot is going to do 3 damage, he does 10 instead.
If Vencabot is going to do 10 damage, he does 5 instead.
If Vencabot is going to do 5 damage, he does 2 instead.
If Vencabot is going to do 2 damage, he does 0 instead.

So the final result is that Vencabot does 0 damage, and he was originally gonna do 3 damage.

But we can LOOK THROUGH THE TIMELINE of alterations to this event to see that, AT SOME POINT, he WAS going to do 10 damage. And in the end, he did 0 damage. So we can surmise that, "Vencabot was going to do 10 damage, but that damage was negated."

We do benefit from having the entire timeline at our disposal when it comes to investigating an event to see if a Rule should trigger.

Soooo... Now that I've realized that it makes more sense to have a 'timeline' object, as a List, than to have this tree of "replaced_by" and "replaces" attributes, we should make DynamicEvent into a DynamicObject so that, whenever an event is UPDATED, we can trigger rules to examine that update. Okay.

We'll do that next time. Now, it's time for 3rd Strike.

Tomorrow is going to be quite a big overhaul. Maybe even worthy of moving to mock-up version 5? Before we move to version 5, it might be worth re-examining the hierarchy of our battle objects.

Right now, we have a hierarchy like so:

         Battle
            |
         Leaders
            |
       BattleUnits
            |
        Abilities

I went through a lot of work in mockup version 4 to eliminate what I call "redundant references," which is to say that the hierarchy should only go one direction. For instance, the Abilities do NOT know who their owner is. The BattleUnits do NOT know who their leader is. The leaders do NOT know what battle they're a part of.

The problem with this is that abilities are really dumb. They're never instantiated, even, so we need to feed them all of the information that they require to do their job, including the perpetrator (their owner) and the battle that they're being used in. Also, it means that, INTERNALLY, there's no logic that limits a unit to using only the abilities that it 'knows'.

That's not a major problem, but it's sort of an aesthetic problem with the architecture.

Originally, we were fucking around with having abilities be INSTANTIATED, and then, of course, they could have an attribute which would point toward their owner -- among any other number of attributes.

There really are a lot of advantages to having abilities be instantiated. For instance, they could gain EXP and level up over time. They could have special qualities, such as, "If 'Slash' is used 3 times, it'll be gauranteed a crit." Right now, doing something like that would rely on having a Rule in play -- and that's consistent, at least, but maybe a little bit overkill for something that simple.

On the other hand, if we're not keeping a reference to the ability's owner, it seems like an architectural misstep to necessarily make abilities instantiated.

So, what if... it made more sense to turn the hierarchy UPSIDE DOWN.

     Abilities
         |
     BattleUnit
         |
    BattleLeader
         |
       Battle

Whenever we take measures to avoid 'redundant references,' we're going to have to do some SEARCHING for the objects that we want to find. If we just let the objects reference EACH OTHER, up AND down, it really minimizes the searching that we have to do. I just hate redundant references because of the architectural ugliness that you get from every object being able to directly reference every other object. The 'state' becomes way too entangled. So that's not an option for us.

Right now, with the hierarchy being 'rightside up,' the searching is pretty minimal.

For instance, if an ability is going to target 'the entire enemy team,' we need to look at the perpetrator and then iterate through all of the battle's leaders to see which team they're on.

Once we know what team they're on, we need to iterate through the leaders to find the one that ISN'T that team's leader.

Then, we can afflict every unit on that leader's team.

When I say 'searching,' I mean that we're literally iterating through some lists to find someone in particular that we're looking for -- instead of just KNOWing who they are (having a reference to them directly).

I feel like, if the hierarchy were 'upside down,' we'd have much more searching to do, right? But let's consider WHO is doing the searching.

The UI is doing the searching. It's when we want to TARGET somebody or something. Once we know who are target is, yeah, we have a direct reference to them. So, what sorts of things are we targeting, and how is our UI behaving. Let's examine these ideas real quick.

The UI behaves like this: we have two units in the 'ring', and, when it's your team's turn, you can use an ability from that UNIT or from that LEADER.

So, the UI has a reference to the 'battle' object, but the battle object doesn't know shit anymore if we're upside-down. So... that seems weird.

I guess what I'm trying to do is limit the number of arguments that we need to pass whenever a unit is using an ability. Right now, because I don't want for the ability to know who's using it -- as an attribute, I mean -- we need to pass a TON of arguments to these abilities in order for them to do very basic tasks.

If I want Vencabot to heal Lucian, I need to pass not only Vencabot AND Lucian to the classmethod, but I also need to pass a reference to the BATTLE object. In the case of 'Vencabot's healing ability,' both the PERPETRATOR (Vencabot) and the BATTLE are pretty much ALWAYS GOING TO BE THE SAME.

So it seems like a waste to pass them as arguments every time -- but the alternative is to instantiate the 'ability' and give it attributes including its perpetrator (Vencabot) and the battle. But, to comply with my design philosophy, if the ABILITY has a reference to VENCABOT, then VENCABOT can NOT have a reference to the ability. That's... sort of my thing right now. I'm trying to eliminate every situation where two objects have references to each other.

In the UI, when you're picking an ability to use and the currently selected unit is Vencabot, it makes sense to just say,

print all of the abilities from Vencabot's list of abilities

But, if Vencabot has a reference to all of his abilities, I'd prefer that his abilities not have a reference to him.

And this design philosophy results in this problem where I need to search through pools of objects to find what I'm looking for, because I can't just rely on a reference in many cases.

And for those who weren't here during previous streams, the reason that I've become hesitant to rely on 'redundant references' over the years is that they result in these situations and METHODS where you need to simultaneously and CONSISTENTLY update two attributes at the same time.

For instance, if the unit Vencabot knows who its leader is, WodoWiesel, AND WodoWiesel knows who's on his PARTY, we have to do something like this in order to add Vencabot to Wodo's party:

wodo.party.append(vencabot)
vencabot.leader = wodo

That seems really simple, but it gets out of hand REALLY quickly. Because the one time that you forget to do BOTH of those things, you end up with a horrifying bug. So what I've found is that it's better to only have the reference go ONE way. It seems to simply things but it means more PROCESSING when you're having to SEARCH the hierarchy for what you need rather than having a direct reference to it -- and it also means a lot more arguments.

         Battle
           |
   |-------|----------|
Leaders   Units   Abilities


The problem I see with this (and I'm sure it's because I don't fully understand Luthian's recommendation) is that neither the Leader nor the Units know who belongs to who. No, no, no. The Battle could have a map.

Ohhhhhhh, and then the Leaders wouldn't need to know their units and the units wouldn't need to know their leaders and the abilities wouldn't need to know their owners because the Battle knows all of that stuff, and the Battle is what you supply to the UI so that the player can actually make use of all of this stuff.

So, rather than giving each object a reference to whatever other objects it needs in order to work, we just have a separate object ("battle") which knows all of the relationships.

That makes so much sense. Not only does that simplify the relationships between the objects, but it simplifies the relationship between the UI and the gameplay. Because now you have this 'battle' object which sort of MANAGES the gameplay. It manages things. You could think of the individual objects below it (leader, unit, ability) as being like ARMS of the Battle which the Battle uses to do ITS job. And then, the UI interacts directly with the Battle.

So, in this case, it's not conceptually the UNIT which uses an ability: the battle uses an ability with some given units (a perpetrator and a target, etc.)

Before I call it quits, let me do some more thinking aloud to nail down where we're at, or where we wanna be:

To really understand the most effective way to internally structure our gameplay, we probably need to look harder at the UI and think about what sorts of things the player is really going to be doing -- so let's do that again and think about how we can apply Luthian's solution to that problem.

The battle's ring has two units in it who are fighting directly: one representative from each party, where each party has a leader.

So, when Party A completes their turn, we move to Party B. Here's what the UI presents us with:

A list of abilities that the Leader has access to
and
A list of abilities that the ring Unit has access to

When any of those abilities are selected, a target must be selected. An ability entails some character doing something to some character.

So, it's player B's turn. I want access to Leader B's abilities and the abilities of the unit representing party B in the ring.

The Battle could have a map of leaders (which represent parties) to their unit list. But that's the wrong way of thinking, already,  because we don't need to know the whole unit list. I need to know who's currently in the ring.

So, what I kind of need is a map of leaders (which represent parties) to their representative unit. Because, as player B, I can provide my leader. I have a reference to my leader, Leader B. I want to know who's representing my leader in the ring. Then, I can present a list of all of the leader's abilities and all of the unit's abilities.

Well kind of. Because that's still thinking that the leader and the unit have a reference to their own abilities.

So, here's what I'm thinking. The 'Battle' object has these attributes, all of which are maps:

our_battle.ring_units = # a map of LEADER to their representative unit
our_battle.teams = # a map of LEADER to a LIST of their units
our_battle.leader_abilities = # a map of LEADER to a LIST of their ABILITIES.
our_battle.unit_abilities = # a map of UNITS to a LIST of their abilities.

That's kind of sick. I feel like this one object knows EVERYTHING we need to know to make a complete player turn without the individual objects needing to know too much. That's one way to look at managing state.

Previously, I've tried to DIVIDE THE STATE into a bunch of portions that were AS SMALL AS POSSIBLE -- as a way to avoid having a bunch of objects which each had TOO MUCH ACCESS to the state.

But Luthian's alternative solution is to have as small a state as possible in ONE MONOLITHIC OBJECT and keep the state THERE. And then the individual objects have virtually no access to the state.

That probably makes more sense. If you're talking about simplifying the state, maybe the solution isn't to DIVIDE IT UP but rather to CONSOLIDATE IT. You have all of these objects which have their own little micro-states, but you have this one MANAGER which deals with the more involved aspects of the state. That way, you keep things simple. You don't have all of these complex interactions between objects.

I might try something like that for the version 5 mock-up, starting tomorrow. Because I've never used a design quite like that before, I'd be surprised if it was entirely smooth sailing, but I think it's definitely worth looking at.

So, tomorrow, mock-up version 5: we move as much of our state as possible to the 'battle' object. We update DynamicEvents to have a 'timeline' that, when updated, can trigger rules.





05/16/19

So, today we're beginning work on porting mock-up version 4 to mock-up version 5. In version 5, I want to focus on simplifying and empowering the relationships between objects by using a central registration or "management" object, whose entire job it will be to allow objects to reference each other.

Also, in mock-up 5, we're going away from DynamicEvent.replaced_by and instead moving toward a timeline mechanism where events register themselves in a timeline.

I don't know if I want to necessarily repurpose the existing 'battle' object as this registry or if I want to create a whole new object with a whole new name.

I'm kind of leaning toward the latter, because we need to consider that I'm re-engineering the way that I'm LOOKING at this code.

The idea of the 'battle' object was to organize objects into a hierarcy with the 'battle' at the top. Now that we're flattening things out, I don't necessarily feel like we need this idea of a 'Battle' at the top of things, where everything else occurs inside. Even if we DO need an object like that, I don't know if I'd want for THAT object to be the one that manages all of these relationships.

So, maybe we need another object whose job it is EXPLICITLY to manage the relationships between objects. Something like "BattleRegistry" or something like that.

Let's just do that, for now. We're going to make a new object.

What sorts of attributes would a 'battle' or 'battlefield' need if we have all of our relationships being managed by a third-party 'BattleRegistry' object?

We established that battlefields can have tags that may affect different Rules that are in play. I think that's really all they have, these days. The battlefield could have a 'ring' that's populated by one unit from each team, or alternatively the teams could just have a 'representative' as an attribute of that object.

We do want a Battlefield object, for sure. So, it can have tags. Does it really need anything else? Well, it can have slots for Rules to apply. We've talked before about how we want for objects to start having slots for Rules to occupy.

So, what have I really accomplished with this new object. Now, units don't know their own abilities, internally. Nor do abilities internally know what unit they belong to.

Have I made a terrible mistake? Do we really need this central registry to search for objects? I've been trying to avoid this problem of 'redundant references', and, in a sense, this registry does solve this problem: no two objects now have a direct reference to each other.

But we've sort of created another problem that I wouldn't have imagined, before: NO object has a direct reference to any other object. So we've solved the problem of having too many direct references by disallowing objects to have direct references to each other at all.

That seems sort of contrary to the spirit of OOP.

Like, does it make sense for a unit to not simply have a list called ".abilities" which contains all of their abilities?

Why should I need to ask some database what abilities this unit has. I can just give it an attribute that contains all of its abilities.

The reason why we strayed from that simple design is because it's so difficult to understand if the UNIT owns the ABILITIES or if the ABILITIES own the UNIT. Again, to solve that problem we prevented anybody from owning anybody.

But the reason that I'm really starting to backpedal on this 'BattleRegistry' object because I'm starting to see all of the design trappings that I was trying to avoid in the first place: we need these 'register' methods whose job it is to literally create redundant references. The only difference is that, now, all of these redundant references are housed within the same object -- which, admittedly, does simplify things a bit.

But the problem is that this simplicity seems like a small consolation for not just moving these same REDUNDANT REFERENCES out to their respective objects.

Like, if we're going THIS FAR into redundancy to make objects able to quickly 'search' for each other, why not just give Unit an 'abilities' attribute and the ability an 'owner' attribute? It's pretty much the same thing. It's just that this redundancy, in that example, is split up among multiple objects where-as, with this 'battle registry,' all of this redundancy is at least encapsulated within a single object.

I just feel like it's counter-intuitive. I feel like a Unit should have an attribute which is a list of the abilities it can use. Unit.abilities. Very simple, very obvious. Are we really accomplishing a noble ends by preventing all of these objects from seeing each other DIRECTLY.

Maybe the thing to do would be strike a middle-ground. Maybe we should not create units or abilities DIRECTLY but rather through some kind of manufacturer object whose job it is to manage these redundant relationships upon instantiation.

That doesn't seem like a real solution, because it creates chicken-or-egg problems. Do you 'manufacture' the ABILITY or the UNIT first? The idea would be to simultaneously connect them to one another, but that isn't reasonable.

On the other hand, if we can AVOID having a developer directly instantiate a class -- and, instead, have them 'manufacture' an object through some method I do think that we get more control over these 'redundant relationships'.

So, you could create a Unit and then the unit could 'learn' an ability. That was a solution that we had literally on day 1. In fact, let's go back to the day-1 code (if I still have it) and examine the trappings that we were trying to avoid in the first place.

Looking at the day 1 code, it seems to me that maybe the BIGGEST PROBLEM with redundant references ISN'T that you have two objects which directly reference each other and you need a method to manage that. Maybe the biggest problem is that you don't know which object to put that method ON. Because there is no hierarchy.

So maybe what we need, in the case of our chicken-or-egg example, is to have a delegating third party which can 'register' these objects to each other.

We would make the unit, and it would have no abilities, yet.
We would make the ability, and it would have no owner, yet.
Then, we would call: BattleRegistrar.register_ability_to_unit(ability, unit)

So, we don't have a third party object to MANAGE relationships. Instead, we have a third-party object to ESTABLISH relationships. That way, we don't need to answer the question of, "which object should have the method to manage their relationship". We just have one master object whose entire job it is to do that.

I kind of like that, but it suffers from the same problem that we always have with redundant-relationships: we can not allow the developer in question to directly manipulate some attributes, which is against the spirit of OOP and Python in particular.

For instance, if we make a unit and we make an ability and then run:

my_registrar.register_ability_to_unit(ability, unit)

We have to assume -- at the risk of INCREDIBLE BUGGINESS -- that no one will ever manually change ability.owner or unit.abilities . These attributes MUST be manipulated ONLY by the BattleRegistrar. They essentially become 'read only'.

But, on the other hand, is that such an extreme expectation? There's gotta be countless cases, in the real world, where manually updating an attribute will cause your software to bug out. If you're fucking around with some attribute of an object, maybe you have to expect that it's going to bug something out.

I'm going around in circles, man. I would love to simply REGISTER AN ABILITY TO THE GAME by saying unit.abilities.append(ability). That's my end-game. That's what I want.

I just don't think that I can accomplish that because the ABILITY needs to know who its OWNER is. That's the problem that we've been having since day 1. If I were a stronger, more educated programmer, I'm sure that I could think of a design paradigm that would solve this most basic of problems.

But there is no solution, right? Even I can see that. To make things as abstract as I can, we can very basically word the problem like this:

The unit must know what abilities it has access to.
The ability must know the unit that's using it.

If I want to just do:
unit.abilities.append(ability)

I can not inform the ability, at that time, the unit that it belongs to.

If I want to do something like, I'm going to need a method of some kind. 100%.

I don't want to override 'append' so that it tampers with 'ability' in some way, to tell it its new owner -- nor do I want to tamper with 'remove' so that it tampers with 'ability' in some way, to tell it that it now has no owner.

We NEED a method whose job it is to manage this relationship. This two-way relationship.

Kenny brings up the idea that we could just use 'init' on the ability class, and then it would change its OWN 'owner' attribute and tamper with its owner's 'abilities' attribute:

def __init__(self, owner):
    self.owner = owner
    owner.abilities.append(self)

But that's exactly the situation I'm talking about, above: in the most abstract of senses, if we're going to have two-way relationships -- for any purpose -- we're going to need methods to establish and manage those relationships. We can't just go raw, vanilla Python OOP and say something as PROFOUNDLY CLEAR as "unit.abilities.append(ability)". As much as I would like to, that doesn't solve the problem of giving 'ability' a reference to 'unit'. It gives UNIT a reference to ABILITY, but it doesn't give ABILITY a reference to UNIT.

And we've been spending weeks asking so many questions like, "well, does ABILITY really NEED a reference to 'unit'." That's why, in mock-up version 4, our abilities are just Classes that never get instantiated, and they always take their 'perpetrator' or 'owner' as an argument to all of their class methods. Because we couldn't give 'ability' an 'owner' attribute by using unit.abilities.append.

So, our solution was to go in a more FUNCTIONAL direction, and just have abilities which have no attributes and when you want to use them you need to supply a fuck-ton of arguments.


class Unit:
    def __init__(self):
        self.abilities = []

class Slap:
    def __init__(self, owner):
        self.owner = owner

my_unit = Unit()
my_unit.abilities.append(Slap(my_unit))



my_unit = Unit()
my_ability = Slap(my_unit)
my_unit.abilities.append(my_ability)

It's still a two-step process, even if you use syntax to condense it onto one line. The thing we're trying to avoid is a situation where a developer establishes ONE HALF OF THE RELATIONSHIP without remembering to establish the SECOND HALF of the relationship.

In the example above, when we instantiate 'Slap' as 'my_ability', my_ability now has an owner: my_unit.

At that point, though, my_unit does NOT have slap as an ability. Slap has my_unit as an OWNER, but my_unit does not have Slap as an ability. That's the nature of SO MANY BUGS that I've experienced in my years of doing OOP. This two-sided relationship where it's understood that both sides have an equal reference to each other when there is no mechanism in play to be certain that this is actually the case.

In the most abstract of senses, IF we're going to fuck around with equivalent two-directional relationships, we NEED some kind of intermediary method or function or even a class to establish these two-way relationships AND we need to trust that the developer in question will USE that intermediary and not just tamper with things directly.

And my profound frustration with that is that it means, when you want to append an ability to my_unit's ability list, you CAN'T just do:

my_unit.abilities.append(ability)

It seems like you SHOULD be able to do that, but, if you did, you would be breaking the game. You absolutely HAVE TO UNDERSTAND that, to append an ability to that list you actually need to do something like,

my_unit.learn_ability(ability)

Or,

my_ability.set_owner(my_unit)

That's where my frustration comes from: immediately, we're looking at 'setter' methods, which I fucking hate. When you SET SOMETHING in PYTHON you should just be able to do it with an assignment operator. We got 'setter' methods, now? Because we need to have side-effects when we're setting things?

So, I've been trying to make all of our relationships ONE-DIRECTIONAL in a strict hierarchy to prevent these sorts of problems, but this DEFIES the very design of our game. It looks nice INTERNALLY, but it's just as simple as the fact that the units NEED TO KNOW what abilities they have and there's no getting around the fact that the ABILITIES need to know who their owner is.

It's not a real solution to just go functional for the abilities and have the unit supply itself as an argument EVERY TIME IT WANTS TO DO SOMETHING WITH AN ABILITY. Like, if you're supplying the same arguments EVERY SINGLE TIME, that's exactly why objects were created. At that point, the ability might as well have a direct reference to its owner -- any time you want to do something with it, you have to supply owner, anyway. We haven't really solved any problem. All we've really done is save ourselves from having to use these methods to establish these two-way relationships. We can't deny that there is a two-way relationship there. We're just disguising as an argument.

So, before we end today's stream, let's enumerate our possible solutions -- like, for real. Let's just lay out the tools that I have access to, with my relatively limited programming experience, and decide which one is the most reasonable to go with:

SOLUTION #1: Just use vanilla Python and expect the dev to manually maintain these two-way relationships.

class Unit:
    def __init__(self):
        self.abilities = []

class Ability:
    def __init__(self):
        self.owner = None

my_unit = Unit()
my_ability = Ability()
my_unit.abilities.append(my_ability)
my_ability.owner = my_unit


SOLUTION #2: Establish methods to manage the relationships between objects.

class Unit:
    def __init__(self):
        self.abilites = []

    def learn_ability(self, ability_class):
        self.abilities.append(ability_class(self))

class Ability:
    def __init__(self, owner):
        self.owner = owner

my_unit = Unit()
my_unit.learn_ability(Ability)


SOLUTION #3: We could make all relationships one-directional and rely on arguments to convey information to lower-level classes / objects on a need-to-know basis.

class Unit:
    def __init__(self):
        self.abilities = []

class Ability:
    @classmethod
    def be_used_by(cls, user):
        print(user, " used the ability")

my_unit = Unit()
Ability.be_used_by(my_unit)


SOLUTION #4: We could take away all inter-object references ENTIRELY and have all of their relationships be managed by a manager object which can be searched to find anything you need.

class Unit:
    def __init__(self, manager):
        self.manager = manager

class Ability:
    def __init__(self, manager):
        self.manager = manager

    def report_owner(self):
        print(self.manager.unit_by_ability[self])

class RelationshipManager:
    def __init__(self):
        self.abilities_by_owner = {}
        self.unit_by_ability = {}

    def register_ability_to(self, ability, unit):
        self.unit_by_ability[ability] = unit
        self.abilities_by_owner[unit].append(ability)

    def register_unit(self, unit):
        self.abilities_by_owner[unit] = []

manager = RelationshipManager()
my_unit = Unit(manager)
my_ability = Ability(manager)

manager.register_unit(my_unit)
manager.register_ability_to(my_ability, my_unit)
my_ability.report_owner()


SOLUTION #5: All objects have their respective direct references to each other, but there's a manager object whose methods ESTABLISH those relationships. So, sort of a fusion between Solution #2 and Solution #4. In solution 4, we have this idea of a 'manager' object. And in solution 2, objects have direct references to each other and they're managed by methods. So now, we just export these methods to an object whose job it is to have these methods. This saves us the problem of having to decide whether Unit should have 'learn_ability' or if Ability should have 'be_learned_by'.

class Unit:
    def __init__(self):
        self.abilities = []

class Ability:
    def __init__(self):
        self.owner = None

class Manager:
    def register_ability_to_unit(self, ability, unit):
        ability.owner = unit
        unit.abilities.append(ability)

my_unit = Unit()
my_ability = Ability()
my_manager = Manager()

manager.register_ability_to(my_ability, my_unit)



In solution #5, the 'manager' doesn't contain a database the way that it does in solution #4. Instead, all of the relationships are more vanilla OOP: each object has a sensibly-named reference to the objects that it is closely related to and requires access to. However, the methods which establish these relationships do not belong to the objects, themselves: they belong to a third-party object / class / module whose entire job it is to establish these relationships. It's a 3rd party mediator so that we never have to ask the question of which object owns which object and should therefore have the method for managing the relationship.

Five solutions:
1.) Just manage two-way relationships manually.
2.) Give one of the objects a method which establishes the two-way
    relationship.
3.) Make all relationships one-way and use arguments when needed.
4.) Manage all relationships between objects through an intermediary
    instead of having objects own a direct reference to each other.
5.) Establish all two-way relationships through an intermediary, but allow
    objects to own a direct reference to each other.

Solution #1 isn't really a solution. I just included it for completeness. We don't want to manage all of these two-way relationships manually.

Solution #2 creates some chicken-or-egg questions. For instance, either a Unit can get a list of its Abilities upon instantiation OR an Ability can know its owner upon instantiation, but not both. So we have to be careful about the order that we instantiate things in.

Solution #3 isn't really a solution, either. We're gonna need two-way relationships, and to disguise them as arguments doesn't really solve any problem.

Solution #4 is a sensible solution except that it defies some of the basic principles of OOP by preventing objects from having a direct reference to each other when it would make a lot of sense for them to have a direct reference to each other. For instance, the 'manager' object knows which abilities belong to which unit, but the unit doesn't know what abilities it owns. Therefore, we can't have a my_unit.abilities list, even though that seems very reasonable.

Solution #5 may be the best of all worlds. It allows us to have a my_unit.abilities list, as you would expect -- and a my_ability.owner reference, as you would expect -- and it allows us to instantiate objects in any order. The real downsides are that it requires this bizarre, 3rd party 'manager' whose entire job it is to manage these relationships. It's basically no different from solution #2 except that having these establishing-methods outsourced to a 3rd party prevents us from having to worry about hierarchy or instantiation order. So, instead of saying, "my_unit.learn_ability(ability_class)", where my_unit MUST be instantiated first and we have to know, as a developer, that my_unit establishes the relationship and not my_ability -- instead of that, we get, "manager.register_ability_to_unit(my_ability, my_unit)," where the instantiation order doesn't matter and you don't need to know which of those two objects establishes their relationship, because NEITHER of them do.

So, I actually -- the more I talk about it, the more solution #5 seems like the solution that we want. Because you could think of this 'manager' object as being a sort of HELPER.

Because really, what we're talking about is solution #1: the developer is expected to entirely manage these two-way relationships on their own. BUT we have this HELPER class / object / module whose job it is to SIMPLY that task. That's what you want.

Okay, so, next Wednesday we're going to truly begin our version 5 mock-up using this design paradigm: vanilla-ass two-way relationships, but with a special manager object whose job it is to simply the establishment of those relationships.

We could call this object something to do with "introducing," right? It introduces objects to each other and establishes their relationships.




05/22/19

It's been a few days since we put any work into this project, and I'm sort of in a position where I'm going to need to rediscover it.

First, let's look at the significance of our existing classes -- outside of the progress that we've made so far -- and decide on what their purposes really are:

Battle objects include:

Battlefield
Leader
Unit
UnitAbility

The Units in our game represent the 'monsters' that the player is going to be collecting and adding to their team. These units have a variety of attributes that determine their effectiveness in battle as well as a library of abilities that they can use on their turn. They can also be subject to various rules -- either inherent to them ('Unit Dynamics') or which are inflicted upon them by their own team (buffs, probably) or by the enemy team (nerfs, probably).

The UnitAbilities represent the moves that a unit can use on their turn. These can have a huge variety of affects and costs, and they can have three levels of effectiveness which are randomly rolled for when that ability is used. Although we haven't implemented in any of our mock-ups, these Abilities will be managed into libraries that we've been referring to as 'classes' or 'roles'.

The Leader object represents the 'trainer' or the player character in this battle scenario. They have abilities that THEY can use (although we haven't implemented any in our mock-up, yet) including the ability to switch which unit on their team is currently in the ring. They also have attributes (especially 'AP', which determines how many actions can be taken on that party's turn) and also may be subject to certain rules. They have a list of units which represents their entire party. So, previously, we'd had 'leader' and 'party' objects, but I think it's pretty clear that we don't need both. Rather, the 'party' is just a list of units that's an attribute of the leader.

Finally, we have the Battlefield object which represents the current state of the battle. The Battlefield has a 'ring' which can be occupied by one unit from each leader's team. It also has properties and rules which may have an impact on every character in the battle.

So, with these abstractions, we still have some questions to answer when it comes to the turn-to-turn action of the battle. For instance, where do we save information such as whose turn it currently is? In an abstract sense, is it even important that objects at this level are aware of whose turn it is, or is that something that we should think more about as we develop the UI.

The more I think about it, the more I'm convinced that the turn-to-turn action or movement is inseparable from the notion of a UI. Because it implies a 'prompt', right? I mean... We could do something INTERNALLY without prompts that generates error messages when certain units and leaders try to take action when it isn't their turn? But that seems overkill. So, again, I feel like the idea of turn-to-turn motion, from battle start to battle completion, is dependent on some kind of battle UI. Perhaps it's the future UI classes which propel battle.

In terms of the underlying mechanisms, we have these 'Dynamic' classes whose purpose it is to handle the Dynamic Rule System, which is our game's central gimmick:

DynamicObject
DynamicRule
Ruleset
DynamicEvent

DynamicObjects are just very basic extensions of Python's 'object', except that they have a method where you can reassign their attributes but while testing that update against a ruleset.

So, rather than manipulating a unit's 'HP' directly, you can choose to update it using the method 'update_w_rules', which will check the current ruleset to see if anything is supposed to happen before or after this unit's HP is updated.

One weakness of this mechanism is that it relies on attributes being updated in order for rules to be triggered. This has been effective for 100% of the rules that we've imagined so far, but it could be an issue when we would like for Rules to be triggered when some kind of action is taken by the player which, in an abstract sense, may not directly update any attribute of a DynamicObject.

For instance, if we want for all of a party's units to take damage when the leader ends the party's turn, I can't currently imagine a way to handle that.


05/23/19

We got cut off, last time, by a Comcast outage. Picking up where we left off, we're examining the weakness of the DynamicRule System, as it stands now, insofar as the only way to trigger rules is to update the value of some attribute of some DynamicObject.

For 99% of use-cases, this is perfectly fine. One situation that I can think of where this isn't going to work (perhaps) is when we want to trigger a rule like,

"When Leader A ends their party's turn, every unit on their team takes damage."

One way to hack around this would be to give Leader A (which is a DynamicObject) some attribute that counts the number of turns they've taken. Then, when that attribute increments, we could inflict damage to their entire team.

But the real reason that I mention rules like this is that I can imagine there being situations in our game where a certain action might have to trigger a rule without necessarily updating an attribute of a DynamicObject.

On the other hand, maybe that's not the case. Maybe we could just hack these sorts of situations using things like a "turn counter." In fact, a turn-counter might not be a bad utility to have in any case.

So... Yeah, maybe this isn't a huge problem. Maybe it does stand to reason that rules could be triggered using DynamicEvents.

But, before we go too far, today, let's reexamine the anatomy of a 'DynamicEvent' and decide how ugly it is or isn't to have all of these optional attributes. Let me show you what I mean:

class DynamicEvent:
    def __init__(
            self, target, attr_name, new_value, old_value,
            perpetrated_by, with_ability, at_effectiveness, triggering_rule,
            original_event=None, replaces=None):
        self.target = target
        self.attr_name = attr_name
        self.new_value = new_value
        self.old_value = old_value
        self.perpetrated_by = perpetrated_by
        self.with_ability = with_ability
        self.at_effectiveness = at_effectiveness
        self.triggering_rule = triggering_rule
        if original_event is not None:
            self.original_event = original_event
        else:
            self.original_event = self
        self.replaces = replaces
        self.replaced_by = None

Before we talk too much about these attributes, I want to point out that one of the core concepts of our version_5 mockup is that we're doing away with dynamic_event.replaces and dynamic_event.replaced_by and instead we're giving them a dynamic_event.timeline attribute, which is a list, organized from earliest-to-latest, containing versions of this same event.

So, what we really have are: target, attr_name, new_value, old_value, perpetrated_by, with_ability, at_effectiveness, triggering_rule.

With these 8 values, I've proposed that we can describe an event in the game in as much detail as we would ever need for Rules to do their job.

First of all, IS IT IMPORTANT THAT WE HAVE AN OLD_VALUE. old_value has no purpose in rules that take place in the 'before' phase, because we can just CHECK the old value of an attribute by looking at target.attr_name .

However, once we're talking about the AFTER phase, old_value does become significant because the target.attr_name has already been updated at that point. So the only way we can know the old value is to look at this attribute of the DynamicEvent.

Is that enough to justify its inclusion? Because, for 'before' rules, it really is redundant. I would say yes. This attribute IS justified because 'after' rules DO need it. The only alternative would be to have a whole different kind of object for reporting to 'after' rules, and it would basically be the same exact DynamicEvent as for the 'before' rules except that it includes old_value. There's no reason that we should make two different kinds of reports in this situation.

The most fundamental attributes of a DynamicEvent are new_value, old_value, target, and attr_name. With these four attributes, we can tell what attribute of WHO is being changed to WHAT. This allows us to trigger basic rules such as, "If Vencabot's HP goes down..." For a rule like that, we just need those first four attributes.

The latter four attributes examine the PERPETRATOR of this change, so that we can create more advanced regarding who DOES WHAT to WHO: perpetrated_by, with_ability, at_effectiveness, triggering_rule .

With these four attributes, we know the unit who USED the ability which instigated this change. We know what ability they USED. We know how EFFECTIVE it was (glancing, normal, or critical), and we know both WHETHER this update was implemented by a RULE and WHAT rule it was, if so.

So, this final attribute -- "triggering_rule" -- is the most bizarre of these report attributes. It's ONLY POPULATED if the change being made to the target's attribute was done BY A RULE. Otherwise, it's 'none'. If the change WAS instigated by a rule, then this attribute points toward that rule instance.

So, in example:

"If Vencabot gains attack power, a random opponent takes damage."

In that example, if Vencabot uses 'charge up' and gains attack power, it's going to cause a random opponent -- KReichJr -- to lose HP. When Kenny loses HP, we're gonna get an event like this:

Kenny's HP went from 10 to 7. This is because Vencabot used Charge Up at Normal effectiveness, triggering our Example Rule.

That's the entire report and is currently the most complex report that we're capable of generating, now. So, Kenny could hypothetically have some rule upon him which says,

"If Kenny is going to take damage as a result of Example Rule, that damage is nullified."

So, from that report, we can tell that, although the damage was, in a sense, triggered by Vencabot using Charge Up, it was actually directly inflicted by the rule Example Rule. So, in this 8-attribute report, we sort of get an entire picture of what instigated this change in Kenny's HP.

We can have very particular rules, this way. For instance, Kenny might be immune to HP damage from 'glancing' effectiveness attacks. Maybe Kenny takes 50% more damage from critical hits. Maybe if Kenny takes damage from a Rule which was triggered by a critical ability, he gains defense or something.

I think, all-in-all, this is a pretty tidy way to organize a report. If I had one hesitation about it, it would be that, in version_5, we're moving toward having Abilities be instances again, and they're going to know who their 'owner' is. As a result, perhaps we don't need both 'perpetrated_by' and 'with_ability'. If we know the ability which caused this update, we know who used it, right? I can hardly imagine a situation where an ability could be used by someone who isn't its owner.

The only situation where this could arise would be if some class did have the ability to use another unit's abilities, be it something like "mirror-move" in Pokemon or some kind of Blue Magic from Final Fantasy -- maybe a unit can temporarily steal another unit's abilities.

If that were the case, though, we could just temporarily instantiate a new ability for that unit, right? That's what we would do.

If abilities know who their owner is -- and supposing that all updates are being done VIA ABILITY -- we don't necessarily need a 'perpetrated_by' attribute.

But, that raises another question. So far, 'with_ability' has always pointed toward an instance of UnitAbility. But what about when a change occurs as the result of, say, a Leader ending their party's turn. What do we have, then, for "with_ability"? Because, outside of that sort of situation, we always have a UnitAbility to reference. Also, supposing that we include some sort of 'inventory' or 'usable items' that a Leader can use (at the cost of AP, probably) instead of having one of their units take an action -- what do we show for 'with_ability' then?

Well, the first thing to point out is that Leaders have 'abilities' that will behave ALMOST IDENTICALLY to 'UnitAbilities'. They may (or may not even) require a 'LeaderAbility' class, but they're capable of doing pretty much the exact same sort of actions as UnitAbilities.

LeaderAbilities can directly attack the opponent. They can buff an ally. They basically can do all of the things that UnitAbilities can do -- but more.

For instance, we might need a LeaderAbility to use inventory items. We might need a LeaderAbility to end the turn prematurely. We might need a LeaderAbility to flee from battle. The LeaderAbilities are more META, right...? But, for instance, I don't see any reason, really, why a Unit wouldn't be able to do all of those same things.

Why wouldn't we be able to have a Unit which has some ability like, "Uses an item from the Leader inventory with a 20% chance of keeping the item afterward." Why shouldn't we be able to have a Unit with an ability like, "Guaranteed critical damage but the party's turn will end."

So, that begs the question: what really is the inherent difference between a Battle.Unit and a Battle.Leader?

Well, Leaders have an AP attribute which determines how many actions their party can take in a single turn. In this respect, Leaders represent the limitations of the party as a WHOLE.

Also, I don't see any reason why a Leader should ever need to have an HP value. Based on the design that we've been sticking to since Day 1, Leaders (like Pokemon trainers) don't take damage directly. Now, in a game like Yugi-Oh!, the 'units' or 'monsters' act as a shield for the 'trainer' or 'leader' and, once all of the units are out of the way, the leader can take HP damage directly -- and the fight is over once the leader has been knocked out.

There's no reason that a leader COULDN'T have HP... It's just that, based on our design so far, we're going with a more traditional monster-collecting-JRPG style where, once all of the units are DOWN, the party is defeated. The 'leader' just stands there and cries about it.

In terms of THEMING, we've sort of described that, when the party is defeated -- just like in Pokemon -- there's the implication that the Leader FLEES and returns to the last safe spot in the game to heal or otherwise reconfigure their party. On the other hand, it could be kind of cool to give the leader HP so that they have the chance, maybe, to use an item to revive a party member even after the entire party is defeated -- and the party is only truly out of the fight once the leader has lost all of its HP.

Really, I'm not all about this 'leaders have HP' idea quite yet. For one thing, it means that, once the entire party is dead, a leader that has no way to revive their party would have to wait for the enemy team to kill them. Unless they just have some inherent 'forfeit' option.

The only REAL appeal that I see for Leaders having HP is that we could make them more uniform with the 'units'. It's sort of seductive to have these two tiers of units: both have the same types of 'abilities'. And both are subject to 'Dynamic Rules'. You could almost even have the player choose an ARBITRARY UNIT to be the leader of their party, which is sort of a trippy idea. Because it never really struck me, until now, just how similar Units and Leaders otherwise are.

As a NOTE, though. Leaders DO need to be balanced differently. They HAVE to be balanced differently:

The core combat gameplay of this JRPG is such that, although each team has 4 Units and 1 Leader, only ONE UNIT can take actions at a time -- the unit in 'the ring', similar to Pokemon. The exception to this, and where I imagine a lot of the game's strategy will come in, is that the LEADER can take actions at any time. And the Leader doesn't take damage.

So, you may have chosen to put a certain Unit in the ring, and now you have access to all of that Unit's abilities. At the same time, though, you ALWAYS have access to your Leader's abilities. So, using your Leader and Unit abilities in tandem is probably key to victory. And what's more is that the player is going to be able to choose from a variety of Leaders, which may have different abilities, which may better-suit different parties.

So, I'm kind of in love with that idea -- and that really does mean that Leader Abilities and Unit Abilities are FUNDAMENTALLY DISTINCT, even if, internally, MECHANICALLY, they are not distinct.

They're distinct in the way that we need to think about BALANCE, because a Leader Ability can be used AT ANY TIME, REGARDLESS of who's in the ring. So those Abilities really shouldn't be anywhere near as focused on directly dealing damage to the enemy party because we don't want for players to just have this Leader Unit, who's immune to damage, just carpet-bombing the enemy team. So, if a Leader has any ability to directly attack or directly buff or otherwise DIRECTLY TAKE PART IN the battle, those abilities need to be very limited.

UNITS ARE MEANT TO DIRECTLY PARTICIPATE IN BATTLE.
LEADERS ARE MEANT TO HAVE AUXILIARY ABILITIES WHICH GUIDE THE FLOW OF BATTLE?

Like, what traits do Leaders really have?

Again, they ABSTRACTLY REPRESENT the abilities that your team can use, on your turn, BEYOND what the ring-unit is capable of:

Using items.
Swapping ring-units.
Fleeing from battle.

All of these basic things that you would expect to be able to do regardless of what unit is in the ring.

Furthermore, different leaders will bring their own RULES into battle, making each leader distinct. Some leaders might have a property where their entire team gets a 15% boost to HP. Some leaders might have a property where their party's 'fire' attacks do more damage or something. So, they have these 'perks' or 'rules' or 'dynamics'.

So, recapping, Leaders, so far, are: generic turn-abilities, party-level dynamics, party-level limitations (AP).

Another thing that I've always imagined that Leaders would have is unique abilities. For instance, we've talked before about how the PLAYER is going to be able to choose their leader. Maybe one of the leaders has an ability to heal a unit's HP.

What this implies is that, REGARDLESS OF WHAT UNIT IS IN THE RING, this team ALWAYS HAS ACCESS TO A HEALING ABILITY. For that reason, the healing ability would need to be somewhat weak -- because we're talking about A HUGE ADVANTAGE, otherwise. We want for these leaders, whose abilities can be used REGARDLESS of what unit is in the ring, to have interesting abilities which can augment their party's strategies. But not necessarily DOMINATE their party's strategies.

In our battle system -- some of the people watching understandably haven't been here since day 1. Let's quickly review the very basics of our battle system.

Each team has 1 leader and 4 units. There are two competing teams.

Each team has 1 'point' unit which is currently "in the ring." Only the unit which is "in the ring" can take actions on that party's turn, along with the leader.

So, so far, exactly like Pokemon. In Pokemon, you have a trainer which can use items and flee from combat and switch Pokemon, and you have a Pokemon which is currently OUT OF ITS BALL and FIGHTING, and you have FIVE OTHER POKEMON which are on your TEAM but they can't be DAMAGED nor can they DO ANYTHING until they take their turn in the ring.

Our game is exactly like Pokemon in all of those respects. Yes, you have a team of FOUR UNITS, but only ONE of those units can act and only that unit can take direct attack, for the most part.

When describing the game's core mechanics, I've been pointing out the SIMILARITIES to Pokemon. The game's main deviation from Pokemon is that, unlike in Pokemon, your team can take MORE THAN ONE ACTION PER TURN.

In Pokemon, when your monster uses an ability, your turn is over and the opponent gets a turn. Likewise, if the Leader (trainer) uses an item or swaps a Pokemon, that also ends the turn.

In our game, when a monster ('unit') uses an ability, the turn isn't over. It just drains AP from the leader. Likewise, when the LEADER uses an ability, it also drains their AP. When the AP is completely drained, the turn is over.

So, unlike in Pokemon, in a single turn, before our opponent can act, we can have our Unit attack, be swapped for another Unit, and have that unit attack.

If our Leader has 10 AP at the start of a turn, our unit can use an attack that costs 3 AP. Now we have 7 AP left. We can swap for 3 AP. Now we have a new unit in the ring and 4 AP left. That new unit can attack, at some AP cost, and, by this point, our AP is probably too low to do anything else, and so our turn ends.

Even with this, we only have one unit in the ring to directly take damage and use abilities. Like with Pokemon, we have a team of 'back-up units,' but they aren't strictly 'in the fight'. It's not like Final Fantasy or Dragon Warrior or whatever else where you have an entire party of ACTIVE units. Only one of our units is active, along with the leader, at a time.

So, the REAL ADVANTAGE of giving our leader HP -- maybe the only advantage -- is that it would allow the leader to potentially stage a comeback after all of their units are defeated. Even if your final unit goes down, you would maybe have a turn to revive them, again.

Another cool advantage of having a leader with HP is that it could give us another abstract win-condition. Let's say that some unit has an ability which has a 1/10 chance to do some damage directly to the enemy leader. Now, the fight could be won before the enemy's party is even defeated. Maybe you could somehow directly attack the leader -- although this would have to be very rare.

It's kind of a cool idea to have this secondary win condition. BUT EVEN THEN. It would be a whole 'nother balancing act to decide HOW MUCH HP a leader should have compared to a unit. Because, although they would both share the name "HP," they're not inherently similar. Because one is just a counter toward that unit being removed from battle and the other is a counter toward that entire party losing the battle. What we'd really be talking about is a sort of 'super LP.' We talked, before, about how units are going to have a secondary HP value called 'LP,' which represents their ability to get back up after being defeated.

When a unit's HP reaches 0, they can't act, anymore, and they lose one LP. When a unit has no more LP, they can no longer be revived. And we talked about how some rare moves or critical hits could directly damage LP even when that unit still has HP remaining. So, you could defeat a unit before even reducing its HP to 0.

We could sort of GO DEEPER and have a 'super LP' attribute which, when diminished to 0, causes that team to lose the battle. You could look at the leader's HP in that light, and, just like some rare attacks could directly damage a unit's LP, some other attacks may directly damage the leader's 'HP', which could bring the whole team closer to losing the fight.

In review of todays' notes:
    *) DynamicEvents currently have 8 attributes to communicate their event
       report: 4 representing the TARGET and 4 representing the
       PERPETRATOR. I would say these attributes are all that we need AND
       that we may be able to discard the perpetrated_by attribute if our
       with_ability instance knows its owner.

    *) We're examining the differences between Unit objects and Leader
       objects. How similar are they? How dissimilar are they? Although
       both have Abilities which, in the most abstract of senses, could do
       exactly the same things, those abilities need to be BALANCED
       drastically differently. Because a Leader can use their abilities at
       any time, regardless of who's in the ring, we need to think about
       their abilities much differently than we think about a Unit's
       abilities.

    *) Can or should Leaders have HP? If they did, it would move our
       'victory' condition from 'defeat every opponent on the enemy's
       party' to 'lower the enemy leader's HP to 0'. As with games like
       Yugi-Oh!, perhaps units can directly attack the leader's HP once
       they have no more units left. Maybe some rare abilities could even
       directly wound the leader's HP while they still have units on the
       field. What are the pros and cons of giving leaders an HP limit?

       Two main 'cons' are that, once all of the Units in the party are
       downed, now the Leader is awkwardly stuck waiting to lose the fight
       in many cases. This is sort of a minor problem. That's true of other
       RPGs and it hasn't been a major issue. The other issue comes with
       balance: if we have Leaders who have HP, and when that HP reaches 0
       the fight is over, there's this strategic depth that emerges which
       demands that some rare abilities can directly damage the leader's
       HP. Immediately, that begs the question: are these attacks too
       powerful. Does it diminish the strategy of the game if certain Units
       can just directly attack the leader (although it wouldn't be easy
       and would probably require crit)? How do Leaders heal themselves in
       battle? Is that a thing?

       Pros are that it adds this extra layer to the strategy, and that's
       immediately attractive. I like the idea of 'LP' on our units. If
       Leaders had HP, it'd sort of be an extension of that: a secondary
       route to victory. That's kind of cool.


05/27/19

It's a fresh week, and I'd say that it's a good time to take inventory of where we are in our project.

We're migrating over to a 'version 5' mock-up, which is bringing us back toward 'redundant references' -- where it's more important for each object to have SENSIBLE ATTRIBUTES rather than worrying about trying to keep objects from having direct references to each other.

Another big change in Version 5 is that we're moving away from DynamicEvent.replaces and DynamicEvent.replaced_by and instead our going with a list of events, which, in order, replace one-another, as DynamicEvent.timeline .

Last time, we did a lot of worrying about the real difference between 'Leader' objects and 'Unit' objects. How similar are they, really?

I think that we should go ahead and give Leaders HP. We could even give leaders MP. Maybe even Str and Def. In fact, is it possible for us to go back and look at what attributes Units have?

On second thought, no, let's not do that. Let's just focus on getting the Dynamic Rule System up-and-running with these Version 5 sensibilities. After that, we can worry about giving the objects all of their game attributes.

What arguments should be required to update_w_rules?

I feel like, ANY TIME AN ATTRIBUTE IS UPDATED, we should have a perpetrated_by object. Probably a with_ability and at_effectiveness, too.

But, what if a unit takes damage from poison when a turn ends.

Well, then the perpetrated_by would be the Leader unit and the ability would be 'end_turn' or whatever.

Should leader abilities be subject to effectiveness? Yes.

Should 'end turn' be a traditional ability? Maybe.

So, let's talk briefly about the way that battles run, internally. Last time, we talked about how, perhaps, battles can not -- or maybe 'should not' -- run without a UI. The UI propels the battle.

I was thinking about this, last night, and I'm not sure that's how I want to handle this. Perhaps battles could be coordinated INTERNALLY in some way and the UI just plugs into it.

So, if we were going to do this, how would we do it? How do we run a battle without a UI?

Basically, I feel like we do need some kind of 'battle' object to keep track of whose turn it is, for one thing. We had this problem before: if we have a 'battle' object, it seems as though we would need to send commands THROUGH the battle object in order for everything to register correctly.

For instance, if Vencabot, the unit, uses some ability and it brings his leader unit down to 0 AP. The battle's turn should go to the other team. Also, if Vencabot tries to act and it isn't his team's turn -- or he isn't the in the ring -- we would need some kind of failure. And that seems like a responsibility that should belong to some higher object.

It almost seems like it makes more sense to PLUG these objects -- units, leaders, battlefields -- into a GAME which RUNS, including some UI. How do we, for instance, automate a battle without a UI? Maybe we can and maybe we should. Yes, we would need some sort of 'battle' object to observe everything that happens and manage some things, but maybe that's for the best.

How much of these responsibilities can we attribute to the 'Battlefield' object? The Battlefield is subject to certain rules and attributes. When we talk about what units are in 'the ring', that could be an attribute of the battlefield or the leaders or both.

But one thing that the 'battlefield' should NOT know which the 'battle' object SHOULD know is whose turn it is. I feel like we need some kind of master object which records whose turn it is.

We've been stuck in a planning phase for a very long time. Some of our ideas are very abstract and difficult to implement. We're almost there to a point that we can get a playable version such that we can start seeing how the game behaves IN ACTION. We've been THEORIZING an awful lot, and I'm concerned that, once the game is playable, we're going to see that certain ideas that we've had are not going to be well-balanced or otherwise immediately FUN. We simply have to get battles working so that we can start to really see what our game needs to be more interesting and more fun. What sorts of ideas we may need to scale back. What ideas we could stand to explore more.

What if we have this 'battle' object, and it somehow manages battle. One thing that we ABSOLUTELY NEED a 'battle' object for is knowing whose turn it is. So, our battle has an 'active_turn' attribute which points to a Leader object. But what else does out 'battle' really need? And what does it really do?

Well, maybe it records win and loss conditions. Maybe, when some Leader reaches 0 HP, the Battle has some method which sends a victory or defeat message and divvies up EXP or whatever.

We could say that this 'Battle' object is the manager of the FLOW of battle. It handles turn transitions. It handles the start and end of battle. INTERNALLY. As something separate from the UI.

Perhaps, therefore, it should also handle Error messages. Nah, we should have error messages be per-object.

So, a focus of mock-up Version 5 is going to be having battles play out, internally, without a UI -- but to completion.

We were talking about what sorts of attributes would belong to the over-all 'battle'. We would need a ruleset, right? Or maybe not, because all of the DynamicObjects already know their own ruleset.

So, until we start giving Units and the Battlefield their own slots for rules, we don't need for the 'Battle' to have some special 'rules' value.

So, until we're ready to implement the 'Battlefield', we don't really need a Battlefield.

Right now, the Battlefield is basically just a vessel for rules and attributes that we have no purpose for, yet.

When we're talking about going back to 'redundant references,' we're talking in a major part about UnitAbility. Let's hash that out, first, and see what impact that has on our methods in our other objects.

Now that they're instantiated, do UnitAbilities need to be DynamicObjects?
 What sorts of rules would we want to trigger when an attribute of an ability is changed?

Well... abilities... can... maybe... gain EXP? Abilities can keep track of their own internal counters to change their properties. Including a counter which will prevent an ability from being used in some conditions.

Okay. UnitAbilities SHOULD BE DYNAMIC OBJECTS, just to be on  the safe side.

Let's say that we have an ability called 'gun'. And the gun can 'jam'.

Let's say that, when a unit uses 'Gun,' there's a 10% chance that it can jam -- and, when it's jammed, it can't be used anymore.

Maybe there's a rule on the battle (or on the unit) called 'unjamming' or something.

Basically, the rule can say, "If the Gun ability's 'is_jammed' flag changes to True, change it back to False."

So, we might need to know when an ability's attribute changes -- which means that it needs to be a DynamicObject.

Maybe it's sloppy that every DynamicObject has to have a reference to the 'ruleset'. Maybe instead of having OBJECTS BE DYNAMIC, we should have the Battle update these attributes and have the Battle be known by every object.

Because, in a battle, EVERY DYNAMICOBJECT SHOULD SHARE THE SAME RULESET. Right now, we're relying on the programmer to be certain that EVERY DYNAMIC OBJECT SHARES THE SAME RULESET. Maybe it would make sense for there to only be ONE reference to the ruleset and we update attributes THROUGH IT.

Right now, we update_w_rules like this:

target.update_w_rules(attr_name, etc.)

Maybe we need to do something like:

ruleset.update_w_rules(target, attr_name, etc.)

or

battle.update_w_rules(target, attr_name, etc.)

Of course, this relies on every dynamic object having a reference to the same BATTLE which is the same problem we have right now where every object has to have a reference to the same ruleset.

But it probably makes more sense to have every object have a reference to the battle that it's a part of, because then we can give those objects access to more interesting values than just what rules are in play -- including whose turn it is, etc.

I mean, we're talking about a LIBRARY CALLED 'BATTLE', where every object in it is meant to operate within a battle.

Maybe we should leave this for version 6, because, right now, we don't really fully understand what responsibilities this 'battle' object is really going to have. Yeah, let's just move forward with the traditional 'DynamicObjects'. We'll come back to this later; I think we're really onto something. I think that it makes more sense, in the long term, for every object to NOT have a direct reference to a ruleset. And, in doing that, we can get rid of the entire complexity -- the entire abstraction -- of this 'DynamicObject'. That makes sense to me.

We've fleshed out the Version 5 'battle' library, which means that, in our next session (Wednesday), we should have a fully-working battle, again. We're going to need to re-implement some test rules and test abilities, and we're going to need to implement the RelationshipHelper.

At that point, we should be able to start worrying about making a fully-working battle which even starts to throw errors if you try to do things that are impossible (such as using an ability when the unit can't pay the cost).

(Which strikes me: up until now, abilities GET USED and then their COST IS SUBTRACTED. The problem with that is that it allows abilities to be used even if the unit can't past the cost. Maybe abilities need some pre-emptive way to communicate how much they're going to cost? Some kind of can_be_used_when . I like that.)


05/29/19:

Would it make sense for the DynamicEvent to have a reference to the battle's ruleset so that we could implement methods like:

DynamicEvent.check_rules(), which runs the event through all of the current rules. That seems pretty tidy and it raises the question of whether or not we would even need DynamicObjects. If Events had a reference to the Ruleset, what else would even need a reference to the ruleset?

Some abilities would need reference to the ruleset to be able to add a new rule.

But, for instance, Leaders and Units and Battlefields definitely wouldn't need references to the Ruleset, anymore. We basically wouldn't need DynamicObjects.

In fact... Even if an ability was going to add a rule to the ruleset, maybe it would just target the 'battle' or something.

Okay... But here's the thing. Any time that a DynamicEvent is generated, the generating object needs a reference to the ruleset.

But what if only BATTLES COULD GENERATE DYNAMICEVENTS. Battles have a reference to the ruleset. And all of the objects in the battle have a reference to the battle they're a part of. I kind of like this LAYER OF ABSTRACTION, because it means that, again, every object in the game doesn't need a direct reference to the ruleset -- and, furthermore, it means that, when an object wants something to HAPPEN in the battle... it asks the battle to make it happen.

self.battle.create_event(target, new_value, self, effectiveness)

We'll save this for version 6, too. So, the main idea for Version 6 is to examine this "battle" object and have it replace the old idea of DynamicObjects and giving everything a ruleset.


Today, we got a lot accomplished in our Version 5 port. We've got the basic battle working again, but there are two major jobs left to be done:

1.) We need to port over ALL of the old Abilities and Rules.
2.) We need to implement the RelationshipHelper class to make it easier to create leader-unit pairs, etc.


05/30/19

I want to talk about moving away from 'DynamicObjects' and passing a 'battle' argument to the usage of a UnitAbility (or LeaderAbility, later).

Right now, all of our classes are DynamicObjects and they have an 'update_w_rules' method for altering their attributes against a ruleset. Therefore, all objects need to have a reference to the ruleset, which I think is a bit sloppy.

So, consider this:

Neither 'Units' nor 'Leaders' have any methods. Everything that they significantly 'do' in battle is relegated to their respective Ability classes. Therefore, you could think of Units and Leaders as being simple structures for organizing their attributes in an object-oriented way.

If we could move them away from being DynamicObjects, we could create an internal architecture that behaves like this:

Units and Leaders as organized data.

Abilities as motivators for action in our battle.

We have 'Battle' objects as the managers of battle, including managing the ruleset AND UPDATING UNITS, LEADERS, RULES, ABILITIES, ETC.

So, instead of, within an Ability, calling:

some_unit.update_w_rules("hp", new_value, etc.)

We would, in the ability, call this:

some_battle.update_w_rules(some_unit, "hp", new_value, etc.)

That would generate an event which would run through the usual 'rule' gauntlet.

Therefore, only one object would need a permanent reference to the ruleset -- the Battle -- and Ability.use_on would require an argument pointing toward the current battle.

That would minimize our references to the ruleset, and we wouldn't even need any permanent references to the battle. We could just supply the battle as an argument to use_on.

But what if we could simplify things even further by looking at the 'battle' simply as an event generator. What if the event had the methods for running itself through a ruleset, and we ran something like:

some_battle.create_event(some_unit, "hp", new_value, etc.)

That doesn't really many more sense than our other way of doing it.

So, we're pretty early in Version 5. Let's take tonight to translate over to this paradigm.


NOTE: In today's stream, we entirely moved away from the old DynamicObjects paradigm and, instead, created this 'Battle' object whose entire job it is to manage the 'dynamic' aspects of battle.

So, when you call an Ability, you give that method a Battle as an argument.

The Ability then uses that Battle's methods for 'updating' unit and leader attributes. The Battle, itself, generates and handles the DynamicEvents. Therefore, no individual object needs a permanent reference to the Battle or any Ruleset; instead, we just supply the Battle as an argument to any Ability that needs to 'do' anything.

This results immediately in some much cleaner code.

Next time, on Monday, I want to finish porting over the old test_abilities and test_rules to Version 5, and I want to implement the RelationshipHelper to shrink the overall size of our test_battle.py .

Also, we should change the name of battle.py to something less generic. We use 'battle' for a LOT of names, already, in all of our libraries.


06/03/19

New day, new stream. Right away, I want to focus on the RelationshipHelper whose job it is to marry objects together. Previously, to avoid having methods whose job it is to marry objects together, we attempted an architecture where every relationship was only one-sided: no two objects had a direct reference to each other.

Since then, I've decided that doesn't really suit the shape of our design, and so we're back to having objects that can directly reference each other -- which means that they need functions to effectively marry them together.

On the other hand, what I've decided to is to put those 'marrying' functions into a separate object. That way, we can keep things tidy and make it more clear, from a design-standpoint, that these functions aren't strictly necessary: they're just convenience functions.

Let's look at which objects need to be married together:

1.) When you make units, they take a leader as an argument. Then, you have to give the leader their party.

2.) When you make abilities, they take an owner as an argument. Then, you need to append the ability to the owner.

I think that's all that we have right now. So, what do our convenience functions look like:

A way to 'create' units directly onto a leader.

A way to create abilities directly onto a unit.

helper.create_unit_for(leader, unit_name)
helper.create_ability_for(unit, ability_class)

SIDENOTE: Although a lot of the responsibilities from the Ruleset have been moved to the new Battle object, we're leaving the Ruleset as the container for rules so that we can have an object to battle.update_w_rules against when we want to add or subtract rules. That way, we can have rules trigger whenever new rules are added.

So, ending today's stream, the RelationshipHelper seems to work, although it isn't saving us any lines. If it's saving us anything, in the long-term, it's in the way that it clarifies exactly what we're doing.

We're changing this rather impenetrable one-liner:

leader.party.append(Unit(leader, "Signopt"))

To:

battle.RelationshipHelper.create_unit_for(leader, "Signopt")

It's actually longer, but it makes it more clear what's going on: we're creating a unit into this party. It manages the arguments that the unit needs on instantiation.

This makes no sense. This method is pointless.

Will this RelationshipHelper become more useful as the relationships between objects become more complex? The whole point of this RelationshipHelper is to marry two objects together that need a reference to one-another that must be consistent.

For instance, we could very easily break our code in a way that's VERY DIFFICULT TO DEBUG if we did something like this:

a_leader.party.append(Unit(b_leader, "Signopt"))

I mis-typed ONE CHARACTER THERE. Now, a_leader has signopt on their party but Signopt thinks that its leader is b_leader. So, we have a broken relationship.

That's what the relationship-helper is supposed to manage:

battle.RelationshipHelper.create_unit_for(a_leader, "Signopt")

In that example, we don't risk that same bug.

I think, in the long-term, especially as the two-sided relationships between objects becomes more complex, the purpose of this relationship-helper is going to be realized.

For now, it's not really saving us any work or headache, but it's already
making things a bit more consistent.




06/05/19

I'm porting over the old 'seal rule' code. Seal Rule is supposed to UNDO the effect of a particular rule after it triggers. How is this going to behave, in practice?

Let's say that 'Hench' is sealed.

When Vencabot is attacked by Sirius, an HP change event is generated.

When Hench sees that Sirius is going to do damage to Vencabot, it doubles that damage.

Seal Rule gets a copy of ALL events that are being passed through the battle. It checks those events to see if they've been either CREATED BY or TAMPERED WITH by the sealed rule.

Then, it walks back through the event timeline to find a point before that event was tampered with by that particular rule.

My question is this: what if we have a situation where an event is tampered with TWICE before it reaches the check for Seal Rule.

So, if Sirius is under the effect of Hench and And One, he will do double damage and then ahve one damage added to his attack.

So, we have a bug. Because, if this updated event, after going through AndOne, reaches Seal Rule, Seal Rule will not recognize that the event was updated by Hench. It only looks at the most recent update, so it's going to see 'And One'. Not 'Hench'.

EVEN IF we walked back through the timeline to see if 'Hench' was ever triggered, how do we UNDO AN EVENT IN THE MIDDLE of this timeline? We can't. We would need to somehow REDO everything AFTER that mid-timeline event.

So this project is too ambitious for me to approach when we're already late for 3rd Strike.


NOTES FOR THURSDAY: We ported over (almost) all of the old rules, and we're going to test them tomorrow. We've tested Rage, Hench, and Invincible. After we're done testing Rules (which I don't think will take terribly long), we're going to port over the old Abilities (there weren't that many) and test those.

After that, we can finally start giving more attributes to units and leaders to better reflect how our game is actually going to play. We've been doing a lot of very BASIC tests to make sure that the Dynamic Rule System is behaving. Now that we're almost done with that, we can actually start to flesh out a real, working battle for our game. We'll hopefully be well into that by next week.



06/06/19

Today, we're going to finish testing the OLD rules from Version 4 and then see if we can get 'seal rule' working correctly, because, right now, it's totally bugged out -- and I feel like it's important to our concept that we be able to have rules like that.

I have a question. When we instantiate a Rule, we always need an ability that spawned that rule.

Nevermind. Let's just assume that, sometimes, rules are NOT spawned from abilities (they're inherent to the battle or attached to some unit), and so, whenever we check for a 'from_ability', we need to make sure that it's not None. We have to assume that it can be None.

But here's another question, then. Can we have DynamicEvents that trigger without a by_ability. The answer would appear to be 'yes,' because Rules, themselves, can trigger events. And Rules don't necessarily need to spawn from abilities.

So... can we say that DynamicEvents don't necessarily need to have a populated 'by_ability' field?

I think that we need to say that event.by_ability CAN BE NONE just as well as event.triggering_rule can be none. You could have both, or you could just have one or the other.

So, any time that I check for event.by_ability, I have to first check that it's not None.

Test what happens when a poisoned unit is invincible.

Okay, everything's working EXCEPT FOR SEAL-RULE. And I'm not sure how we're gonna get that to work. I thought we had it working, before, but it turns out that it was bugged all along. So, we need to reconsider the way that 'seal rule' works and re-implement it.

One thing that we can do... is look for when the sealed rule is triggered. But I don't think that, when the rule is triggered, we have any way of knowing what events were produced so that we can edit them.

But what if we did.

What if, whenever... an ability... is used... or an event is triggered... we somehow get a report of what events were generated.

Let's put that idea on the back-burner for now, because it would require reconsidering -- AGAIN -- some of the most fundamental ideas of how our game works.

Let's see if we can find a solution that fits better into the framework that we've already developed.

Dixx points out, "can we just check to see if the rule is sealed BEFORE applying it." That was my first idea for sealing rules, and it requires what's known in object-oriented programming as an "attribute".

That solution would involve giving EVERY RULE an attributed: "sealed". That attribute can return TRUE or FALSE.

By default, some_rule.sealed would return False.

If we use Seal Rule on it, then some_rule.sealed would return True.

We could then use this attribute to say, "It's time to run Poison. Is Poison sealed? True? Then don't run it."

The problem with this is that it requires STANDARDIZING the idea of a rule being 'sealed,' and there's many levels of rules being stacked on rules and affecting how other rules behave -- and we can't standardize them all. That's why I moved away from this idea of having a 'sealed' attribute. It's a bad precedent to set and I thought I had a better solution.

But, I'm glad that Dixx brought that up, because, SINCE WE LAST DEFINED 'SEAL RULE,' we came up with a new technology in our game called 'tags'. Back when we first conceived 'seal rule,' rule tags didn't exist. But now we have this standard ALREADY IN PLACE and ALREADY WIDELY USED and ALREADY KNOWN TO BE SUPER USEFUL.

The cool thing about TAGS is that they address the very problem that I just talked about above with 'standardization'. Tags don't need to be standardized.

Dixx's question is "what's the difference between attributes and tags," and it's an abstract difference that relates to the heart and soul of object-oriented programming.

So, basically, 'tags' is an attribute on rules:

some_rule.tags

And 'tags' is a LIST, and, by it's nature, a LIST is meant to be DYNAMICALLY EXPANDED and CONTRACTED. Things are all-the-time being ADDED TO THEM and REMOVED FROM THEM.

On the other hand, 'attributes' should almost always, whenever possible, be standard to a type of object -- in this case, a "rule". So, my big problem with adding 'sealed' as an attribute to rules would be that it would need to be an attribute of ALL rules and, if we made every 'affect' stacked onto a rule into an attribute we would end up with a ton of junk attributes on our rules that are very rarely used.

ON THE OTHER HAND, it makes perfect sense for us to ADD A TAG (because tags are a list) to a rule and then, when that rule becomes unsealed, we REMOVE THAT TAG. It doesn't suffer the same problem of 'standardization' as if we were to make it an attribute, where it would need to be on that rule all the time even if the flag was False.

In Python, you CAN check all of an object's attributes ESSENTIALLY AS A LIST, but it's meant for what's called 'introspection' or meta-programming and you don't want to fuck with that on a regular basis if you can help.

But let's move forward with the notion of applying a 'sealed' tag to our sealed rules and see how that affects our game.

We have other problems at play which would make it impossible for us to prevent a rule from triggering just because it has the 'sealed' tag. That wouldn't be impossible. It would even be quite reasonable -- but, again, it's a matter of setting a precedent that could become impossible to manage in the longterm.

So, the question really becomes this: CAN WE PREVENT A RULE FROM TRIGGERING WITHOUT LOOKING INTO ITS ATTRIBUTES (INCLUDING ITS TAGS) FOR A PARTICULAR FLAG.

The answer would appear to be 'no,' and that's exactly we had this 'rollback' system for Seal Rule in the first place.

You can't prevent a rule from triggering. It's gonna trigger if its trigger-conditions are met -- and we can't just make one of its conditions, "If I'm not sealed," because, again, the state of 'sealed' is just one of countless states that our game could end up requiring, and we can't just re-write every single rule every time we come up with a new state like this.

So, the question that we need to answer is CAN WE. UNDO. A SELECTED EVENT.

This is the problem that has haunted our development for the past few months that we've been doing this. This question always comes up and the answer is always "no." Often times we think that we have a solution, and it always ends up backfiring.

We've always found, consistently, that we can PREVENT rules from having an affect IN ADVANCE, but we can't come back AFTER a rule has triggered and UNDO it.

The problem, here, is the ORDER of the rules.

If I say, "Vencabot is poisoned."

"Now Vencabot's poison is sealed."

I can not prevent that poison damage because the sealing happened after the poison. But our game necessitates that.

Let's be real, though. The way things are engineered, now, I CAN PREVENT THAT POISON DAMAGE. 100%. I seriously can look at the damage event and say, "Was this damage generated or affected by poison? Then get rid of the damage."

The problem is finding WHEN, in the event's timeline, it was tampered with by the sealed rule and UN-TAMPERING IT. That's what's our current problem.

If we could KNOW WHEN AN EVENT IS UPDATED AND ATTACK ~THEN~, we could UNDO the event update. That would resolve the issue of us having to wait for the event to go ALL THE WAY DOWN THE ASSEMBLY LINE before it reaches us.

(And for the sake of clarity, I think I am going to use this 'assembly line' analogy more often.)

So, let's demonstrate out problem and think through it:

We have two modifiers for damage: Hench (doubles damage) and And One (adds 1 damage).

We want to seal Hench.

Let's see how the assembly line looks:

Vencabot Slaps Dixxucker for 10 damage (triggering no rules).
|
Vencabot Slaps Dixxucker for 20 damage (triggering Hench).
|
Vencabot Slaps Dixxucker for 21 damage (triggering And One).

At this point, at the end of our assembly line, we want to seal Hench.

I believe that this is something we can't do.

We can look through the timeline of this assembly line and we can SEE that HENCH was triggered in the middle.

But what we CAN'T SEE -- what we have no REPORT FOR -- exactly what And One did. And One happened afterward. We could easily roll back from where we were before Hench:

Vencabot Slaps Dixxucker for 10 damage (triggering no rules).

But we don't have a mechanism in place to then re-apply And One. It would make sense to roll back from Hench if Hench was the most-recent update to the event. The problem is that Seal Rule is occuring AFTER And One.

Maybe one solution would be insert Seal Rule directly after whatever Rule is being Sealed.

Seal Rule is a "before" rule. So, if it's sealing an 'after' rule, it can be at the end of the Before -- no, no, no.

If it's sealing an After rule, it needs to be at the START of the Before list.

If it's sealing a Before rule, it needs to be directly AFTER the rule it's sealing.

That's solution 'A': selectively position 'seal rule' in the rule list. Change it's place in the assembly line so that it always directly follows the rule that it's sealing.

Solution 'B': what if DynamicEvents were effectively DynamicObjects... and we could run Rules when the EVENT is updated.

Like, what if, when you run dynamic_event.replace_value(), it runs the new event through some 'meta rules' list.

That's kind of tidy.

We'll implement one of those two solutions next time. We gotta play third strike.

06/10/19

Solution A isn't a SUPER SOUND SOLUTION because it RELIES on the fact that the 'seal rule' always directly follows the rule that it's sealing. If it were to be moved around for ANY REASON, it would not only cease to work but would cause bugs.

The problem with the 'meta rules list' idea is that these special 'meta rules' would need to take a different shape of 'event' compared to normal rules, and I'd like to keep things standardized.

We could use battle.update_w_rules(some_event, "new_value", so-on and so-forth)

I guess the thing to do... would be... to change the 'replace_value' method to call battle.update_w_rules.

But, for that, Events would need to know the Battle they're a part of.

I don't see any reason why they shouldn't.

It'd be impossible to call update_w_rules on some_event.new_value, because 'new_value' never changes. Instead, we update the timeline. The timeline is the only mutable attribute of a DynamicEvent.

So, we would need to call battle.update_w_rules(self, "timeline", so-on-and-so-forth)

It seems to me that we now have a mechanism where, whenever an Event is updated, we can run some rules.

So, that changes the way that we can look at how 'before' rules work. Now, they can directly target a situation where a rule has altered an event.

Before we get 'Seal Rule' working, let's go back through our existing Rules and see if we can't change how they behave to take advantage of this new mechanism.

We've got a problem. We can't update the timeline to be a brand new list because we rely on the identity of the old list to keep all of the events in the same timeline synchronized.

I could make an EventTimeline object whose only purpose is to store a list as an attribute. That way, we could update the list while still having an identity to point all of the Events to. I mean, that would be a quick-and-dirty solution.

I like it, honestly. I like it because, if we're gonna have a DynamicEvent that gets generated whenever a timeline is updated, the architecture should reflect that.

Right now, we're saying:

"This event's timeline is being updated."

But, really, all of the events share the same timeline. So, that's deceptive. That could be engineered in a way that's more clear.

If we have an EventTimeline object, we can say:

"This timeline is being updated."

That's more clear, anyway.

Seal Rule is now triggered when:
    A DynamicEvent is fed in where a Timeline is being updated.
    If that Timeline is being updated by the sealed Rule:

Then what do we do?

For one thing, we could just PREVENT THE UPDATE. That's the easiest thing to do.

The problem with this is that it doesn't leave a paper-trail.

BUT IT DOES.

We just need to. Roll back. The event. It does leave a paper-trail.

Wait, wait, wait. Are we gonna end up having the same 'order of operations' problem that we always have?

I wanna say "no," because now we have this new vector of attack -- this DynamicEvent which targets the timeline. Now, we have a whole extra dimension to examine what's happening in our game. Because we can look at a timeline of timeline changes.

I want to roll the timeline back to what it was before this rule was triggered.

I feel like we're coming up on the same 'order of operations' problem.

We've had this problem since day 1 of this project, literally: "how do you roll back an event." "How do you prevent a proposed change from triggering."

How can I verbalize this problem?

KReich slaps Vencabot.
KReich is Hench.

The Slap proposes a HP change of -10 to Vencabot.
Hench sees this event and proposes a new event -- a timeline update -- where the HP change is -20.

Seal Rule looks for this timeline change and changes the timeline, again, so that the HP change is -10.

That makes no sense. We're proposing TWO timeline changes. The original timeline change never actually goes through. That's a huge problem.

Proposing and pre-empting changes to a timeline is a really weird idea. Oh. Well, this should. be. an 'after' rule. An 'after' rule. It takes place AFTER the timeline is changed. Okay. Let's look at it that way:

The Slap proposes an HP change of -10 to Vencabot.
Hench sees this event and proposes a new event -- a timeline update -- where the HP change is -20.

After the timeline has changed, Seal Rule sees that it changed and changes the timeline, again, so tht the HP change is -10.

On Wednesday, I'm gonna try my DAMNEDEST to break Seal Rule.

Seal Rule is now an AFTER Rule. How are we gonna break it? It's gonna definitely be contingent on two rules simultaneously looking for changes to the timeline. That's what's always broken these sorts of rules in the past, but I feel like, now that I've found a way to make it an AFTER RULE, that's not gonna be the case any more.

But we're gonna dedicate to Wednesday to making sure that I'm right about that. Is there a way to break Seal Rule, now -- or any Rule which depends on looking at a change being made by another rule and preventing it.


06/12/19

Today, we're trying to break Seal Rule. Let's theorize some situations to test that could potentially break a rule like this.

1.) The most obvious thing -- because it's what usually breaks these sorts of rules -- is to have two different rules waiting for the same sort of event such that they might interfere with each other based on the order of their operations.

So, Seal Rule is waiting for a certain other Rule to trigger, and then it effectively UNDOES its effect.

So, let's say that Seal Rule is sealing Hench. And then suppose that we have a Rule that's supposed to trigger whenever a unit's damage is doubled. So, if they're both essentially waiting for Hench, is this going to cause a problem where the second Rule's triggering will prevent Seal Rule from working correctly?

So, the only way to test this is to test it, because we're getting to challenges that are so abstract that it's giving me a headache just to try to imagine. So let's not imagine it: let's just test it. Let's design this new rule:

"If the target's unit's damage is augmented UPWARD, they take damage." What's the name of this rule? "Growing Pains".

It strikes me that a lot of our existing rules could probably be updated to look for event timeline changes, and that might be a more reliable way, over-all, to handle these sorts of rules which take affect based on the affect of other rules.

I hate to say it, but I need a lot more diagnostic code. Not a lot of code, but a lot more output. I'm just gonna make a one-line change to the way that 'update_w_rules' works to add a lot more diagnostic output.

In vanilla Python, you would say:

"Vencabot attacks KReich for 10 damage."

KReichJr.hp = KReichJr.hp - 10
or
KReichJr.hp -= 10

In our game, we don't directly modify attributes like this because we want to generate a REPORT that tells the DynamicRules about PROPOSED CHANGES to attributes and FINALIZED CHANGES to attributes.

So, instead of updating Kenny's HP directly through his .hp attribute, we do this:

our_battle.update_w_rules(KReichJr, "hp", KReichJr.hp - 10)

print(KReichJr.hp)
>> 20
KReichJr.hp -= 10
print(KReichJr.hp)
>> 0

Growing pains is working. The whole point of this was to try to break 'Seal Rule' by having two rules look for the same criteria but in a different order. So, let's examine this new "Growing Pains" scenario theoretically to see where and if it's gonna fail.

In our example, Seal Rule prevented Hench from triggering, the first time, and so Growing Pains did not trigger. Let's examine this situation.

Is it possible for Growing Pains to TRIGGER BEFORE HENCH is sealed.

Both GrowingPains and SealRule are waiting for an update to the event timeline.

When SealRule triggers -- and THIS IS THE CORE DIFFERENCE WHICH I BELIEVE WILL FINALLY SOLVE ALL OF THE PROBLEMS AND BUGS THAT WE USED TO HAVE -- when SealRule triggers to prevent 'Hench' from working, IT DOES NOT, ITSELF, MODIFY THE EVENT TIMELINE.

It CHECKS the Event Timeline, but it DOES NOT NEED TO ALTER THE EVENT TIMELINE IN ORDER TO PREVENT HENCH FROM WORKING.

Instead, SealRule updates the EVENT. The abstraction is so subtle, and that's what makes it so annoying -- but powerful.

It doesn't even add a new event to THIS TIMELINE. It's because it's not looking for the event that CHANGES THE HP. It's looking for the event which CHANGES THE TIMELINE. And whenever the timeline is changed, we get a BRAND NEW EVENT WITH ITS OWN TIMELINE. We events on events, we got timelines on timelines.

So the advantage we have with this new system is that SealRule and GrowingPains are not looking at the same event, really. I don't think so. Let's theorize. I'm pretty sure they're not looking at the same event.

Vencabot creates an event when he attacks Kenny. The event says, "Kenny's HP is changing as a result of Vencabot."

Hench looks at that event and UPDATES THAT EVENT, CREATING A NEW ENTRY IN ITS TIMELINE. It updates it so taht Kenny's HP is reduced twice as much.

SealRule is waiting for an event that says that an event was updated. It sees that the 'hp change' event was updated by Hench, and so it UPDATES THAT EVENT AGAIN, creating a new entry in the 'hp change' timeline, and creating a WHOLE NEW event that says that the timeline was updated.

Where does 'GrowingPains' fit into this? Why didn't GrowingPains trigger when Hench was sealed?

GrowingPains is failing twice when I only expected it to fail once. I think that it's failing twice because it's - no. It's because it's also triggering when Hench is updating the timeline.

It's failing when Hench updates the timeline and when Seal Rule re-updates the timeline.

But the question I have is, why is the timeline the same both times?

I was right about why it's failing twice. Why is it failing on Seal Rule before it fails on Hench? Hench is TRIGGERING first. Hench is FINALIZED first. GrowingPains is looking for a timeline update. But Hench's timeline update completes BEFORE Seal Rules, doesn't it?

Slap proposes an HP change [EVENT0HC created].
Hench proposes an update to that HP change [EVENT1TC created].
The update to the HP change event completes [EVENT0HC updated] [EVENT1TC finalized].
Seal Rule proposes another update to that HP change [EVENT2TC created].
That update to the HP change event completes [EVENT0HC updated] [EVENT2TC finalized].
GrowingPains sees




When Hench changes the timeline, Seal Rule is triggered immediately.
When Seal Rule changes the timeline, GrowingPains is triggered immediately.

Once that process is complete, then Hench's change finally dribbles down to GrowingPains. That's why GrowingPains sees Seal Rule first.

The reason that both times that GrowingPains is triggered it sees the same timeline is because timeline is a mutable object that we're referencing by identity. By the time it sees it the FIRST TIME, Seal Rule has already triggered. so, even though Growing Pains is triggered the SECOND TIME by Hench, the timeline change from Seal Rule has already taken place.



06/13/19

Today, I would like to break Seal Rule if I can figure out a way to do that.

As I was thinking about this problem last night, it struck me that perhaps a rule like "GrowingPains" is never going to break Seal Rule. I even theorized that we could successfully SEAL SealRule using SealRule. Having this extra axis of attack on the DynamicEvent system is really adding so much flexibility to our mechanics.

So, how WOULD you break Seal Rule?

Seal Rule looks for a DynamicEvent that occurs when another DynamicEvent is altered.

It's an After rule. I just can't think of a way to break this. I think that tonight -- the hour that we have -- might be better spent looking at progressing toward our fully-working battle.

I'm afraid that one day I might find a situation where our Dynamic Rule System breaks down. But I can't just keep wasting streams trying to find those weaknesses; the system is just too complex. In fact, we might be well-served at this point to start doing some kind of documentation.

Yeah. Before I start moving toward the fully-working battle, maybe it's time to start documenting the Dynamic Rule System so that another programmer that joins this project (like KReichJr) will have a clearer understanding of how it works.

Tonight, let's look through our battlelib and start looking at how we can commentate our features.

Right now, the biggest difference between our EXISTING mock-up and our FULLY-WORKING BATTLE is that we need a more fully-fleshed-out implementation of the Unit.

If a Ruleset is changed during the processing of a DynamicEvent, how does the change in rule-list length affect the 'for' loop? Is this a bug?

############## LOOK ABOVE ###############



06/19/19

Before we get started, I notice that, at the very end of our last programming stream, I theorized that we might have a bug with the way that we handle iteration through a rule-list. Because, during iteration, the length of the list can change. Let's make sure that we're working on this loop correctly.

To break Rule iteration, we would need an After rule which adds or removes another After Rule. I think that we'd get the better 'breaking' result by removing an after rule during an after rule.

So, we would need two Rules to test with: one generic 'after' rule (could just print a message) and one after rule which REMOVES that rule.

It strikes me that, whenever you update the list of rules, you're almost certainly going to be using Battle.update_w_rules.

What's particular about update_w_rules -- and, by extension, our entire Dynamic Rule System -- is that it doesn't support mutability at all. This has some interesting caveats when you start thinking about updating the list of rules, some of which will actually have ramifications on gameplay.

In particular, IF YOU ADD A RULE ON A TURN, YOU CAN NOT TRIGGER THAT RULE ON THE SAME TURN. Or, you CAN, but it will be somewhat unpredictable (which is kind of a problem).

Basically, whenever an event is being processed through a list of rules, that 'for' loop is fixated on a single list.

If the battle's ruleset is updated during that process, a brand new list is created (that's how 'update_w_rules' works). Therefore, the ongoing processing of the event WILL STILL BE USING THE ORIGINAL LIST OF RULES.

But then, as soon as a new event is being processed, it'll be using the NEW list of rules.

Let's focus on these 'bugs' one at a time. First, I want to make sure that we can't break rule-processing due to the mutability of the rule list. After all, not every update to the rulelist will necessarily be going through update_w_rules (although it SHOULD). We probably need to fail-safe or foolproof this, so let's prove that.

We solved our first, obvious bug. But now we have a new bug, which may itself not be a "bug" and may not need fixing, but it MAY result in behaviors which are somewhat unexpected by the player. And I want to demonstrate that.

So, if we have an after_rule which ADDS a new after_rule, that new after_rule can not be triggered in the same processing phase which triggered the first after_rule.

However, that new after_rule CAN be triggered by NEW events which are the RESULT of another after_rule. So, the problem that we're facing is that there will be situations which may be difficult for the player to discern where new rules are INSTANTLY TRIGGERED and other situations where new rules will NOT be instantly triggered. I would like to demonstrate both scenarios and how confusing this can be.

What I've proven with our first 'salty' example is that, although the same criteria of event triggers both goodvibe BECOMING salty AND his salt giving him ATTACK POWER, he doesn't gain attack power the FIRST time he becomes salty.

You might think that, because him BECOMING salty and him GAINING attack power are both triggered by him taking damage, that the sequence of events would go like this:

GoodVibe takes damage.
GoodVibe's 'salt' is triggered, meaning that, when he takes damage, he'll now gain attack power.
He gains attack power (because he took damage).

It doesn't play out that way because when 'Salty' is triggered, it adds a new rule (when he takes damage, he gets attack power), and that new rule can not be triggered on the same phase that it was created.

That's fair, that makes sense -- that's predictable. But what's NOT predictable (maybe) is that, although this new rule can NOT be triggered on the same "phase," it can be triggered on the same TURN or ACTION. Because these ideas, internally, are distinct. We can prove that simply by making GoodVibe take damage TWICE from the same action.

Maybe we have another Rule where, if GoodVibe takes damage, he takes damage again.

I've proven my point.

When GoodVibe is pessimistic, he can GAIN A NEW RULE WHICH GIVES HIM ATTACK POWER WHEN HE LOSES HEALTH, and that rule CAN BE TRIGGERED ON THAT SAME ACTION.

He loses health, which gives him a new rule that's triggered when he loses health.
His losing health causes him to lose health, again.
His new rule is triggered, because he just health.

That all happens based on him getting slapped.

However, this won't happen if he's not pessimistic.

He loses health, which gives him a new rule that's triggered when he loses health.
Nothing happens after that. The new Rule isn't triggered, even though he just health.

Is this a 'bug' worth addressing, or is it pretty clear to the player what the difference is between these two situations? Right now, I'm sort of leaning toward the latter. Even though both 'hits' are triggered by the same 'slap,' it's clear that, in the first example, the damage which TRIGGERED 'salt power' came from his Pessimism -- not from the slap, itself.

So, any time that a new rule is added as the result of another rule, it won't be triggered by that same event. But, if another event is created that WOULD trigger it, by that same action, sure, it can be triggered THEN. It just can't be triggered by the same exact event.

I'll look at this again, tomorrow, but I'm pretty sure that this isn't a bug that's worth worrying about. I think that the behavior will be more-or-less understandable by players. When any new rule is added as the result of some action, it can't be triggered by that same exact event.




06/20/19

Today we're going to be doing kind of a short development stream where we look at the 'units' for our battle system and give them the attributes they're going to need in order to satisfy our original design documents.

Units, right now, have a couple of attributes that we've been using for testing:

HP
ATK
MP

But they're going to need quite a few more attributes than that in order for our battle system to be considered fully-working. Let's break down what we know, so far, about the attributes that our units are going to need:

HP - The amount of damage that a unit can take before they're 'knocked out' and can no longer act.

ATK - A base value used for attack damage multiplication.

MP - A resource typically consumed by using abilities that represents a limit to how many abilities a single unit can use in battle.

Here are some ideas for other attributes that we've been strongly considering for our combat system:

DEF - A base value used to diminish damage done to this unit. It's meant to have a larger impact on weaker abilities; that way, attacks that hit multiple times for less damage (potentially adding up to MORE damage) will be less effective against units that have high DEF. In order to effectively damage a unit that has high DEF, you need to deal damage in large chunks.

SKL - An offensive value that raises the 'effectiveness' of abilities against another unit.

PRY - A defensive value which lowers the 'effectiveness' of abilities against this unit.

XST - A percentage which temporarily diminishes the maximum attribute values of a unit based on how many encounters they've been through since they last rested. Meant to encourage the player to swap party members to keep them rested.

LP - A value representing the number of times that a unit can be revived after being knocked out. Some attacks can damage LP directly. When LP reaches 0, the unit is 'destroyed' on a semi-permanent basis.

MAX HP
CUR HP

MAX LP
CUR LP

MAX MP
CUR MP

REAL XST
AUG XST

REAL ATK
AUG ATK

REAL DEF
AUG DEF

REAL SKL
AUG SKL

REAL PRY
AUG PRY

REAL TAGS
AUG TAGS

It's been a few months. Let's re-examine some of these ideas that we came up with when we were originally designing our game.

First, let's re-examine the idea of permanently-bound equipment. I still think that's a cool idea; that's probably all that we need to say about it for now. When you capture a new unit, you bind it to some item which will affect that unit's growth. We also discussed the possibility that this equipment would determine the unit's tertiary class and maybe even offer them some extra dynamic. In fact, we should lock that in: I don't think that units, in their most raw form, should have three classes. I think that units should have a Primary Class and a Secondary Class, and the Tertiary Class comes from their equipment, which is universal across any unit.

We talked about how units should have some kind of 'elemental' value which may affect how certain abilities affect them. We've since changed, updated, and improved that idea to this notion of units having 'tags.' Any number of tags.

Units have Dynamics. I think that this should be a list, and any unit can have any number of inherent Dynamics -- including some which may be attributed by their equipment.

Let's talk briefly about the idea of our game's 'class' system, which I've been re-examining on off-stream hours.

I feel like, for the sake of making each unit feel more unique, the abilities that each unit has should be, at the very least, re-named to suit that unit.

But I do like the idea of 'classes' determining what these abilities DO. Like, each unit would have a couple classes, and these classes would determine their abilities. But it's much more to do with what these abilities DO and are USED FOR than anything to do with theming. Because we're gonna have classes that might be shared between My Little Pony and Jason Vorhees, so I feel like we could get caught up in the idea of what these abilities are meant to represent. I think that it makes more sense to say that "warriors have a basic attack ability which does double their base ATK and costs 2 MP." And then every unit would have a different name and potentially graphical affect for this ability.

So, internally, how are we going to architect these units considering these classes?

Maybe. Every. Unit. Should have unique classes designed for THEM which are BASED on universal classes. That way, we could give the unit these 'classes' and their abilities (which, as we discussed above, are TECHNICALLY but not ENTIRELY unique to that unit) still live in those classes, which are, themselves, TECHNICALLY but not ENTIRELY unique to that unit.

On the other hand, if every unit has classes with unique names, then it doesn't really do the player any good to know what these classes are. That's kind of a dumb idea.

I think that units need an Abilities list, and they draw those abilities from some pool that's based on their class. In fact, we discussed that abilities should have permutations? And also I came up with the idea of units only being able to bring so many abilities into any given battle? We need to reexamine these ideas.

When Units are captured, they only know a few abilities from their classes. As they level up, they can learn more of these abilities.

But units can only equip a limited number of abilities at a time. As they level up, they can unlock more slots for these abilities.

What makes more sense, then: giving the unit a maximum number of abilities TOTAL, or giving the unit a maximum number of abilities PER CLASS.

If you give the unit a maximum number of abilities TOTAL to use at once, you're essentially giving them extra incentive to bring in their MOST POWERFUL abilities. Which are almost certainly going to be from their Primary Class.

If you give the unit a maximum number of abilities PER CLASS, you're encouraging them to mix the abilities of their classes together. But, is this the sort of encouragement that we want to give the player? Shouldn't the afforded tactical flexibility of multi-classing be incentive ENOUGH for the player to equip abilities from BOTH or ALL of their classes?

Consider Tertiary Classes. If a Unit is limited in the number of total abilities that they can bring into combat, you're almost never gonna see anyone bring in abilities from their Tertiary Class. The whole idea that we conceived for Tertiary Classes was to have weaker abilities which afford a very small amount of tactical flexibility that might be useful in edge-cases or otherwise when the Leader has little AP remaining or the unit has little MP remaining.

If there's little incentive to bring in these tertiary skills, is that a problem with the SKILL SLOTS (we should give them a limited number of abilities PER CLASS) or is it a problem with the whole idea of TERTIARY CLASSES (we need to make these classes / abilities more interesting to make the player want to take these abilities into combat).

I want to make an argument that the available ability slots should be limited PER CLASS: we could give the player an INTERESTING DECISION TO MAKE when it comes to WHICH class to expand in terms of abilities availble per battle.

Because, the Primary Class has access to that unit's most POWERFUL abilities. What if it cost MORE to unlock new slots for the Primary Class. Then, the player would be encouraged to fuck around with their secondary and tertiary classes despite the fact that those abilities aren't inherently as POWERFUL, NUMERICALLY.

Maybe a system like this would ENCOURAGE the player to EXPERIMENT with the notion of secondary and tertiary classes. Otherwise, they might over-fixate on the NUMERICAL SUPERIORITY of their PRIMARY skills and then find themselves tactically limited in battle and not understand why they're losing. So maybe if we made it more AFFORDABLE to multi-class, players would be more encouraged to do that and, as a result, experience battle more in line with what we expect as game-designers.

With this suggestion, LEARNING tertiary abilities would be cheaper (because the abilities, themselves, are weaker) and buying slots for the tertiary class would be cheaper (because only weak abilities are going into those slots).

Buying abilities for the Primary Class would be potentially more expensive (because this class has access to more powerful abilities), and buying slots for this class would be more expensive (because those slots could potentially be filled with more powerful abilities).

I like that idea. It encourages the player to experiment with their tertiary and secondary classes. It means that you're going into battle and you're always going to have access to your secondary and tertiary classes in some capacity, defining how that unit is used. You can't just load up on Primary Class abilities and only use the best of those and make a unit which is tactically less flexible but more specialized.

That, in itself, could be an interesting decision to offer to our players: do they want for their unit to be more FLEXIBLE or more SPECIALIZED. But I think that, with the way that our gameplay has been designed so far, it makes more sense for us, as game-designers, to maintain some control over how specialized or flexible a unit-type is.

Notes for the new guys:

* Every Unit has three classes: Primary, Secondary, and Tertiary

* Every class has three tiers of abilities: Tier 1, Tier 2, Tier 3.

* Which class 'slot' a particular class is in, on a unit, determines which tiers of abilities that unit has access to.

* If a class is that unit's Primary Class, they can learn abilities from ANY of the tiers.

* If a class is that unit's Secondary Class, they can learn abilities from the first two tiers.

* If a class is that unit's Tertiary Class, they can only learn abilities from the first tier.

This means that, if a class is your Secondary Class, you'll have access to all of the abilities of that class EXCEPT for the most 'powerful' abilities.

If a class is your tertiary class, you only have access to the least 'powerful' abilities in that class.

So, in terms of attributes -- like, programmatic attributes -- we need lists and numbers for how many slots from each class we have.

What's the best way, programatically, to assign things like CLASSES and ABILITIES to a unit? Right now, for our temporary mock-up, units just have a list of abilities. But how are we going to organize that for units in the long-term?

Units need slots for the Rules they're under the affect of. They can only be under the affect of two Ally Rules and two Enemy Rules at the same time. We're gonna really need to examine how that's gonna play out.



06/24/19

Today, I want to continue looking at how to architect the 'classes' and 'ability' systems. We can also look at fleshing out the other attributes that Units need, including their limited slots for new Rules.

Maybe the solution for Abilities will come to us if we review this idea of 'gacha' abilities, where there's some randomness applied to the Ability that you learn.

Let's see if I can find those notes.

I found our old notes regarding 'gatcha':

1.) Units are born with some seeds which determine the variant of Abilities they get.
2.) These seeds are balanced against each other so that a single unit doesn't have too many 'good' seeds -- or bad seeds -- so, they don't get too many godlike or trash ability variants.
3.) Abilities can vary in their 'severity' and 'effectiveness' and 'status change they inflict' and 'cure condition' and a bunch of other terms that I didn't really seem to understand at the time.

These notes are from a time before I personally (maybe even off-stream?) came up with an idea for the gacha element coming into play when BUYING abilities from a class.

The idea is that, when units complete battles, they're awarded some kind of currency that you can use to upgrade that unit in a variety of ways -- including learning new abilities from their classes. I had this idea where, when you buy an ability, you get a randomized variant of that ability -- and then you could buy it AGAIN to get a new, randomized variant of that ability.

And I sort of understood it as the unit being able to accrue a more-or-less indefinite number of the same ability which they could selectively choose to equip. Maybe they'd be limited to having only one variant of a particular ability at a time, or something.

But, re-reading these notes from my conversation with Dixx, I feel like that might not be the most elegant solution. In a monster-collecting JRPG, 'gacha' is always an element, and I sort of like the idea that you might want to re-capture a unit-type that you already have just to see what its variant abilities are. If you could just keep re-buying the same ability over and over again until you get one that you like, there really is no difference between two units of the same unit-type (aside from their bound equipment).

You could look at a sort of compromise between the two concepts: maybe the FIRST variant that you get when you buy an ability is based on that unit's seeds. And maybe RE-BUYING to get a different variant is very expensive. I kind of like that.

Okay, well. I wonder how expensive it would need to be -- but, in any case, I like that solution and I'm gonna roll with it, and we can work on balancing it later.

Now, we need to seriously look at what it means for abilities to have 'variants'. How much do these abilities vary. Do we hard-code all of the variants in? Maybe there's two 'levels' of variance, or two kinds of variance:

'Linear variance,' where we talk about abilities becoming strictly more or less powerful (varying things like their COSTS, their DAMAGE, how long their STATUS EFFECTS LAST, how hard they are to CURE, etc. Chance to crit.).

'Non-linear variance,' where we talk about abilities gaining different PROPERTIES. Inflicting different status changes.

The non-linear variance would need to be hard-coded in, probably including a different ability name. The linear variance might be more-or-less completely randomized within a set limit.

The linear variance would NEED to balanced, somehow, such as by having seeds be balanced against each other (???).

The non-linear variance could be completely random. Because variations that are non-linear aren't strictly 'better' or 'worse' than other variations, there's no need to balance them. You just get a random variation.

So, for instance, when a unit 'buys' Slap...

Its damage amount is somewhat randomized.

Its crit-chance is somewhat randomized? (Is that a thing we can do? I never considered that before. I'm not sure that our current mechanisms accommodate abilities having different crit-chances. We can fix this by making the crit-chance algorithm overridable).

Its MP cost is somewhat randomized.

It's AP cost could be somewhat randomized.

And if some of these have a high chance to go UP, then others consequently must have a high chance to go DOWN.

If attack power and / or crit chance is likely to go UP, then MP cost and / or AP cost are likely to go UP as well. But there would still be randomization even within these figures, so it's possible that you COULD get a very good variation, although it's less-likely because of how we're using these seeds against one another.

So, basically, you would need to mark certain attributes as 'favorable' and others as 'disfavorable'.

Does the object which 'spawns' random variances of an ability need to be the same object that's used in combat (the actual Ability)? It almost seems like this shouldn't be the case. Almost like it COULDN'T be the case, because the non-linear variants would need to each be their own class -- so we'd need some class which could represent the ability AS A WHOLE. And maybe THAT class spawns the variants.

We need another class for this. We need some kind of 'meta ability' or 'master ability' or something along those lines whose job it is to describe the ability in BASIC terms and spawn instances of randomized variants of that ability.

I feel like it's important, when talking about 'gacha abilities' and randomness, that I tighten up some of the verbage: I don't think that what units have could strictly be described as a 'seed'. Although it is randomly generated, it does not, itself, DETERMINE what ability that unit is going to get when it buys a new ability.

Instead, that 'seed' is then run against some degree of randomness. It's more like an augment or a factor or multiplier or whatever. It's a value that's used as the part of another random equation.

One thing about this design is that it allows us to disassociate 'abilities' and 'meta abilities' or 'master abilities' or 'class abilities' or whatever you wanna call it. It means that the 'UnitClass' object can contain these META ABILITIES, and the Unit doesn't really need to worry about these MetaAbilities at all.

Instead, the Unit can just have an essentially loose list of abilities. Maybe each Unit has three ability lists. They would actually need 6 ability lists:

'learned_primary_abilities'
'learned_secondary_abilities'
'learned_tertiary_abilities'
'equipped_primary_abilities'
'equipped_secondary_abilities'
'equipped_tertiary_abilities'

Then, they would also need a value representing the limit of how many abilities they can have equipped at a time:

'primary_ability_limit'
'secondary_ability_limit'
'tertiary_ability_limit'

Units also need a reference to their class for the purpose of when they want to buy new abilities and for when the player is checking their 'status' page:

'primary_class'
'secondary_class'
'tertiary_class'

Before we end the stream, I want to consider that, perhaps, we should make the 'abilities' aspect of a Unit a bit less flat. Maybe create some kind of 'personal_class' object which contains things like:

A reference to the master class.
The list of currently-known abilities for that class.
The list of currently-equipped abilities for that class.

That way, they're not all just floating around attached directly to the Unit.

I feel like that kind of solves an non-existant problem. How does that really serve me?

Having all of these loose attributes does look kind of sloppy. Maybe it would make sense to divide them up into their own objects.

So, let's look at the new classes that we're going to need to fully-implement our current vision for the Ability system:

MetaClass: contains all of the MetaAbilities associated with this class.

MetaAbilities: objects which represent the totality of a unit's ability as it belongs to their class. The primary purpose of this class is to DESCRIBE and to SPAWN abilities conforming to this design. It contains methods for generating the randomized variations of this meta-ability.

PersonalClass (name-in-progress): Would belong directly to a Unit and would contain a reference to the associated MetaClass. It contains all of the abilities that the owning Unit has learned from this class, and it contains the limitations of how many abilities can be currently equipped from this class -- and, of course, it has the equipped abilities. Lots of attributes, not a whole lot of methods. Really more of a data structure.

UnitAbility: The actual instance of an ability to be used by the unit in combat. Originally spawned from a MetaAbility and it belongs to a 'PersonalClass'. It has a lot of randomized attributes and belongs to a particular random 'non-linear variance' of a MetaAbility.

What's a better name for a sort of 'unit-class instance' than 'PersonalClass'? Maybe UnitClass. We have MetaAbilities and UnitAbilities. Maybe we have MetaClass and UnitClass.

So, on Wednesday, I feel like we need to put more work into hammering out this 'ability' system. We need to look at the architecture of MetaClasses as well as MetaAbilities. We need to create a working mock-up of a MetaAbility which can randomly spawn linear and non-linear variations into the ability list of UnitClasses.

The complicated part is going to be the MetaAbilities. In fact, I feel like the 'Meta Class' is pretty much just a data structure that organizes the MetaAbilities into tiers. The MetaAbility is going to be rich with attributes and methods for defining the spawning-behavior when a unit learns a randomized variation of that MetaAbility. So, we'll make a mock-up for 'Slap' which allows a unit to learn 'Slap' and get a slightly different slap every time.


06/26/19

Today, I want to start mocking up our game's Ability system, where UnitAbilities are organized into MetaAbilities, and MetaAbilities are organized into MetaClasses.

Before we get started with that, let's look at how much we've broken our Units.

HP, MP (and, in our case, LP) are interesting attributes in JRPGs, because they're resources that are meant to be continuously consumed and restored.

So, when you think about something like 'ATK', it basically has two associated values:

It's 'default' or 'base' value, which is what shows up on your character 'status' screen between fights. This value raises as your character levels up.

And it also has a 'current' or 'augmented' value, which is representative of how much ATK your unit has ON THIS TURN IN BATTLE, which may be different from its base ATK due to the results of some status changes -- buffs or nerfs.

But HP and MP aren't this same way. They do have BOTH of those attributes: a 'base' value and an 'augmented' value (such as some status change which temporary lowers a unit's max HP or maybe raises it), but they also have ANOTHER value, which is their CURRENT HP. So, the MAX value is a base value and THAT can be augmented, but there's also a CURRENT value which represents how 'full' the HP or MP is. ATK, DEF, etc., don't have that.

If I want to unify all of the unit attributes into some kind of class which has .base and .aug attributes, we need to look at CURRENT HP and CURRENT MP as their own, SEPARATE values. Because CURRENT HP can ALSO be augmented. So, really, what we're looking at are values which always have a BASE VALUE and an AUGMENTED value -- because, in a game with such an emphasis on 'status changes' (hence the 'Dynamic Rule System'), we're going to see attributes being augmented a lot. I think it's only natural to build this directly into our architecture.

I think we need another layer of classes? We talked about how Units should have ability names which reflect the THEMES of that unit, even if the actual affect of the ability doesn't change. For instance, what one class calls 'Slap' another class might call 'Punch' or 'Shoot' or whatever. Just to better fit the GRAPHICAL or NARRATIVE theme of that class. So, how are we gonna break this up?

Considering that only (?) the NAMES of the abilities and classes are changing, perhaps these could just be aliases that are built into the Unit class. Like, they take a MetaAbility and they rebind its name to something else.

But the downside of this would be that we really COULDN'T add unit-specific abilities even if we wanted to, and I kind of liked the idea that Panders brought up a long time ago of maybe having one or two unique abilities per unit. So it's almost like... we need a MetaClass to extend another MetaClass.

And then, when a MetaAbility is learned... it could intercept the newly born ability and change its name and description or whatever?

Okay, that works. So, we don't NEED a new type of object. We just need for the unit-specific MetaClasses to inherit from some base MetaClass.

Leaders don't need classes or anything. Although, it stands to reason that they should be able to learn new abilities and stuff? But let's not worry about that right now. We can worry about that mock-up or 8 or so. I think that mock-up is probably going to be focused on GROWTH. Unit growth. Once we have a feel for unit growth and such, we can start worrying about the Leader growth. That's really a secondary concern.

So, for now, let's say that Leaders DON'T need classes. They just have abilities and such that are INHERENT to them.

In a future episode, we need to examine how much like units we really want leaders to be. For now, let's just leave them as a very basic structure whose AP is consumed by their team. They're basically just representative of a 'party' and a shared AP pool.

I'm going to rewrite the code, right now, in advance, for determining critical-hit chance. We want for this to be more modular, so that different abilities can override the equation for critical-hit chance.

I think we broke something with the Dynamic Rule System, because Dynamic Events take a target and an attribute name. But now we've got layers to this shit. Now, the 'target' would be an attribute (like HP) and the attr_name would be 'base_val' or 'aug_val'.

That's super duper ugly. Is there any way we can fix this? Not to my knowledge, right away.

The thing that you COULD do is just to flatten out the Unit class and give them attributes like:

some_unit.base_hp

Rather than

some_unit.hp.base_val

Maybe that just makes more sense because of the way that the DynamicRuleSystem is engineered. I wanted to move to

some_unit.hp.base_val

as a way to communicate, ARCHITECTURALLY, the way that unit's attribute values change over the course of a battle. By flattening it out, we lose that sense of structure that's congruent with the way that battles actually play out.

But it could just be a sacrifice that's worth making to keep the DynamicRuleSystem simple (or RELATIVELY SIMPLE).

The thing is, we could update the DynamicRuleSystem to understand 'base_val' and 'aug_val', but there are attributes that are SUBJECT to the DRS which are not UNIT attributes. Like, when a Rule's triggered-counter updates. It doesn't need 'base_val' and 'aug_val', because it's not an attribute of a unit. So, because not all DRS-subject attributes belong to units, it doesn't really make any sense to impart this 'base_val' and 'aug_value' sub-attribute thing into it. So maybe we should just flatten it out.

But the thing -- there's an advantage to having this 'base_val' and 'aug_val' structure to our unit attributes, because we could see, at a glance, which unit attributes have been augmented, for instance.

On the other-other hand, unit attributes are FIXED. They're not going to be dynamically added and removed in battle -- that's what we hve 'tags' for -- so it's not like we're ever going to have more than HP, MP, LP, ATK, DEF, SKL, and PRY to deal with. So in that sense, it's very understandable to flatten things out.

It makes THE MOST SENSE, FOR NOW, TO FLATTEN OUT THE UNIT ATTRIBUTES. We can worry about adding more depth later if we really want to.

So, on Monday, let's work backwards: we want to get a working battle scenario FIRST, where Son of Dixxucker is Slapping Other Son of Dixxucker. Then, we can start looking at organizing 'Slap' into a MetaAbility, and then organize that MetaAbility into a MetaClass.

1.) Get Slap working again.
2.) Organize Slap into a MetaAbility.
3.) Organize the MetaAbility into a MetaClass.

Units still need 'Dynamic Rule' slots.



07/01/19

So, we ported Slap over to the new Unit mechanisms. But now we need to start asking some pretty interesting questions, because we're going to be trying to organize 'Slap,' the UnitAbility, into some kind of MetaAbility.

So, let's review what the purpose of the MetaAbilities really are:

MetaAbilities are integral to the process of LEARNING new abilities. That's what they really are. Once an Ability is LEARNED, the MetaAbility really has no importance.

So, what we're looking at is a mechanism where a unit wants to learn a new ability and the MetaAbility handles that transaction: it takes some kind of currency and gives the unit a UnitAbility.

Perhaps, then, the most integral method of a MetaAbility will be something like "learn" or "be learned by," or maybe the unit, itself, has a 'learn' method that takes a MetaAbility as an argument.

So, I think that Units should have a 'Learn' method which takes a MetaAbility as an argument. That being the case, the MetaClass -- well, no. I think it probably makes more sense, from an architectural standpoint, to have the MetaAbility have some kind of 'be_learned_by' method, because it's in that method that the MetaAbility sort of contains its logic for deciding which version of the Ability to give the unit as well as how to randomize that ability's attributes.

Let's just start coding and see what happens.

We have our meta-ability. Now let's talk about... what we call... 'linear variance'. In other words, we can get some Slaps that are better than other slaps.

So, for something like 'Slap,' we can play with the DAMAGE MULTIPLIER, we can play with the COSTS.

So, the MetaAbility handles the linear variance when the UnitAbility is spawned, right?

But why? That seems like an unnecessary extra step, because the UnitAbility, itself, knows its 'owner' upon instantiation. That being the case, shouldn't it be able to provide its own linear variance? Is there any reason it shouldn't?

I wanna say that there is NO REASON to rely on the MetaAbility to handle the LINEAR variation. So let's say that the responsibility of the MetaAbility is to handle the NON-LINEAR variation exclusively.

When you instantiate a UnitAbility, it can handle its own linear variation.

How do you get a random number between .5 and 2?

Ending our game-dev stream for today, we got our first MetaAbility working, and it seems to be behaving correctly. Now, the UnitAbilities, upon instantiation, handle their own 'linear variance,' which is to say that they examine their new owner and use the owner's attributes to decide, within some amount of randomness, what sorts of attributes they should have.

The MetaAbility, Slap, has a method, "get_unit_ability_for," which can return a UnitAbility based on the attributes of the UnitClass that its given as an argument. So, on Wednesday's stream, we should get some non-linear variance working for the Slap MetaAbility, which means that we can not only get different STRENGTHS of slaps, but also different TYPES of slaps. So, we can program in a slap which inflicts poison or a slap which has a chance to take a unit's turn or something like that.

After that, I'm surprisingly well-satisfied with where we're at insofar as architecting the Ability system of our game. I feel like it's where it needs to be in terms of sensibility and stability. It works. It's simple. It's dynamic. It's everything that I want it to be, right now.

So, on Wednesday, it's very likely that we'll start to look into designing these 'MetaClasses,' at which point we can pretty much start designing mock-up unit types and get a real test battle going.

Call me optimistic, but I think that, by the end of our Thursday stream, this week, we should have our first real test battle going -- except that we probably need some kind of mechanism to manage the turn-taking and stuff.

Let me dial it back: by the end of NEXT week, we will DEFINITELY have a fully-working and playable battle.


07/03/19

Today, we're going to start seriously looking at 'MetaClasses' and maybe even designing some mock-up unit-types that are more suited to a real test battle than our 'Dixxucker' unit-type, which has just been a placeholder.

So, first, let's design a real MetaClass for Dixxucker that we can use to at least demonstrate the architecture of these MetaClasses. I feel like these MetaClass objects are going to be very simple -- at least for now.

NOTE: I feel like there should be no cross-over in Abilities between classes.

We made some really awesome progress, today, in the internal architecture of the ability and class system. That means that, next time, on Thursday, we can really knuckle down and start creating some mock-up classes and units so that we can actually have a real, working test battle.

To make the design process easier during this mock-up phase, we've decided to use a battle loosely based on Pokemon: two leaders, Ash and Gary, square off using two teams of four Pokemon. So, we need to design a few classes for these Pokemon to use, each with some number of abilities.

I think... we should look at ABILITY TIERS after we have a fully-working battle. Once we've looked at ability tiers, we can start making even thinking about character growth -- but, really, the ability-tiers are the main issue. We'll incorporate a tier-check during UnitClass.learn_ability .

That'll be tomorrow!


07/04/19

I was thinking, today, in the shower, that it would make sense for us to create a new universal method for all UnitAbilities called "linear_variate," which would always be called upon instantiation and which would exclusively handle the assigning of attributes to that class which fall under the 'linear variation' of that ability.

In other words, when you buy an ability in our game, you get a randomized ability -- it's the game's 'gacha' element. First, during the randomization process, we go through the 'non-linear variation.' This refers to WHICH FAMILY OF ABILITY you end up with.

So, if you buy Slap, you might get a Heavy Slap (which has a chance to stun), or you might get a Sweaty Slap (which has a chance to poison). You might get a Cold Slap, which does 'cold' damage. Something like that. That's the non-linear variation of slap. It's non-linear because all of those slaps are considered equally 'good,' but they're just different.

After we decide WHICH slap you're going to get, that slap goes through a Linear Variation process, which randomized the attributes of that slap, which may make it better or worse. That's the 'linear' variation, because the attributes are just randomly going up and down.

Previously, we'd decided to handle the linear variation within the __init__ method, because that's pretty much what it's for. The whole point of __init__ is to set up the instance and assign attributes, and so it makes sense to include the algorithms for linear variation there.

The reason that I want to spin it off into its own method is because I want it to be clear to any developer looking through the code what these equations are really all about. I think that it makes sense to separate these from the standard __init__ fare because we're not JUST setting up the class; we're implementing an actual game mechanic whose entire purpose it is to randomize certain attributes -- BUT ONLY those certain attributes. So, if we spin off into a linear_variation method, the developer can quickly see which attributes are affected by linear variation on that ability.

We're getting to the point in our mock-up where it's becoming (but not entirely) important to think about actual equations for our game. Of course, this is still a VERY EARLY mock-up phase and these equations are subject to change entirely, but we need to start at least considering how things like damage-calculation are going to be handled.

We talked about how we want the DEFENSE ATTRIBUTE to have a greater effect on low-damage abilities.

Should this be something universal? I would argue... no.

In many ways, it definitely makes sense for the damage calculation between DAMAGE and DEF to be universal. Otherwise, you don't really know what having higher defense means.

On the other hand, if you put the damage calculation entirely into the hands of the individual abilities, you can do things like have certain attacks IGNORE defense. Or diminish the effectiveness of defense. Or maybe, if the attack is glancing, maybe it MULTIPLIES the effectiveness of defense.

That makes sense to me, but, again, if we don't have a universal equation for this sort of thing, what does the player really understand about 'defense.' What does it mean to have higher 'defense.' It just means, at that point, that you're likely to take less damage from most attacks.

In a game as dynamic and flexible as ours, there comes a time for a LOT of consideration when you're talking about balancing different classes, abilities, and units against each other. We've created an engine that I'm SUPER proud of, where we have a lot of freedom for how these abilities are conceived. We could create some really awesome, highly varied abilities -- highly tactical abilities -- with relative ease because of how we've designed things.

But with that much freedom comes a lot of responsibility insofar as designing these abilities and their affects. I think -- I think my mistake is that I'm jumping in too fast. I think that we were on the right track before with 'Slap.' We need a Slap because we need a sort of vanilla ability to act as a baseline for all other abilities.

We need a sense for what damage is 'average'. What damage calculation-type is 'average'. What critical-hit chance calculation-type is 'average'. Once we know how much damage an average attack ability does, and we know how much MP an average attack ability costs, we can start to look at how to balance other abilities against that. For instance, we could start talking about abilities that do more damage but cost more MP. We could start talking about abilities which do less damage but have a chance to afflict. We can talk about abilities which do NORMAL damage AND have a chance to afflict but which come at a higher cost.

So, yeah, this isn't as intimidating as it was starting to appear; what we need is a baseline to work from so that we have an understanding of where to go with future abilities.

So here's what I'm going to do. Pikachu's tertiary class is 'Normal'. Right now, we're designing his primary class, 'Electric.' Let's just make sure that Electric is functional with its placeholders, for now, and we'll go work on Normal and give IT Slap. Then we can start building from there.

I guess what I'm saying is that, in order for us to know what abilities and classes and units MAKE SENSE within the context of our game, we absolutely need to have a baseline to balance other things against.

So we're gonna need to have a baseline Ability. We're gonna need to have a baseline class. We're gonna need to have a baseline Unit. We're talking about a generic, vanilla, median, average baseline to work from.

For now, I'm stepping back from the idea of helper classes for marrying objects together. What classes do I currently have which NEED to be married?

Leaders <-> Units

Units <-> Abilities

Units <-> UnitClass

What we accomplished, today, was mostly to realize why we needed a Version 7 mock-up and we're transitioning into that direction.

We're making big changes to the way that we handle ability effectiveness and to how we're laying out our mock-up classes and abilities by spinning them off into their own directories and files.

The goal for the Version 7 mock-up is to create a fully-working example battle with some example units, leaders, classes, and abilities based on Pokemon. It's going to be the most creatively indepth design process so far. We're going to dedicate some real consideration to creating interesting and tactical abilities even though, almost certainly, none of these exact classes or units are going to make it into our final game. But, this is an important step so that we can see the weaknesses of our approach to designing the game -- which we already have, today.

The weakness that we came across, today, is that we desperately need to set some baselines so that we can make informed decisions about what kinds of abilities, classes, and units we're designing. So, our real goal, starting off in Version 7, is to create some baselines for us to use to develop the rest of the mock-up around. Once we have those baselines established, I expect that it'll be simpler to go back and create more abilities and more classes and more units. But we can't do that until we have this baseline set.


07/08/19

Let's start today by examining the architecture of our packages.

We have a 'classes' directory, and it contains directories for each class.

Each class's directory contains .py files which represent each ability of that class, including all of its permutations.

SIDE-NOTE: before we get any further and I forget to mention this, I was thinking about 'damage' equations, last night, and how they should factor in ATK vs DEF. I think what I want to do is to make it very simple:

A 'baseline' attack, in the game, should do base damage EQUAL TO that unit's ATK attribute. I want to think of 'ATK' as sort of representing BASE DAMAGE in the game.

Then, DEF would subtract directly from that damage. That's all it is. Very simple.

Here's how it would look:

If Attacker has 20 ATK power and Defender has 5 DEF, then a baseline attack would deal 15 damage.

What's cool about this is that we could have an attack like 'triple punch,' which would do HALF base damage but THREE TIMES. So, the base damage of triple-punch could be thought of as dealing 30 damage. HOWEVER.

If you subtract 5 DEF from each of those three attacks, the total damage is 15.

So, against an opponent who has 5 DEF, the damage of a SINGLE ATTACK which does 20 or a TRIPLE ATTACK which does 30, the final damage is the same.

On the other hand, let's say that the opponent has 7 DEF.

Now, BIG PUNCH (20 base damage) does 13 damage.

BUT, TRIPLE PUNCH (30 base damage) does 9 damage.

In our final example, let's say that Defender has 3 DEF.

BIG PUNCH now does 17 damage.

TRIPLE PUNCH now does 21 damage.

So, what I'm getting at is that this very simple equation for DEF can have very interesting results based on how much damage is being done in a single attack and how many attacks there are.

Higher defense will have a greater impact on multi-hit attacks than it will on single-hit attacks. Or, to put it another way -- if you're an attacker, it would make sense to use multi-hit attacks against opponents that have low DEF and single-hit attacks against opponents which have high DEF. That's kind of cool to me.

We've got a directory for classes which contains directories for each class, and each class directory contains a separate .py file for each ability.

Right now, we have one class, "normal", which has one metaability "slap".

I'm kind of frustrated that MetaAbilities can't have the same name as UnitAbilities. For instance, I like the idea of 'Slap' being a MetaAbility, because there can be several different kinds of slaps, but I would also like for the most basic slap to just be called 'Slap'.

I could implement this just by having the Python classname for the UnitAbility be something like,

"UnitSlap" (which sounds kind of saucy)

but have that class's ability_name attribute just be "Slap".

That fulfills the same purpose. Or, maybe we could just call the MetaAbility 'Slap' MetaSlap instead.

Before the stream, I was thinking about what sorts of non-linear variation we could possibly implement for abilities in the game. The idea has been to make the non-linear variation of abilities return a version of each MetaAbility which isn't strictly better-or-worse than other variations, but rather different.

The problem with this, abstractly speaking, is that I also kind of feel like UnitAbilities that fall under a single MetaAbility should be at least tactically SIMILAR. You should probably use the Ability more-or-less the same regardless of which version you get, which sort of limits what kinds of variation we can have within a single MetaAbility.

For instance, we were talking, before, about having a single MetaAbility with three UnitAbilities under its umbrella:

One which does 100% ATK power.

One which does 50% ATK and 50% status change.

One which does 20% ATK and 80% status change.

Those could be thought of as variations of a single ability, but what makes them distinct is how different they are to use, tactically. It's almost like they're three different abilities which would all belong to different classes.

One is for an attacker. One is for a mix of attacker and inflicter. And once is pretty much really meant for afflicters.

Of course, we just came up with that ability as a quick example of how to implement the MetaAbility system, but it got me thinking about what sorts of similarities and differences really make sense among UnitAbilities that are all shared under a single MetaAbility.

So, look at 'MetaSlap'. Right now, I have two different UnitAbilities underneath it: 'Slap' and 'Double Slap'. Both of these are simple damage-dealing abilities, but one lumps all of the damage into a single attack and the other splits the damage over two attacks -- so the former will be more effective against units with higher DEF and the latter will be more effective against units with LOWER DEF.

And yet, these are still both usable pretty much the same way in the same situations by the same character. It's just that there will be a slightly different result based on which type of Slap this particular got at random.

Okay, so that makes sense to me, but here's where I'm going with this proposal: considering that the ability that you get when you buy out of a MetaAbility is random to some extent, WOULD IT MAKE SENSE for there to be a rare chance that you just get an ability which could be considered somewhat SUPERIOR.

Because, up to this point, we've broken ability variation into two categories: LINEAR, which just randomly makes an ability slightly better or slightly worse, but with the same effect. And NON-LINEAR, which gives you an entirely different ability, with a similar use but perhaps a slightly different effect, but which would be considered to be approximately equally 'good'.

What if we included a rare chance to get a non-linear variation (an ability with a similar use but a slightly different effect) which was just BETTER. What if we included an attack called 'Dick Slap' which was just like a normal Slap except that it has a chance to inflict poison.

There's a problem with this right away, and that's that it sort of invalidates the tactical need for both Slap and Double Slap. Considering the gacha element of the game, a player might just keep buying Slap over and over until they get Dick Slap, and then they'd never have any need for Slap or Double Slap.

But is that necessarily a bad thing? Because buying abilities is going to cost some kind of currency (EXP or whatever) which could also be used to invest into other things. So, if the player really wants this rare but slightly superior version of an ability, they might need to invest a lot of points into getting it which they could otherwise just spend on something more productive. So, maybe it's fine to reward them for taking that chance -- or to reward the rare roll where a unit gets Dick Slap as their first MetaSlap.

I guess, for now, what I'm going to say is that we can consider RARENESS to be a COST of an ability when we're balancing that ability -- but we'd have to be careful. These rare, "superior" non-linear variations would need to be superior only by a small margin so that players can't just farm these rare gachas and create super-powered units.

Dick Slap is a good example of an ability which I think could be balanced effectively against its rareness. Because, maybe it does the same damage as Slap, which is very common, but it has a 10% chance of inflicting short-term poison. Yeah, that's the version you would PREFER. But is it really worth buying MetaSlap over and over to get it? Is a player who's using Slap at a significant disadvantage against a player who has Dick Slap. Not really. I feel like Dick Slap is only a little bit better than Slap. I don't think it's going to be a deciding factor in a match, but it's still maybe a fun reward and adds some interest to the gacha.

Dixx points out that this could be a barrier to new players in a competitive game. If we have players who have been grinding for a very long time, they would likely have access to superior abilities that may have been more rare. I think that this would be a small price to pay to add excitement to the gacha element as long as we maintain that these 'superior abilities' are only VERY, VERY SLIGHTLY SUPERIOR.

SIDE NOTE:

Should abilities print messages BEFORE or AFTER running update_w_rules?

I argue that it would be BEFORE. This is how you would expect a Pokemon to animate before we know whether its attack was actually effective or not.

So basically, as we write these messages to be printed, we shouldn't assume anything about the attack actually WORKING. Language-wise, as long as our game is text-based, we need to write these descriptor messages very agnostically insofar as the ability's actually effectiveness considering our game's Dynamic Rule System.

SIDE NOTE:

We've talked about this before, but I feel like the base AP for a leader unit should be 10, and I want for unit-swapping to cost 3. So, where does the leave the rest of our abilities, tactically-speaking?

With 10 AP, in a single turn, a leader can hypothetically swap units 3 times AND use an ability which costs 1 AP.

What's interesting about that is that it also means that a leader can use an ability which costs 1 AP ten times.

So, it's almost like... no ability in the game should cost 1AP?

I guess I don't see why 1AP abilities shouldn't exist? I mean, maybe it heals you just a tiny, itty-bitty bit? Maybe it does an itty-bitty bit of damage? Fine. But maybe they're kind of rare.

Tactically-speaking, let's return to the scenario that I often lean on when considering unit-swapping costs:

When a turn ends, whatever unit is in the ring will be the most vulnerable to damage. So, you have an incentive to swap in a unit right before the end of your turn.

That also means that when you get your NEXT turn, this unit that you swapped in is going to be the first unit whose abilities you have access to.

If you swap in a unit SOLELY for it to take damage, you would then hypothetically need to swap it OUT at the start of your next turn.

So, you would have 4 AP remaining to use abilities on that turn:

Swap out, use ability, swap in.

Because we don't strictly want to make it EASY for players to swap tanks in and out with no other tactical concerns, we have to believe that having this 4 AP for your turn is a pretty shitty amount to have.

Tell me if you agree with this, from a GAME DESIGN PERSPECTIVE: SLAP is the most basic of abilities because it does 1xATK damage.

From that baseline, we can consider different COSTS for moves that are BETTER, different costs for moves that are WORSE. We can subtract DAMAGE to get OTHER EFFECTS and consider them around the SAME effectiveness as Slap.

I think it stands to reason that, in a game about lowering your opponent's HP to zero, a simple move which just does basic damage based on your unit's attributes is probably a good baseline for 'normal' cost.

Kenny brings up MP, which gives me a chance to reiterate that NOT ALL MOVES COST MP. At least, the way that I imagined it, AP is a secondary cost meant for abilities which would be MORE effective than Slap (baseline ability).

If you're a wizard in an RPG, it's not unusual for you to have abilities that are MORE EFFECTIVE AT DOING DAMAGE (maybe even to a group) than, say, a Warrior. Both Warrior and Wizard are classes primarily focused on dealing direct HP damage, but Wizards are typically better at it, but the difference is that wizards consume MP, so they can't do it as consistently as warriors can. That's sort of how I imagine MP, in our game: some attacks consume it. When you're out of it, you can't use those attacks any more.

I guess here's what I'm asking:

Should 'Slap,' our most basic of abilities in the game, cost 2AP, 3AP, or 4AP. Or more.

Well let's consider a hypothetical scenario, which is probably going to be pretty common in our game: a turn starts and you already have the unit that you want in the ring. And you have no need to change that unit. So, you have 10 AP and you're gonna use it all with this single unit.

So, if Slap costs 2 AP, you can use it 5 times. We haven't really talked about HP vs ATK values on our base units. It also depends on, tactically, how long we want for a base unit to survive. In Pokemon, for instance, units typically die in or two turns.

What we're talking about, here, is really how much strategic flexibility we want to give a team in a single turn. This is kind of a deep subject.

We're talking about strategic flexibility within a single turn. When you swap units, you have access to entirely new abilities. When you swap units, you are protecting the last unit from damage and making a new unit vulnerable to damage.

We're talking about how much YOU, as a player, can GET DONE before your opponent can act.

Now, in Pokemon, you can always only ever get ONE thing done before your opponent can act, and that's very fair.

In our game, you can get more than one thing done before your opponent can even act. So, when we're considering fairness, we need to consider things like synergy and combinations within a single turn. Like, if you're going to make the case for a game where you can take multiple actions within a single turn, we're talking about SETTING THINGS UP and FOLLOWING THROUGH before an opponent can act. How much of that do we really want for a player to be able to do.

A party is 4 units big, and only one of those units is in the 'ring' or 'front row' at a time. Only units in the ring or front row can act and 90% of abilities will only target the unit in the ring / front row (although, unlike Pokemon, units in the back row may be subject to some small aggression).

Another game that I love where you can do tons of shit on a single turn is Disgaea. I grew up with Final Fantasy Tactics where each 'turn' is only one unit long. I was flabbergasted, at first, when I played Disgaea and found that, despite its core gameplay seeming very similar (tile-based tactics), you can take actions with ALL of your party members before your opponent can do anything -- but then, when it's their turn, they can do tons of shit before you can do anything.

And the difference between Disgaea and Final Fantasy Tactics, in that respect, is that there's a lot more TEAMWORK in Disgaea than in Final Fantasy Tactics. You use all of your units to accomplish a single goal.

So, in our game, you can do a few things before your opponent can do anything. What sorts of things are we talking about, here?

Well, you can: swap a healer in, get a heal, then swap the healer out.

Attack multiple times with an aggressive unit (but, maybe at the cost of not being able to swap in a tank -- risk reward).

Inflict a status change and then swap in a unit that can attack the opponent with an ability that capitalizes on that status change (cover opponent in oil, then swap in a unit which can attack with fire).

So, from these examples that I'm dreaming up, it seems like we're kind of hitting a pattern:

swap once, use two abilities
swap twice, use one ability
don't swap at all, use three abilities

You end your turn with an afflicter on the battlefield, and the opponent fails to kill that afflicter on their turn.

When it's your turn, you can afflict with oil, swap out, and then attack with fire all in a single turn.

That's your reward for the risk of leaving the afflicter in the ring between turns.

Alternatively, you could play it safer but over more turns (so you're taking more damage):

Swap out tank, afflict with oil, swap in tank.

Swap out tank, attack with fire, swap in tank.

In these examples, the tank never gets to act. He's just there to absord attacks for the afflicter and the fire-attacker.

So, in the case of slap -- it being our game's most basic ability. Supposing we have 10 AP each turn and swapping costs 3, slap should cost 3?

An ability that's not that expensive (it's not amazing) and it's not that cheap (it's fully effective)... could cost 3. Then you have 1AP remaining to either WASTE (as a punishment for swapping twice) or to spend on some super minor ability (a tiny heal or something, or tiny poke, or tiny buff).

If swapping costs 3, then you could look at abilities that cost '3' as a way to sort of PUNISH double-swapping, to DISCOURAGE double-swapping, to make it harder to play in such a way that you're always having one unit take damage and that's all that it does.

Because if you swap ONCE per turn, you can use two abilities that cost 3 or you can use one that costs 3 and one that costs 4.

If swapping costs '3,' then '3' is that magic number for cost that means you're probably gonna have to waste 1AP in the end, which sucks.

So, here's what we can probably say about AP costs:


'8' is a high-commitment ability because you can't swap at all and you could've used two 'normal' abilities, instead.
'6' is high-commitment. You can still swap, but you could have used two 'normal' abilities.
'5' would be an above-average ability. You can't use if you swap twice.
'3' is a unit swap
'3' or '4' is a normal, basic, but fully-fleshed-out ability
'2' is a soft or auxiliary ability
'1' is an ability that does practically nothing but better than wasting 1 at the end of your turn

Let's make a note about balancing AP costs: you can think about it in terms of "how many times can I swap and still use this ability?," but you also need to think in terms of, "how many abilities could I have used instead of using this ability for the same amount of AP?"

If Slap costs '3,' then a move that costs '6' would need to be more than twice as useful because it's not ONLY twice as expensive, but it's more of a COMMITMENT. It's less tactically flexible than using two abilities that cost 3. Because I can use one that costs 3 and then decide if I want to use another that costs 4, or two abilities that cost 1 and 2 -- breaking up your abilities gives you more flexibility. So an ability that costs 6 would need to be twice as useful or "good" as an ability that costs 3.

Next time, we need to finish implementing the 'costs' for Slap and we're going to create DoubleSlap and DickSlap.

07/10/19

New day, new design decisions to make. What are we gonna do about multi-hit moves that want to roll for crit more than once? I guess we could just call roll_for_effectiveness manually, right? I'm pretty sure that's a method of UnitAbility, so we would just call self.roll_for_effectiveness.

Comparing a move that hits once to a move that hits twice for the same cost, what should the raw damage calculation comparison be?

We've established that moves that hit ONCE are better against foes with HIGH DEF.

Moves that hit TWICE are better against foes with LOW def.

So, supposing that each type of attack has an advantage against different types of opponents, perhaps a 'double-slap' SHOULD do half as much damage per slap.

Let's run some example numbers:

Attacker's ATK is 20
Defender's DEF is 7.

Slap does 13 damage.

Double-slap does 6 damage.

That's less than half as much damage.

Defender's DEF is 3.

Slap does 17 damage.
Double-slap does 14 damage.

Slap still wins.

This is the fallacy. If double-slap does half as much damage per slap, the only way that it can do as much damage as Slap is if the opponent has 0 defense. So, we do need to find some magic-number to help us decide what the multiplier should be for multi-hit attacks to make them compare evenly with single-hit attacks.

I guess, in order to make this calculation, we need to decide on a 'baseline' comparison of ATK and DEF. One thing I've been discovering over the past week is that we need to decide on some 'baseline' values in order to effectively design skills, and this is no different. I don't know, yet, what the 'average' comparison would be between a given unit's ATK and DEF -- and, without knowing that, I can't really find that magic number for what attack multiplier would make multi-hits approximately even with single hits on a 'baseline' unit.

I'm gonna work out Steve's question, here:

Attacker has 20 ATK.
Defender has 7 DEF.

Double-slap does .75 * ATK per hit.

Slap does 13 damage.
Double-slap does 16 damage.

Defender has 3 DEF.

Slap does 17 damage.
Double-Slap does 24 damage.

I guess now is probably the time to start looking at baseline attribute values for a baseline Unit.

Units have what:
* HP
* LP
* MP
* ATK
* DEF
* SKL
* PRY

One thing we have to think about, when defining this baseline unit, is how many turns we want for them to be able to survive if they're on the front row and not being healed.

If you're under attack and you're NOT swapping the unit out and you're NOT healing them, then they shouldn't be able to survive for more than two turns.

We're talking about getting slapped. We're talking about a unit taking its own ATK power as raw damage 3 times in a turn.

If our baseline unit is going to die halfway through its second turn of being slapped, then its HP needs to follow this equation:

hp = (ATK - DEF) * 5
50 = (15  - 5)   * 5
100 = (30 - 10) * 5

Is DEF over-powered, mathematically, compared to ATK? Let's run some example numbers for Slap and Double-slap and see how their damage differs as we invest our points differently. My theory is that, if Defender invents an equal number of points into DEF as Attacker invests into ATK, Defender is getting the better deal.

Attacker has 30 ATK.
Defender has 10 DEF.

Slap does 20 damage.
Double-slap, with a multiplier of .66666~ per hit, does 20 damage.

Attacker has 35 ATK.
Defender has 15 DEF.

Slap does 20 damage.
Double-slap does 16 damage.

I'm not a mathematician, but this phenomena reflects any situation where you're comparing the SCALE of two values after adding the same AMOUNT to both.

2 is 200% as large as 1.
But as soon as you add 1 to both, you get 3 vs 2. 3 is only 150% as 2.

So, now that I've said it out loud, maybe here's a solution:

When you add the same amount to two different values, they always come closer in scale. So, if we want attack and defense to be balanced, perhaps the only thing to do is to have the baseline attack and defense values be exactly the same and re-examine our 'base damage' equation to account for this.

We seem to have two options: accept that DEF is over-powered and make it cost more, somehow. Or try to make DEF even with ATK, somehow.

Dixx points out that we could manually design 'soft caps' into our equations, which is a pretty popular way to solve problems like this. But I've always hated that approach in JRPGs. I feel like it just makes the equations overly complicated and unpredictable to the player unless they know, in advance, where the soft-caps are.

Jeefy points out that, if we want to BALANCE ATK against DEF, we could NERF DEF or BUFF ATK. I guess what I'm thinking, right away, is buffing ATK such that a 'baseline' ability has a multiplier greater than '1' when comparing ATK to DEF.

To be clear, the issue that we're talking about is that our current equation for damage -- our current understanding of how damage is calculated -- favors DEF when ATK and DEF are both given the same number of points on level-up.

SIDE-NOTE: aggressive attributes are ATK (used to calculate damage) and SKL (used to calculate which of the three effectiveness levels we get for our ability, "glancing", "normal", "critical").

Our equation for calculating raw damage, right now, for a baseline ability (like Slap), is this:

damage = ATK * 1 - DEF

So, in our current 'baseline' examples, a baseline unit has 30 ATK and 10 DEF.

So, slap does 20 damage.

The reason that we're using this simple equation (where we're just subtracting DEF from the raw damage in order to get the total damage) is so that multi-hits scale BETTER against opponents that have LOW DEF and WORSE against opponents that have high DEF. The goal is to have multi-hits have a separate tactical use compared to single-hits. Single-hits are more effective against units that have high def. Multi-hits are more-effective against units that have low def.

SIDE-NOTE: SKL and PRY are the analogues for a classic JRPG's "ACCURACY" vs "EVASION." Every JRPG has their own names for these values. In our game, it's "SKL" and "PRY". Skill is the aggressor's attribute to make their attacks more likely to land clean. PRY is the defender's attribute to make their opponent's attacks more likely to land 'off'.

Our problem is that, if our Attacker and Defender both invest all of their points into ATK and DEF respectively, and they level up the same number of times, there will come a point where the Attacker cannot harm the Defender -- where-as you might expect that, if they're both raising their attributes by the same amount, the defender would always be taking approximately the same damage.

The calculation between SKL and PRY has RNG in it. An aggressor with a set amount of SKL and a defender with a set amount of PRY will not always result in the same effectiveness when a given skill is used.

Dixx puts forward the idea of a 'tertiary stat' which augments how effective the DEF stat is -- a multiplier. And 'DEF' is just a value that's set in stone per unit. I don't know if that solves our problem.

In fact, when we decided to implement 'DEF,' that was sort of its idea: it's already a tertiary value.

So, my original idea was to have NO DEF in our game, similar to Final Fantasy Tactics, which I've always admired for the fact that it simplified its JRPG trappings by replacing DEF with 'more HP.' The question came up, in one of our early-on design streams, "what is the point of having DEF when you can just have more HP."

And I think it was Dixxucker who raised the idea that a DEF value could create an interesting sliding-scale when you're talking about how individual abilities 'overcome defense.'

And I liked that idea, and we settled on this notion that BIG, HEAVY, SINGLE-HIT ATTACKS would be better at getting 'over' DEF and smaller, multi-hit attacks would be more RAW damage but would have trouble conquering defense.

Therefore, if you observe that your opponent has lower-than-average defense, it would make more sense to use multi-hit attacks for their raw damage.

But if you observe that your opponent has higher-than-average defense, your multi-hits would have trouble cresting OVER that defense value, and so the best way to get damage for your money is to use an equal-costing single-hit attack.

So, basically, DEF is already sort of a tertiary or auxiliary attribute that augments your HP.

Dixx says, "Don't make 1 ATK = 1 DEF," and that's exactly what I'm talking about. I'm saying that one solution, which is the most attractive to me, right now, is to make the 'baseline ability,' Slap, deal some multiple of ATK greater than 1 on "normal" effectiveness.

So, right now, the baseline attack in the game -- which all other attacks are based around -- is Slap, and it does 1 * ATK for its raw damage, which means that, as dixx puts it, ATK = DEF.

So what if, for our most basic attack -- and all attacks that behave similarly -- we raise the mutliplier for how effective 'ATK' is at creating raw damage.

Let's just suppose -- and run some numbers, because I'm lazy and don't want to try to figure out, in an abstract sense, what the result would be without experimentation -- that a 'normal' effectiveness Slap calculates it damage with 1.5 * ATK. Let's see how that changes things. By extension, I guess Double Slap would do *1 damage.

Attacker has 30 ATK.
Defender has 10 DEF.

Slap now does 35 damage.
Double-slap now does 40 damage.

Attacker has 40 ATK.
Defender has 20 DEF.

Slap does 40 damage.
Double-slap does 40 damage.

To repeat: any time you have two different values and you add the same amount to them, the lower value is going to come closer to the higher value in terms of their respective scale.

So, because DEF is lower than ATK, if you add the same amount to both, DEF is going to always be getting closer to ATK in scale.

It seems to me that we need to make the default ATK and DEF the same value and then create an equation around that which would have our unit die in 5 slaps. We need to adjust the damage of slap and the amount of HP the unit has.

So let's re-examine our equation.

Our old equation was this:

hp = (ATK - DEF) * 5

hp = (damage) * 5

Where damage is some value that we can get from ATK and DEF being exactly the same. In our old equation, if a unit has the same value for ATK and DEF, he cannot damage himself with Slap; he takes 0 damage. Our goal, with this new equation, is to change that. Now, he has the same value for ATK and DEF, and, when he slaps himself, he dies in 5 slaps.

We're trying to design the stats for a 'basic' unit which we can base all other units off of. Other units might favor defense over offense. Other units might favor high HP over both. But, in order for us to decide what 'pros' and 'cons' each unit brings to the table, we need to define what a 'baseline, normal, run-of-the-mill, no exceptional advantages-or-disadvantages' unit looks like.

So, I'm theorizing that it would be for the best for an 'average' 'normal' unit to die in 5 'average' or 'normal' attacks. That means that they would die in a turn-and-a-half of being vulnerable. Meaning that, strategically, if you want for a unit to survive for more than a turn, you probably need to heal them or swap them out before a turn-and-a-half. That's where the number '5' comes from.

So, by my estimation, a 'basic' unit would need enough HP to survive 5 hits of our basic damage calculation.

Our attacker and defender are, at level 1, the same unit. We could talk about a unit 'slapping themselves.' So, our old equation was:

HP = (ATK - DEF) * 5

DEFENDER_HP = (AGGRESSOR_ATK - DEFENDER_DEF) * 5

Our game is going to have lots of different types of units with lots of different advantages and disadvantages.

In order to keep things balance, whenever a unit has a particular advantage in one area it would need to have a disadvantage in another area.

This is true of Abilities and Classes as well: whenever you GIVE SOMETHING to a unit / class / ability, you need to take something away.

Until we establish a 'baseline' for these sorts of ideas, we don't know what qualifies as an advantage or a disadvantage. We need some kind of generic object to represent a unit / class / ability which has no particular advantages or disadvantages so that we can design around these.

To answer Dixx's question about opponent generation in single-player, I figure that we'll be using a similar approach to Pokemon: opponent type at level 1, all their stats multiplied to whatever level they're supposed to be at. Supposing that they continued to invest their points in equal proportion to whatever respective scales they started with.

The idea is to figure out how much damage Slap should do. In order to understand how much damage slap should do, we need to understand how much HP a hypothetical opponent has. And in order to figure that out, we need to figure out how fast we want them to die (5 slaps) and how their def factors into this.

That's what we're stuck on.

I don't think we're going to be scaling anything about the opponents, in singleplayer, based on the player's attributes. That would be Elderscrolls-esque -- scaling opponents based on player. In our case, I always imagined it being more traditional: enemies in a certain area are a certain level, and their attributes are based on their 'base' attributes (but scaled up to their level), and the player has to be strong enough to survive in that area or go get stronger.

Tomorrow, in this timeslot, we need to examine in greater detail the equation for calculating raw damage in consideration of 'ATK' and 'DEF'. What is the most basic way to use those attributes of the attacker and defender respectively to calculate damage in such a way that it scales neatly to different levels and we get our expected behavior for the difference between 'mutli-hit' and 'single-hit' attacks.

Single-hits are supposed to do more damage to an opponent who has above-average DEF than a mutli-hit would.

Multi-hits are supposed to do more damage to an opponent who has below-average DEF than a single-hit would.

Therefore, an opponent who has exactly average defense should take the same damage from an attack that does a single-hit versus an attack that does a multi-hit.

Defender DEF+: single-hit more effective, multi-hit less effective
Defender DEF-: single-hit less effective, mutli-hit more effective
Defender DEF=: single-hits and multi-hits do the same damage

Considering this future equation, I believe that we need to have ATK and DEF be equivalent in value if we want for them to cost the same amount to level-up. If they aren't equivalent, we're going to see a problem of scale.

07/11/19

Last night, I was thinking about different equations that we could use for calculating damage to get the effect that we want and I didn't have a whole lot of luck. I feel like this is the sort of thing that's going to require quite a bit of thought -- but I did have one idea that I want to step through, here.

I had this idea where the ATK vs DEF calculation is the factor deciding 'bonus damage.' My gut says that this isn't going to be a fun way to calculate damage, but, based on my early estimations, it seems like it might be more effective than it first appears.

Let's say that a baseline unit has 25 HP and that Slap and Double Slap are supposed to do 5 damage supposing that the attacker and defender have the same value for their attack and defense.

So what if we did something like this:

final_damage = damage_constant_of_ability + (ATK - DEF)

In this example, 'Slap' would have a damage-constant of 5.

I can already see a problem, here, but let's follow-through with what I was thinking, anyway.

If the attacker has 1 more ATK than the defender has DEF, Slap now does 6 damage. If the Defender has 1 more DEF than the attacker has ATK, then Slap does 4 damage.

On the one hand, I feel like this is a pretty good incentive for players to raise their units' ATK and DEF. Because it makes both very strong. Equally strong, even.

The problem is that we start to see a situation where the BONUS DAMAGE dramatically outscales the DAMAGE CONSTANT. If a unit continuously pumps their ATK value at every level-up, they might have a damage bonus of 20 or whatever. At that point, the difference between Slap (5 damage constant) and poke (1 damage constant) is relatively little, but Poke only costs 1 AP, so it becomes a much more attractive option.

That's the problem with this 'bonus damage' idea.

My gut tells me that, whatever we do, it's going to need to rely on some MULTIPLIER. Hang on. I'm getting a Jimmy Neutron brain-blast.

Maybe the difference between ATK and DEF can create some kind of bonus as a multiplier -- not as a sum. I wonder if that would give us better Double-Slap against lower-defense opponents, like we want, but let's test it.

Let's say that Attacker has 15 ATK and Defender has 12 DEF.

So, we would need to find out, mathematically, what percentage higher 15 is over 12.

15 is 125% as big as 12. So, we could say that the 'damage constant' of Slap (5) gets a 25% increase.

Slap does 6.25 damage.

Double-slap does 2.5 base damage. So, double-slap does 6.25 damage.

So, I like this equation. It seems fair, it seems sensible. The problem with it is that it doesn't scale Slap differently to Double Slap depending on whether the opponent has 'low' or 'high' or 'average' DEF.

What I don't like about this is that, with no 'bonus damage' calculation -- no 'subtraction' -- we end up in situations where you would need to have insanely high ATK in order to, for instance, get double-damage on an opponent with moderately high DEF. But maybe that's for the best.

It seems weird to me that, an attacker with 20 ATK hitting a defender with 10 DEF would do 10 damage with Slap.

But, also, an attacker with 100 ATK hitting a defender with 50 DEF would also only do 10 damage with Slap.

I'm not sure that's a bad thing. You could argue that it just helps us keep our HP values in check. I mean, yeah, we could give units 300 HP instead of 25, but the effect is the same, right? If you pump twice as much points into ATK as your opponent put into defense, you're gonna do twice as much damage.

If we want for multi-hits to do more damage against low-defense opponents, we're GONNA NEED some kind of subtraction in our algorithm. Some kind of linear SOMETHING. Or, we could factor in some kind of multiplier for 'number of hits'.

Like, DEF has to create some kind of 'barrier' that an attack has to OVERCOME, you know what I mean? In order for HEAVIER ATTACKS to scale better over high defense than LIGHTER ATTACKS. We have to create some kind of threshold.

Like, we need one more layer. We get our RAW DAMAGE from the ability's damage-constant multiplied by the percentage difference between ATK and DEF. After we get our RAW DAMAGE, we need some sort of threshold layer for that damage to go up against. The threshold layer would also need to be based on the percentage difference between ATK and DEF, I feel like, but it's linear: it involves subtraction.

The threshold, I feel like, would almost certainly need to factor in the ability's damage constant...? To get a sense of scale...? Well, no, that hardly makes sense because the idea is that heavier-hitting attacks would be better at crossing the threshold.

If you have 100 ATK and I have 50 DEF, my DEF is 50% as big as your ATK. How can I make that into a sensible threshold that would allow heavier-hitting attacks to cross the threshold sooner than lighter-hitting attacks?

We could consider Dixx's suggestion of a 'tertiary attribute' that would help with these calculations? Like, what if it was based on Max HP. Like, there's some kind of additional bonus damage (this doesn't really help) based on what percentage of my total HP your raw damage would subtract. That would definitely favor heavier-hitting attacks -- but the problem is that we want to reward multi-hits against opponents that have low DEF. Reward them more than single hits.

Using 'Max HP' as a multiplier for damage taken sort of reminds me of Steamband, which is a game that we're already taking inspiration from insofar as the 'LP' system. But Steamband had these values called 'WP,' or 'Wound Points,' which worked fairly similarly to SaGa's LP or 'life points,' except that, when you took a hit, there was always a chance that you could lose WP, and the percentage of your max HP that was subtracted from that hit was multiplied by .5 to get the percentage chance of losing WP.

So, if you took half of your health in a single hit of damage, you would have, like, a 25% chance of losing WP. So, heavier hits were rewarded with a much higher chance to lose WP.

So maybe we could create some kind of 'bonus damage' system based on what percentage of your health you lost from a single hit. Multi-hits would have a higher damage-constant OVER-ALL (considering the number of hits), but no single hit would do as much of your HP as a heavy attack would, so the heavy attack would get a more substantial bonus?

But the problem with this, at least the way that I'm conceiving it, is that, as long as there is no linear threshold, the bonus damage from the multi-hits would necessary eventually add up to the bonus of the single-hit. I'm no mathematician, but I'm pretty sure that's how multiplication works.

Let's just say that attacks get bonus damage of their damage-constant times the percentage HP they removed from the opponent.

Our example equation is this, for total damage:

raw_damage = damage_constant * (ATK / DEF)
bonus_damage = raw_damage * (raw_damage / max_hp)
total_damage = raw_damage + bonus_damage 

So, let's look at an attacker with 10 ATK and a defender with 10 DEF and 25 HP.

raw_damage = 5 * (10 / 10)
total_damage = 5 + 5 * (5 / 25)

total_damage = 6

Now, let's use double-slap:

raw_damage = 2.5 * (10 / 10)
bonus_damage = 2.5 * (2.5 / 25)
total_damage = 2.5 + .25

multi-hit = 2.75 * 2 = 5.5

It penalized double-slap. The only problem is that, at even ATK and DEF, we want for Double Slap to do the same damage as Slap. But what was a success was that our harder-hitting attack ended up doing more damage than our multi-hit because of the bonus it got for doing heavy damage.

So, what we've created here, successfully, is an equation that rewards heavier hits. Could we just solve this problem, now, by giving multi-hits a greater damage-constant to compensate? Right away, I would argue not, because I still think that, if the opponent has LOWER DEFENSE, multi-hits and single-hits are always going to scale the same in this equation... maybe.

Dixx is raising some questions about our old equations, so let's compare them:

Our old way of doing things was for abilities to have a DAMAGE MULTIPLIER which would influence damage directly based on the attack's ATK.

So, if attacker has 10 ATK and Slap has a 'damage multiplier' of 1, then Slap does 10 damage. And then we would subtract the defender's DEF to get the real damage.

In our new system, abilities don't have 'damage multipliers' but rather 'damage constants.' I think that's the core difference. So, now, we say that Slap has a damage constant of 5 -- it does 5 damage supposing that the attacker and defender have the same amount in their respective stats. And then we use the difference between attack and defense to figure out how much to add to or reduce from that value. This way, atk and def always have the same value to the player.

Something we considered, today, was creating a hybrid: the old, linear, subtraction-based system using damage-constants instead of damage-multipliers, and it didn't work. It would've looked like this:

total_damage = damage_constant + (ATK - DEF)

That way, if ATK and DEF are the same, slap does 5 damage (its damage constant). The problem with that is that, the damage constant is quickly made obsolete by the difference between ATK and DEF. If an attacker pumps ATK heavily for every level-up, they might have 20 more ATK than the defender has DEF.

At that point, Slap does 25 damage. The argument could be made that it was the defender's responsibility to raise DEF as much as attacker raised ATK, but the real problem with this is not that the attacker is being rewarded with damage 5x what Slap would have otherwise done; the problem is that the attacker can now use Poke (1 damage-constant) for 1 AP and it'll do 21 damage. That makes it extremely to Slap for that player, but at a much cheaper cost. Also, it means that, while Slap goes from 5 to 25 damage (5x damage), Poke goes from 1 to 21 damage (21x damage).

So, it doesn't work.

And the reason that the original equation of:

total_damage = damage_multiplier * ATK - DEF

doesn't work is because, as both ATK and DEF are raised evenly, the benefit of raising ATK gets much lower compared to the benefit of raising DEF.

total_damage = 1 * 10 - 5

5 damage

total_damage = 1 * 20 - 15

5 damage

This is apparently working fine, but it doesn't serve us correctly for rewarding multi-hits on opponents that have 'lower than average DEF.'

GOOD: w/ 10 atk & 5 def
    slap
    total_damage = 1 * 10 - 5 = 5

    double slap
    total_damage = (.75 * 10 - 5) * 2 = 5

GOOD: w/ 10 atk & 3 def
    slap
    total_damage= 1 * 10 - 3 = 7

    double slap
    total_damage = (.75 * 10 - 3) * 2 = 9 

BAD: w/ 20 atk & 13 def
    slap
    total_damage = 1 * 20 - 13 = 7

    double slap
    total_damage = (.75 * 20 - 13) * 2 = 4






STRICTLY LINEAR ATK-DEF SCALING, ABILITIES HAVE DAMAGE MULTIPLIERS:
    total_damage = damage_multiplier * ATK - DEF

    + As long as the difference between ATK and DEF is the same, Slap does
      the same damage.
    + As DEF falls lower and ATK stays the same, multi-hits are rewarded
      more.
    - Even if the difference between ATK and DEF is the same, Double Slap
      loses damage. This is because DEF gets closer to ATK in scale. When
      you raise two values evenly, the lower value gets closer to the
      higher value in scale.

    GOOD: w/ 10 atk & 5 def
        slap
        total_damage = 1 * 10 - 5 = 5

        double slap
        total_damage = (.75 * 10 - 5) * 2 = 5

    GOOD: w/ 10 atk & 3 def
        slap
        total_damage= 1 * 10 - 3 = 7

        double slap
        total_damage = (.75 * 10 - 3) * 2 = 9 

    BAD: w/ 20 atk & 13 def
        slap
        total_damage = 1 * 20 - 13 = 7

        double slap
        total_damage = (.75 * 20 - 13) * 2 = 4


LINEAR ATK-DEF SCALING, ABILITIES HAVE DAMAGE-CONSTANTS
    total_damage = damage_constant + ATK - DEF

    + If ATK and DEF are the same, then total_damage is equal to damage-
      constant.
    + If ATK and DEF are raised evenly, then this is always true.
    + Which means that ATK and DEF have equal value to the player.
    - As ATK raises over DEF, the damage-constant is quickly outclassed by
      the bonus damage.
    - This means that, for stronger characters, the difference between Slap
      (5 AP cost for 5 base-damage) and Poke (1 AP cost for 1 base-damage)
      is significantly less, making Poke extremely overpowered.
    - The opposite is also true. If DEF outclasses ATK by the damage
      constant (a very small number), that attack is completely nullified.
    - In other words, pretty quickly, most of the damage you're getting is
      from the bonus damage. The damage constant stops mattering.

    GOOD: 10 ATK & 10 DEF
        slap
        total_damage = 5 + 10 - 10 = 5

        double slap
        total_damage = (2.5 + 10 - 10) * 2 = 5

    KIND OF GOOD: 15 ATK & 10 DEF
        slap
        total_damage = 5 + 15 - 10 = 10

        double slap
        total_damage = (2.5 + 15 - 10) * 2 = 15

    KIND OF GOOD: 10 ATK & 13 DEF
        slap
        total_damage = 5 + 10 - 13 = 2

        double_slap
        total_damage = (2.5 + 10 - 13) * 2 = 0

    BAD: 30 ATK & 10 DEF
        slap
        total_damage = 5 + 30 - 10 = 25

        double_slap
        total_damage = (2.5 + 30 - 10) * 2 = 45

BONUS-DAMAGE CALCULATED BY THE PERCENTAGE DIFFERENCE BETWEEN ATK & DEF
    total_damage = damage_constant + damage_constant * (ATK / DEF)

    + When ATK and DEF are the same, Slap and Double Slap do the same
      damage, regardless of how high ATK and DEF are.
    + When ATK is twice DEF, Slap and Double Slap do double damage.
      Compared to previous equations, this is much more respectful of
      scale.
    - It doesn't provide any difference in damage for single or multi-hits
      based on whether DEF is higher than ATK or vice-versa.

    GOOD: 10 ATK & 10 DEF:
        slap
        total_damage = 5 + 5 * (10 / 10) = 10

        double slap
        total_damage = (2.5 + 2.5 * (10 / 10)) * 2 = 10

    KINDA GOOD: 15 ATK & 10 DEF
        slap
        total_damage = 5 + 5 * (15 / 10) = 12.5

    BAD: 15 ATK & 10 DEF
        double slap
        total_damage = (2.5 + 2.5 * (15 / 10)) * 2 =  12.5

THE ABOVE BUT WITH DAMAGE BONUS BASED ON SINGLE-HIT DAMAGE
    raw_damage = damage_constant + damage_constant * (ATK / DEF - 1)
    bonus_damage = raw_damage * (raw_damage / max_hp)
    total_damage = raw_damage + bonus_damage

    + Rewards heavier hits with more bonus damage.
    - It doesn't reward heavier hits less when DEF is higher than ATK.
    - So, there's still no advantage to multi-hits.
    - WHENEVER you do MORE DAMAGE with a SINGLE HIT, you get a GREATER
      BONUS. How can we write an equation that uses this to our advantage?
    ? But what if the damage-constant for multi-hits was higher?

    KINDA GOOD: ATK 10 & DEF 10 & HP 25
        slap
        raw_damage = 5 + 5 * (10 / 10 - 1) = 5
        bonus_damage = 5 * (5 / 25) = 1
        total_damage = 5 + 1 = 6

        double slap
        raw_damage = 2.5 + 2.5 * (10 / 10 - 1) = 2.5
        bonus_damage = 2.5 * (2.5 / 25) = .25
        total_damage = (2.5 + .25) * 2 = 5.5

    BAD: ATK 12 & DEF 10 & HP 25
        slap
        raw_damage = 5 + 5 * (12 / 10 - 1) = 6
        bonus_damage = 6 * (6 / 25) = 1.44
        total_damage = 6 + 1.44 = 7.44

        double slap
        raw_damage = 2.5 + 2.5 * (12 / 10 - 1) = 3
        bonus_damage = 3 * (3 / 25) = .36
        total_damage = (3 + .36) * 2 = 6.72

For next time: what we've been struggling with is creating a damage-calculating equation that satisfies all of these needs:

1.) When DEF and ATK are even, attacks do their 'base' damage.
2.) When DEF and ATK are even, single-hit attacks and their sibling multi-
    hit attacks do equal damage.
3.) When ATK is greater than DEF, multi-hit attacks do more damage than
    their single-hit siblings.
4.) When DEF is greater than ATK, single-hit attacks do more damage than
    their multi-hit siblings.

Many of our equations, tonight, have satisfied many of these requirements -- but none have satisfied all of them.



07/15/19

After our last stream, Panders came up with an equation that he thinks should meet all of the criteria that I was putting forward during our stream. Afterward, Kenny created a spreadsheet to demonstrate that equation and found it to be very satisfactory.

Let's have a look at it, here.

DMG FORMULA:  ((ATK / DEF) * (Slap Base Damage + (ATK - DEF) / 2)) * NUM_OF_HITS

Let's break this down, theoretically:

So, just like in some of my previous example equations, we're using the 'percentage scale' of ATK over DEFENSE as a multiplier against the base damage.

I think, for the most part, this equation looks like something we've already done:

total_damage = base_damage * (ATK / DEF)

In Pander's equation, the base damage, BEFORE THE MULTIPLIER, is being altered.

total_damage = (base_damage + (ATK - DEF) / 2) * (ATK / DEF)

I think that the profound thing about this equation is that the BASE DAMAGE gets a buff. I think that's what I was missing in my own equations, but let's look a bit deeper.

You could break up the equation like this:
bonus_damage = (ATK - DEF) / 2
offense_multiplier = ATK / DEF
total_damage = (base_damage + bonus_damage) * offense_multiplier

It seems to me that the shortcoming of this equation is in the same vein as the last equation I tried which used linear bonus damage. Will there come a time -- maybe even very quickly -- where the BONUS DAMAGE outweighs the BASE DAMAGE such that WEAKER ABILITIES become more efficient than STRONGER ABILITIES.

To test this, we need to look at another ability: 'Poke'. Poke has a base damage of 1.

There's something wrong with DEF in this equation. It seems like raising DEF is extremely strong.

At 20 ATK vs 10 DEF, the damage of Slap triples and the damage of double-slap quadruples.

At 10 ATK vs 20 DEF, the damage of Slap is reduced 75% and the damage of double-slap is reduced 100%.

This seems to be something to do with the 'bonus damage' going into the negative and quickly overwhelming the base damage. So, the problem I predicted.

We can probably also demonstrate this with 'Poke'.

With 20 ATK, 10 DEF, and an attack with a base-damage of '10,' we get 30 damage.

With a base-damage of '1,' we get 12 damage.

But I still think I can prove my point.

Once you get to 100 ATK vs 50 DEF, going from Slap (5 base damage) to Poke (1 base damage) results in a damage loss of ~30%. Where-as you might expect a damage loss of ~80%.

The difference seems much more extreme when DEF is higher.

How can I examine this issue better?

With +20% ATK over DEF, single-hits do +32% damage and multi-hits do +44% damage. Seems legit.

With +20% DEF over ATK, single-hits do -25% damage and multi-hits do -33% damage.

with +50% ATK over DEF, single-hits do +87% damage and multi-hits do +22% damage.

With +50% DEF over ATK, single-hits do -50% damage and multi-hits do -66% damage.

I guess I feel like, when you have twice as much ATK as they have DEF, Slap should do twice as much damage -- and when you have half as much ATK as they have DEF, Slap should do half damage -- but I don't think that's reasonable because of how we're calculating a 'defensive threshold.' I think that idea is maybe incompatible with the idea of a defensive threshold.

Slap is getting a bonus for every point over ATK that it is.

We're augmenting the base damage based on the DIFFERENCE between ATK and DEF. And then we're multiplying that by the percentage difference if ATK and DEF.

By augmenting the base damage by the DIFFERENCE between ATK and DEF, we're giving a bonus to... any attack when ATK is higher than DEF.

But, compared to the base damage, that bonus is more significant when base_damage is lower.

If we get 2 bonus damage and add that to slap, we get 12 base damage. An increase of 20%.

If we get 2 bonus damage and add that to double-slap, we get 7 base damage. An increase of nearly 50%.

The bonus damage rewards weaker hits more.

The bonus damage scales better for weaker hits.

Does this mean that weaker, and cheaper, abilities become more cost-effective against foes that have lower defense than stronger, more-expensive abilities? It would seem 'yeah,' but maybe that's not necessarily a bad thing. Maybe that's exactly what you expect. When you pay more for heavier-hitting abilities, you're not just paying for the raw damage -- you're paying for the ability to penetrate defense. So as long as you have high ATK, you can get more mileage out of weaker abilities and not need to worry as much about more expensive, harder-hitting abilities.

The thing about the bonus damage is that it ignores scale entirely. And that's by design -- that's exactly what we've been talking about for weeks. That's what it's supposed to do. The higher your ATK is over their DEF, the more damage you get, right? So if I have 100 ATK and you have 50 DEF, my ATK may only be double your defense, but I'm also 50 fucking points higher than you in DEF.

Is that how I want to look at this? Get bonus damage for every point over your DEF I have in ATK?

I'm starting to formulate an idea based on Panders' equation, here. I think the real profundity of Panders' equation is that he augments the BASE DAMAGE as the way to get bonus damage.

But I think my idea won't work -- because, again, it relies on SCALE more than LINEAR ADVANTAGE. I think we NEED an element of linear-advantage in order for us to have this 'defense threshold' idea.

But my idea would be like this:

total_damage = (ATK / DEF) * (base_damage + base_damage * (ATK / DEF))

That would award bonus damage to scale with the base damage and the scale difference between ATK and DEF.

But, whenever I try to do things this way, it seems like Slap and Double-slap always end up doing the same damage.

Let's break it up:

damage_multiplier = (ATK / DEF)
bonus_damage = base_damage * damage_multiplier
total_damage = (base_damage + bonus_damage ) * damage_multiplier

10 ATK, 10 DEF
Slap = 10
Double Slap = 5

Slap damage = 20
Double slap damage = 20

20 ATK, 10 DEF

Slap damage = 60
Double Slap damage = 60

I think this works, but the scale is out of whack. We need to downscale the bonus damage a lot. We need to make the bonus_damage more in-scale with the base damage.

What if bonus_damage = base_damage * damage_multiplier - base_damage

I wonder if the second damage-multiplication is necessary. Maybe yeah.

Equation change:

bonus_damage = base_damage * damage_multiplier - base_damage

This effectively scales bonus damage better for attacks that are weaker.

My problem, cognitively, is that I want everything to scale 'neatly,' but that's contrary to the very notion of what I'm trying to accomplish: the effect of some kind of linear threshold.

The equation has to have some kind of linear factor in order for me to have some kind of linear result. But I'm scared of introducing a linear element because that introduces scale problems.

We're working on a JRPG. In any JRPG, you have damage-calculations based on ATK vs DEF, including some other factors (in our case, simply an ability's base-damage).

We have ATK. We have defense. We have some abilities which are meant to have higher 'base-damage' than others.

What we're trying to accomplish is to have WEAKER ABILITIES SCALE BETTER than STRONGER ABILITIES in the case that the attacker has more ATK than the defender has DEF.

The idea being that, if your opponent has more DEF than you have ATK, weaker abilities will scale MORE POORLY where-as stronger abilities will scale MORE FAVORABLY.

And the opposite is true.

So, when choosing which ability you want to use, you have to consider the difference between your ATK and the enemy's DEF. If you have more ATK than them, it's likely more effecient to hit them with 'weaker' abilities, because they scale better when ATK is greater than DEF.

If the enemy has more DEF than you have ATK, it's more likely that you should use abilities that are 'stronger' to overcome that difference. Because the more DEF the opponent has over your ATK, the shittier your weaker-abilities will scale.

My thing is that, any time we just use a MULTIPLIER for damage, weaker attacks and stronger attacks are going to scale the same way. I feel like we need to introduce a linear element -- in other words, at some point, something's gotta get added or subtracted. We can't just keep multiplying everything.

We're talking about a defensive threshold.

We're talking, in the abstract, about a JRPG system where "stronger attacks are better at 'breaking through defense', but weaker attacks are better at 'doing damage' when you don't need to break through defense."

Both Max and Vex put forth the idea that there's no way to do this without running an 'if' on whether ATK is higher than DEF.

Here's why you don't need to do it with an if:

Let's look at what Max said:

If ATK is greater than DEF, then multiply by > 1. If ATK is lower than DEF, then multiply by < 1.

Here's our requirements, as I understand them, and they may very well be conceptually flawed such that it's not possible:

ATK = Aggressor's offensive power.
DEF = Defender's defensive power.
base_damage = the essential 'damage' inherent to the ability

We have two hypothetical abilites: Slap and Double Slap.

Slap has base_damage = 10.
Double Slap has base_damage = 5
Double Slap hits twice.

REQUIREMENTS:

1.) If ATK and DEF are equal, then Slap and Double Slap do the same damage.

2.) If ATK > DEF, then Double Slap does more damage than Slap.

3.) If DEF > ATK, then Slap does more damage than Double-Slap.

PANDERS GODLIKE EQUATION:

damage_multiplier = ATK / DEF
bonus_damage = (ATK - DEF) / scale_factor
total_damage = (base_damage + bonus_damage) * damage_multiplier / scale_factor

The reason Panders' equation works is that it gives (and takes away) bonus damage based on the linear difference between ATK and DEF.

You get fixed bonus (or penalty) damage based on the linear difference between ATK and DEF.

The reason it works is because it has this linear bonus / penalty applied directly to the base_damage but also scales ALL of the damage based on a multiplier.

It scales ALL damage based on this multiplier, but it also provides this linear boost to base_damage.

The bonus 4th requirement for our equation is that "bonus damage" never becomes so high that it trivializes the base damage.

PANDERS EQUATION:
damage_multiplier = (ATK / DEF)
base_damage = some_constant
bonus_damage = (ATK - DEF) / scale_factor
pre_multiplied_damage = base_damage + bonus_damage
total_damage = pre_multiplied_damage * damage_multiplier


SPACE_BUTTS UNTESTED EQUATION:
(base_damage * 0.5) + (base_damage * (ATK / DEF) * 0.5)


Quentin's equation
ATK ** DMG_SCALE / max(ATK, DEF)

I like, in Pander's equation, that, in the end, the damage is multiplied by (ATK / DEF). And because he applies the bonus / penalty as a linear value to base_damage, we see that bonus or penalty be scaled by ATK / DEF.

Do we need a penalty? Can we just bottom-out ATK - DEF at 0? I think we need SOME kind of penalty, right?

If DEF is higher than ATK, you suffer a penalty to your base damage. Why does this impact multi-hits more?

Because the bonus / penalty is a linear value added directly to the base_damage, it always scales more dramatically with lower base_damage.

You guys are talking about making the base_damage of Double Slap a constant, where-as before it was slap_base_damage / number_of_hits.

VEXOS EQUATION

slap_base_dmg = (DEF / ATK + 1) + 8
double_slap_base_dmg = (ATK / DEF + 1) + 3

Panders calculates bonus damage linearly from the difference between ATK and DEF. He adds that bonus damage directly to the base_damage.

Then the whole thing gets multiplied by the damage-multiplier.

Panders is talking about a way to ADD DAMAGE at the very end, after the multiplier.

bonus_damage = (ATK / DEF) / 2
damage_multiplier = ATK / DEF
total_damage (base_damage + bonus_damage) * damage_multiplier

In Panders new equation, at even ATK & DEF, Slap does 12. Double-slap does 14.

BACK TO THE PANDERS RIDDLE

I think the reason that panders' first equation works so well is because it augments the base damage by a linear value that's the result of a comparison between attack and defense.

It adds a value to the base_damage and then multiplies the whole thing by the damage multiplier.

I think, to make it work right, we need to examine that value that is being added to the base_damage.

Panders says that, by adding base damage to the entire damage at the end, higher-damage moves are affected by high defense less. That's totally true.

I'm trying to think of where this breaks down, because I don't think that adding damage at the end is our solution.

Here's a reason that I consider the original panders equation to be broken:

If the defender invests TEN MORE POINTS into DEF than the aggressor has invested into ATK, double-slap does no damage.

This becomes the case once you get into the range of 50 vs 60.

I always keep saying this, and mabye the reason that I can't solve this problem is because I'm trying to marry two ideas that are just not compatible.

I'm trying to combine a LINEAR scale and a scaled-scale. I'm talking about how I want both of these things which maybe can't be had together:

If ATK and DEF are equal, it stands to reason that the ability should do approximately its base damage.

If ATK is double DEF, it stands to reason that the ability should do approximately twice as much damage.

If DEF is double ATk, it stands to reason that the ability should do approximately half as much damage.

BUT.

There needs to be SOME accounting for 'penetration.' The problem is, how do you have penetration make sense while still showing SOME respect for the scale I mention above.

I always keep saying this, and it's a trap that my mentality -- my limited understanding of math -- keeps putting me into. I keep saying, "we need to scale this penetration, as well." That seems to be the only way for '200% ATK does approximately twice as much as 100% ATK' to be married with 'but there is a bonus for the actual difference between ATK and DEF'.

What if we took THE DIFFERENCE between atk and defense and SCALED THAT by the scale of ATK to DEF.

I think I'm onto something, but I always think that.

Panders has this 'scale factor' in his original equation, which is .5. He told me, originally, that we could change this scale-factor to make the the difference more-or-less dramatic.

ATK Advantage is calculated as (ATK - DEF) / DEF
Double Advantage is calculated as Double - Slap / Slap


ATK 15
DEF 10

ATK +50% advantage

Slap: 26.25
Double: 37.5

Double +43% advantage


ATK 30
DEF 20
ATK +50% advantage

Slap: 37.5
Double: 60

Double +60% advantage

So far, this actually seems to be working. We are keeping more-or-less in-scale with ATK vs DEF, but with a relatively (?) slight bonus being added for the LINEAR DIFFERENCE between ATK and DEF.

In the first test, ATK was only 50% greater than DEF. And it was 5 linear points away. Double-Slap did 43% more damage than Slap.

So, at 50% more ATK than DEF and 5 points of advantage, Double-Slap did 43% more damage than Slap.


In the second test, ATK was only 50% greater than DEF. And it was 10 linear points away. Double-Slap did 60% more damage than Slap.

So, at 50% more ATK than DEF and 10 points of advantage, Double-Slap did 60% more damage than Slap.

What I'm getting at is that, although we are getting a JUICY BIT OF BONUS DAMAGE for the LINEAR difference IN POINTS between ATK and DEF, it's still highly appreciative of the SCALE DIFFERENCE between ATK and DEF (50% advantage for ATK)

What I'm getting at is that, although we are getting a JUICY BIT OF BONUS DAMAGE for the LINEAR difference IN POINTS between ATK and DEF, it's still highly appreciative of the SCALE DIFFERENCE between ATK and DEF (50% advantage for ATK).

All other things being equal, when the POINTS ADVANTAGE between ATK and DEF went from 5 to 10, Double-Slap's advantage over Slap went from 48% to 60%.

I want to point out that we can very simply scale how dramatic we want for the effect of 1 point of advantage to be.

So now, let's do the opposite.

ATK: 10
DEF: 15

DEF ADVANTAGE 50%

Slap: 4.44
Double: 2.22

SLAP ADVANTAGE 100%

ATK: 20
DEF: 30

DEF ADVANTAGE 50%

Slap: 2.22
Double: -1.11111 twice

In Pander's equation, there's a FIXED SCALE FACTOR.

In my adaptation, the SCALE FACTOR is ATK / DEF.

Dixx is inquiring about what impact, exactly, does having more hits do to the equation.

And the answer is (or should be) this:

The weaker an attack gets, the better it scales when ATK is greater than DEF.

So, although stronger attacks won't scale as well when ATK is greater than DEF, the fact that they do MORE BASE DAMAGE will often make them a more attractive option, anyway.

But for moves that hit MORE THAN ONCE, that weaker damage is multiplied by the number of hits. Obviously. As in, Double slap hits twice. Triple Slap hits 3 times.

So, because they're doing the damage MORE THAN ONCE, that BONUS that they get for their superior scaling gets applied more than once.

So, in other words, if Double Slap is half the base_damage of Slap, and Triple slap is 1/3rd the damage of Slap, then, if ATK is higher than DEF:

Double Slap does more than Slap.
Triple Slap does more than Double Slap.

Because, in terms of scale, Double Slap is not weaker than Slap, and Triple Slap is not weaker than either Double Slap or Slap. Their base damage is perfectly scaled.

Therefore, because each HIT does less damage, those individual hits scale BETTER when ATK is greater than DEF, so the more hits they do, the more total damage they get.

First of all, we have to look at the percentage advantage between ATK and DEF.

And you can look at the difference. Now wait a minute. Do we even need the traditional 'damage multiplier,' then?

What if we just looked at the difference between ATK and DEF and we used that value to scale something. The problem with that is that the numbers get very extreme, very quickly. 10 points of difference means the same scaling at 100 points and 10 points, which isn't kosher.

It's almost like the difference between and atk and def should, itself, scale. Am I literally just re-inventing atk / def?

If ATK is higher than DEF, the weaker an attack is, the better its damage scales.

So we need to take the difference between ATK and DEF and do what with it?

What if we looked at this a totally different way and included a constant representing 'average damage' which would allow us to get a sense for how 'strong' or 'weak' an ability is. Then we could use that to see how it's supposed to scale. I think that's the wrong direction because we need to fixate on the actual impact of 

Everybody looks at RPGs differently. We've all been playing them for our whole lives, and we've all been seeing the numbers cascade down whenever we hit somebody. But we all have our own understanding of how those numbers are calculated.

Here's how I'm looking at it:
Remember, this game has no equipment. There's no swords.

Abilities have a per-hit 'base damage' that they're "supposed to do, all other things being equal".

When I talk about a 'total_damage_multiplier,' I'm talking about the filter that the damage goes through because of the comparison between the Attacker's ATK and Defenders' DEF.

In other words, I'm talking about, "How much does this damage get reduced as the result of the interaction between ATK and DEF?" And I call it a 'multiplier' because I've been doing it with a very simple, "ATK / DEF", which means that, if I have twice your DEF in ATK, I get double base-damage. To me, that seems like a very elegant way to go about it, because the actual points-difference between ATK and DEF doesn't matter -- rather, the scale matters. So, when you're at the start of the game, getting 1 extra point in ATK might nearly double your damage. Later in the game, you need to invest more to have those same extreme.

To answer Steve's question, 'base_damage' is a value inherent to each individual ability, and, in our case, for the purpose of our testing, we have essentially one base_damage of 10 (Slap) and we have multi-hit variants of Slap whose base damage is just Slap's base_damage divided by the number of hits.

So, Slap has 10 base damage.

Double-Slap has 5 base damage.

Triple-Slap has 3.33 base damage, and so-on.

When an enemy has very high DEF, harder-hitting abilities scale better against them. So, if you use an ability with 5 base-damage it will do less than half of an ability with 10 base-damage, because the 5 is being scaled harder by the enemy's defense.

On the other hand, against an opponent who has low defense (lower defense than we have attack), lower-damage abilities scale BETTER.

DEF > ATK: better scaling for hard-hitting, single-hits.
DEF < ATK: better scaling for soft-hitting, multi-hits.

We have TWO WAYS to compare ATK and DEF.

We can compare them in terms of their SCALE to one another:
ATK / DEF

We can compare them linearly in terms of how many points about they are:
ATK - DEF.

How does this work:

base_damage + base_damage * damage_multiplier

I don't think that scales different for weaker attacks?

base_damage + base_damage * (damage_multiplier - 1)

base_damage = 5
damage_multiplier = 1.5
total_damage = 5 + 5 * .5 = 7.5

base_damage * damage_multiplier

What if we took a different approach? Get a basic equation working and then factor in penetration.

IGNORING PENETRATION.

If I have equal offense to your defense, my attack does its base damage.

If I have twice as much offense as you do defense, my attack does double damage.

In Dixx's words, "So, it isn't total ATK and total DEF that matter, but ATK:DEF?"

The answer is that the goal is to have BOTH be significant.

When you compare ATK - DEF, you're comparing how FAR apart they are, right?

Pander's new equation:

raw_damage = (base_damage + ATK) / hits

total_damage = (raw_damage / 2) * damage_multiplier + atk - def

BASE DAMAGE IS A VALUE INHERENT TO THE ABILITY. EVERY ABILITY HAS DIFFERENT BASE_DAMAGE, THAT'S WHAT DETERMINES HOW STRONG IT IS.

BONUS_DAMAGE IS DAMAGE ADDED DIRECTLY TO BASE_DAMAGE.

BONUS_TOTAL_DAMAGE IS DAMAGED ADDED DIRECTLY TO THE FINAL, TOTAL DAMAGE VALUE.

DAMAGE_MULTIPLIER IS A VALUE THAT SCALES DAMAGE. IT'S ON A PERCENTAGE SCALE.

So, in our most essential of equations:

((base_damage + bonus_damage) * damage_multiplier + bonus_total_damage) * number_of_hits

All night we've been fucking around with ways to tamper with bonus_damage and bonus_total_damage and maybe even the damage_multiplier to try to get the results that we're after.

Unlike our most essential equations, panders divides the damage by the number of hits before it hits the damage_multiplier.

ATK: 10
DEF: 10

ATK ADVANTAGE +0%

Slap: 10
Double: 10

DOUBLE ADVANTAGE: +0%

When I say that, when defense is greater than attack, lower-base-damage abilities should scale WORSE than higher-base-damage abilities, one thing that definitely needs to happen is that, if base-damage is cut in half, total-damage should be less than half.

In Balls' example, the lower-base-damage ability actually scales BETTER.

Let's talk about game-design. The whole reason we've been stuck for nearly 8 hours now is that we're trying to add a strategic layer to which abilities the player chooses to do their damage in battle depending on the foe they're facing.

You guys all play JRPGs, right?

Consider two moves which have the same exact cost (MP, etc).

Slap: base_damage of 10, hits once
Double Slap: base_damage of 5, hits twice

The consideration that we want for the player to make is whether they want to use Slap or Double Slap. Seemingly, they're the same.

The thing is, when the enemy has 'high defense' (higher DEF than you have ATK), damage scales differently. It scales such that it favors LARGE, SINGLE HITS.

Likewise, when the enemy has 'low defense' (lower DEF than you have ATK), damage scales such that it favors WEAK, MULTI-HITS.

In the abstract sense, we're talking about 'penetration'. If you have an enemy who has high defense, a move that hits multi-times for less damage each time will have trouble 'penetrating.' On the other hand, when the enemy has 'low defense,' you don't need to worry about penetration, and so you get more total damage from hitting multiple times.

Let's get back to testing Pander's equation.

ATK 10
DEF 10
ATK ADVANTAGE 0%

SLAP: 15
DOUBLE: 15
DOUBLE ADVANTAGE 0%



ATK 15
DEF 10
ATK ADVANTAGE 50%

Slap: 33.125
Double: 48.125

Slap and Double Slap are TWO DIFFERENT ABILITIES THAT THE PLAYER CAN CHOOSE FROM.

Both abilities have the same exact cost to the player.

Double Slap hits twice, each time at half the 'base damage' of Slap.

Triple Slap has the same cost as both Slap and Double Slap, but has 1/3rd the 'base damage' of Slap and hits 3 times.

In an RPG, ATK, DEF, and the base_damage of abilities is very dynamic -- and the resultant damage calculations are just as dynamic, based on those values.

In Chimera's example, a wide variety of 'ATK' and 'DEF' values will result in the same exact damage.



PANDERS EQUATION
ATK 10
DEF 10
ATK ADVANTAGE 0%

SLAP: 10
DOUBLE: 10
DOUBLE ADVANTAGE 0%


ATK 15
DEF 10
ATK ADVANTAGE 50%

SLAP 23.75
DOUBLE 28.75
DOUBLE ADVANTAGE 21%



ATK 30
DEF 20
ATK ADVANTAGE 50%

SLAP 40
DOUBLE 50
DOUBLE ADVANTAGE 25%




ATK 60
def 40
ATK ADVANTAGE 50%

SLAP 72.5
DOUBLE 92.5
DOUBLE ADVANTAGE 27.5%

You could almost say that when ATK has a 50% advantage over DEF, Double Slap has between 20-30% advantage over Slap.


In panders equation, scaling factor is disabled when def is higher than offense?

ATK 10
DEF 15
DEF ADVANTAGE 50%

SLAP 8.33
DOUBLE 3.33
SLAP ADVANTAGE (8.33 - 3.33) / 3.33
SLAP ADVANTAGE 150%

ATK 20
DEF 30
DEF ADVANTAGE 50%

SLAP 10
DOUBLE 0
SLAP ADVANTAGE ????



GAME DESIGN:
* Slap and Double Slap have the same cost to the player to use.
* Slap has 10 base damage. Double Slap has 5 base damage and hits twice.
* When aggressor ATK == defender DEF, both do their total base damage (10). 

What we want to accomplish is that, as ATK becomes relatively larger than DEF, Double Slap should become increasingly more cost-effective than Slap in terms of damage.

Likewise, as ATK becomes relatively less than DEF, Slap should become increasingly more cost-effective than Double Slap in terms of damage.

Here's our variables:

base_damage : a value inherent to every attack ability representing the damage it'll do if aggressor ATK is equal to defender DEF.

ATK: aggressor's ATK value

DEF: defender's DEF value

Let's assume that, during damage calculation, we don't know how many hits are lumped into the single ability.

Chimera points out that what we're going for, in terms of player decision-making, is that we want for the player to have to compare their ATK to their opponent's DEF, as well as the costs of HIGHER DAMAGE abilities and LOWER DAMAGE ABILITIES, because, if the enemy's DEF is 'low,' then it is likely more cost-effective to use 'weaker' abilities at a lower cost -- because, at the same cost, weaker abilities become more effective in that situation.

In other words, when enemies have higher DEF than you have ATK, you need to hit for more base damage to sort of 'penetrate' or 'overcome' that defense. As such, if you have an attack, like Double Slap, which hits twice at half base_damage each time, for the same cost, it wouldn't be as effective as Slap because each individual hit would be scaled more harshly because of their relatively low base_damage.

On the other hand, if your character has more ATK than the opponent has DEF, it makes more sense to use Double Slap because each attack is scaled better.

Let me point out why penetration cannot scale by number of hits.

In our game, you can use more than one ability per turn.

So, from now on, let's look at two abilities:

Intead of Slap and Double Slap, let's look at Strong Slap and Weak Slap.

Strong Slap has 10 base_damage and costs 10 AP.

Weak Slap has 5 base_damage and costs 5 AP.

When ATK == DEF, using Weak Slap twice should do the same damage as using Strong Slap once for the same cost.






Strong Slap
Weak Slap




Strong Slap has 10 base_damage and costs 10 AP.
Weak slap has 5 base_damage and costs 5 AP.

The player can choose to use Strong Slap once or Weak Slap twice for the same AP cost.

If the player is going to spend 10 AP, they can use Strong Slap once or Weak Slap twice.

If aggressor ATK == defender DEF, then using Strong Slap once will do the same damage as using Weak Slap twice (for the same cost).

Chimera points out that what we're essentially talking about is rewarding the player with bonus damage based on making the correct choice for which ability to use. The issue is that we're trying to figure out how to deliver that bonus damage in a way that scales correctly.

Whenever we talk about "high defense" or "low defense," we're talking about it being compared to the aggressor's ATK.

The bigger the advantage of ATK over DEF, the more bonus damage Weak Slap gets.

The bigger the advantage of DEF over ATk, the better Strong 

The bonus damage is scaling.

Let's revisit our ESSENTIAL EQUATION.

CONSTANTS
    ATK = offender attacker
    DEF = defender defense
    base_damage = base_damage of the ability in question

VARIABLES (we've been playing with these, and beyond)
    damage_multiplier = ATK / DEF
                        Scales the overall damage being done based on the
                        scale of ATK to DEF.
    bonus_damage = an amount of damage added directly to base_damage
    total_bonus_damage = an amount of damage added directly to the total
                         damage inflicted.

total_damage = base_damage * damage_multiplier

The problem with this equation, as elegant as it is, is that Strong Slap and Weak Slap are always both equally efficient. Any time that you attack with Weak Slap, it's going to do half the damage you would've done with Strong Slap.

total_damage = base_damage ^ damage_multiplier

In Chimera's example below, we assume that the player has made the 'correct' decision regarding which ability is more cost-effective.

total_damage = base_damage + (ATK - DEF) * .2

ATK 100
DEF 10

Slap goes from 10 to 28 damage.

ATK 50
DEF 10

Slap goes from 10 to 18.

To break it down using the language we've been using tonight, it's really like this:

bonus_damage = (ATK - DEF) * scale_factor
total_damage = base_damage + bonus_damage

This requires for the game, itself, to know which is the "right" decision based on cost-effectiveness (AP per base_damage). Which sort of requires us to have a threshold for what qualifies as a "weaker ability" vs a "stronger ability," which isn't the end of the world, either.

Let me propose what I think this solution's "weakness" would be, which relates to something that I'm not sure I communicated since Chimera showed up.

In Chimera's equation, he's using the ATK and DEF values solely to calculate bonus_damage, which isn't a bad thing at all. It's just ~a~ way to go about it.

Let me try to communicate the way that I've been conceptualizing the relationship between ATK and DEF and the value of those attributes to the player:

The SCALE between the two is significant. Hence our "essential equation," which fails most of the other tests that we've been trying to accomplish.

total_damage = base_damage * (ATK / DEF)

This equation makes it such that ANY attack will do twice as much damage if the aggressor has twice as much ATK as the opponent has DEF. Likewise, any attack will do half as much damage when the opponent has twice as much DEF.

Obviously, the problem with this is that Weak Slap and Strong Slap will always be equally effective, because they scale identically. Chimera solves this problem by not using the scale of ATK and DEF for anything.

The way that we've been trying to solve this problem, tonight, is by adding some kind of augment to this 'essential equation' which will factor in the difference between ATK and DEF. So, this 'scale' is still a significant factor -- but it's no longer the ONLY factor.

I like Chimera's equation a lot because I feel like it effectively captures this idea of getting more bonus damage based on the difference between ATK and DEF. There are a few things that I wonder:

First of all, can we have this linear bonus that Chimera is applying also act as a penalty for the 'wrong decision' in such a way, mathematically, that we don't need an 'if' statement to see if the player made the supposed 'correct' decision.

Let me try to describe some equations we had working EARLIER which were almost exactly what we needed but which had shortcomings that we just couldn't overcome.

The way that these equations usually end up is that ATK and DEF are compared to calculate some amount of bonus damage, and then that entire resultant damage (base + bonus) is multiplied by ATK / DEF and then, of course, by the number of hits.

When you add the same bonus damage to a stronger, single hit, the scale of bonus:base damage favors the base damage. What I mean by that is this:

If base_damage 10 gets bonus_damage 2, we've made that attack 20% more effective.

If base_damage 5 gets bonus_damage 2, Weak Slap has received more of a boost, relatively speaking, compared to Strong Slap.

So it's seemed to me that there is a way to reward weaker, multi-hits more, in terms of cost-effectiveness, while devising some way to calculate bonus damage that looks at ATK and DEF the same.

Another idea I want to point out is that Chimera's equation, with lovely simplicity, looks at this whole problem in terms of rewarding the player with bonus damage when they make the right decision.

But the way that I've been conceptualizing it is that, for instance, when an opponent has HIGH defense (higher than your ATK), it isn't that you get bonus damage for attacker with a stronger, single hit (for the same cost) -- but, rather, you get penalized less. You don't GET bonus damage --it's just that, as your base_damage gets lower, your hits get penalized more and more. So, RELATIVELY SPEAKING, higher base_damage hits get penalized less.

It seems to me that there must be a way to compare ATK and DEF and come up with some kind of multiplier and / or bonus|penalty value that would reward lower-base_damage attacks relatively MORE than higher-base_damage attacks when ATK - DEF is positive or ATK / DEF is > 1 -- and which penalizes higher-base_damage attacks ~relatively~ less when ATK - DEF is negative or ATK / DEF is < 1.

It just seems like, when you have these values which can be positive or negative (bonus or a penalty) and you have these multipliers which can be greater than 100% or less than 100% -- and you have these base_damage values where, the lower the value is, the more it's (relatively) impacted by smaller changes, there should be an equation that satisfies all of our requirements without needing to have this god's eye view of "number of hits" or whether or not the player made the "right" decision based on cost-effectiveness. I feel like that's something that could be worked into the equation.

STEVE EQUATION
damage_multiplier = ATK / DEF
scaled_damage = base_damage * damage_multiplier
bonus_total_damage = (steve_constant / base_damage) * damage_multiplier
total_damage = (scaled_damage + bonus_total_damage) / scale_factor

For Steve's equation to work, he needs to have a number higher than our highest best damage.

STEVE_CONSTANT 11
SCALE_FACTOR 0.9

ATK 10
DEF 10
ATK ADVANTAGE 0%

STRONG 9.99
WEAK 6.48
WEAK ADVANTAGE 30%

BALLS EQUATION
total_damage =  (left_factor * (DEF / ATK) * base_damage ^ (right_factor * (ATK / DEF)) * hits


If I had to theorize based on what we've been through, tonight, I would say that the ideal equation exists somewhere in here:

damage_multiplier = ATK / DEF
bonus_scale_factor = 1
scaled_damage = base_damage * damage_multiplier
total_bonus_damage = 1 - damage_multiplier
total_damage = scaled_damage + total_bonus_damage

What do we know about 'total_bonus_damage'?
1.) It needs to be 0 when ATK and DEF are the same.
2.) It needs to be relatively lower as base_damage gets higher.

In Kenny's equation, we're not seeing a cost-effectiveness bonus when using weaker abilities. It's kinda backwards: it seems like, lower-base-damage abilities are more cost-effectiveness against high DEF. And it seems like that amount is almost always the same, so we might want to play with the scale_factor.

If this has one shortcoming (and I'm not even really sure it does), it's that, when DEF is higher than ATK, it scales damage pretty hard.

This is a problem that all of Panders' equations had, and he was trying to come up with a bunch of ways to get around that, but I bet the solution is pretty simple.

It's almost like we need to halve the 'bonus' when it's actually a penalty, which we could do with a MAX() I would think, or something like it.

So, for next time: it seems that we just need to solve the problem of the damage PENALTY seeming to be twice as harsh as the damage BONUS is rewarding. Seems very easy to solve in a variety of ways.

FINAL EQUATION:

damage_multiplier = ATK / DEF
scaled_damage = base_damage * damage_multiplier
total_damage = scaled_damage + (damage_multiplier - 1) * scale_factor

07/24/19

Finally back from DTN and getting back to game-dev. I'm re-examining this equation -- and, while I don't doubt that it works as well as I remember, I can't help but notice that the 'penetration damage' is a value totally independent of the ability's base damage.

The 'penetration damage' is (damage_multiplier - 1) * scale_factor

So, it's based entirely on three values: attacker ATK, defender DEF, and the scale_factor constant.

So, the actual damage of the ability has absolutely no bearing on the penetration damage being factored in.

Is that okay? You could argue that it's like a "bonus for penetration" that rewards the attacker for having more ATK than the defender has DEF, and it penalizes the attacker for having less ATK than the defender has DEF.

So, this idea works okay as long as we consider that a 'baseline' move like 'Slap' has 'baseline' damage which is considered 'normal' or 'average,' and then we apply a scale factor based on that. Because, basically, stronger attacks won't have more penetration and weaker attacks won't have weaker penetration. So this 'average' amount of penetration is going to be uniform to all attacks.

Mathematically speaking, this means that multi-hits are affected much more by penetration than single-hits. And weaker hits are affected much more, RELATIVELY SPEAKING, than stronger hits.

Let's carry on with creating this spreadsheet and examine our options for dealing with or better-undering this 'problem'.

Because of the math for the 'scaled damage,' an attack with half the base damage is always going to do half the scaled damage. So there are two ways that multi-hits differ from single-hits:

1.) Each hit is weaker, and, therefore, the penetration damage is of greater significance to the total damage of that hit.
2.) This penetration damage is added PER HIT.

Hypothetically speaking, if you had a move that did 10 hits for 1/10th the base_damage per hit, it would be massively more powerful because it'd get the penetration_bonus ten times. But this is what we want. The whole idea of this equation was to reward multi-hits when ATK was higher than DEF -- and to punish them more when ATK is lower than DEF. After all, this 'penetration_bonus' can also be a penalty, and it's also applied for EVERY hit.

I'm starting to think that this problem with the penetration 'penalty' seeming more drastic than the penetration 'bonus' is actually not the issue. I think the issue is a matter of scale and perspective when it comes to imagining how our units' attributes might compare to one another.

An ideal that we've had for the past few streams has been that, very simply, if the attacker has twice as much ATK as the defender has DEF, then the attacker's ability should do twice as much damage. 

Seems simple. Seems sensible.

But if we're talking about small scales where, let's say, hypothetically, an attacker would have 5 ATK and the defender would have 5 DEF -- and if we're dreaming, hypothetically, that a unit can grow a stat by 1 each time they 'level up,' then we're talking about being able to double your ATK pretty quick. And maybe that's the problem that I'm perceiving.

If I'm right, there are two main ways to solve this problem.

1.) Very simple decide, as a family unit, here, what kind of scale we want for unit attributes. Do we start the game with 50 ATK? Or 5? We've been using '10' as our baseline, but that's totally arbitrary; we can make it whatever we want. If it would solve this problem in some way, maybe that's what we need to do: decide on a scale for our unit attributes.

2.) Maybe we need to address the multiplier not necessary by 'number of points put in' (as Kenny put in) but just in general -- like, make it less dramatic. It would be something like: damage_multiplier = (ATK / DEF) * multiplier_scale . In other words, we could make it so that having twice as much ATK as the opponent has DEF doesn't get you twice as much damage. Maybe it gets you 150% as much damage, or something.

We pointed out, today, that the PENETRATION DAMAGE is not affected AT ALL by the base_damage. And base_damage represents the amount of damage done when ATK and DEF are equal. So, if we were to MAGNIFY BASE_DAMAGE, it WOULD NECESSARILY outscale penetration damage. At some point, it would make penetration_damage entirely obsolete.

So, any time we scale BASE_DAMAGE we must also play with the PENETRATION_SCALE to compensate so that penetration isn't completely nullified.

But, THEORETICALLY, we don't need to mess with EITHER base_damage or penetration_scale. Because those values are totally arbitrary. Because we don't have a scale for HP.

As long as the base_damage of our baseline_ability is in scale with the universal penetration_scale, we're good.

Well, let's consider how often a defender will have 50% more DEF than the attacker has DEF.

I think I'm starting to understand the problem with 'scale' here.

Doing 100% more damage means that you're doing double damage.

But doing 100% LESS DAMAGE DOESN'T MEAN THAT YOU'RE DOING HALF DAMAGE.

It's a simple mathematically falacy that I've been falling into.

Our scale factor is literally a straight-up percentage. If I want for double ATK to do double damage and double DEF to do half damage, we can't just use a linear percentage --

because double ATK WILL DO DOUBLE DAMAGE (100% more damage), but DOUBLE DEF WILL COMPLETELY NEUTRALIZE DAMAGE (100% less damage).

So we need for double-ATK to do 100% MORE DAMAGE and double-DEF to do 50% less damage.

Right now we're doing base_damage * (ATK / DEF).

Kulahan says that we can solve our issue by doing base_damage / DEF * ATK.

I think they're the same thing so, no, that doesn't solve our problem; that's the cause of our current problem.

I'm wrong. Kulahan's right.

In any case, our current equation works fine as far as damage multiplication goes. The issue is with the scale of the penetration penalty to the multiplied damage.

If we have twice as much DEF as we do ATK, with a penetration scale of 5, two things happen:

1.) Our base_damage is scaled from 10 to 5.
2.) We take a penetration penalty of -2.5

These two things combined result in a very extreme penalty. It's a matter of penetration penalty to POST-DAMAGE-SCALING damage.

In other words, at a penalty of -2.5, we've just lost HALF of our scaled damage to the penetration.

Compare that to when you get a penetration BONUS. If we have twice as much ATK as we do DEF, with a penetration scale of 5, two things happen:

1.) Our base_damage is caled from 10 to 20.
2.) We get a penetration bonus of 5.

So, we get a penetration bonus equal to 1/4 of our scaled damage.

In the same situation, reversed, we take a penalty equal to 1/2 of our scaled damage.

So the reason that it seems like we take more of a PENALTY from penetration than we get a BONUS is because, necessarily, as our scaled_damage goes DOWN, the effect of penetration is RELATIVELY MORE DRAMATIC. The ratio between scaled_damage and penetration bonus / penalty goes UP as scaled_damage goes down. The lower the scaled_damage, the greater the relative impact of penetration. The higher the scaled_damage, the lower the relative impact of penetration.

We could probably come up with a VERY SIMPLE WAY to scale penetration based on scaled_damage so that this issue of scaling is lessened.

I want to point out that the impact of penetration is basically limited to one main value: the relationship between BASE_DAMAGE and PENETRATION_SCALE.

Right now, we have a penetration_scale of 1/2 base_damage.

I'm gonna repeat myself:

Our problem is that, as our scaled_damage goes down our penetration_bonus also goes way down. They go down together. And, because of that, the penetration penalty takes on much, much greater significance as the scaled_damage gets nearer to zero.

In other words, as scaled_damage goes UP toward infinity, penetration becomes less significant. As scaled_damage goes down toward zero, penetration becomes more significant.

I have two gut feelings right away:

1.) Scale the penetration by some factor based on scaled_damage.
2.) Idea #1 is stupid and is going to result in the same problem with scaling that we always have: the result will be that penetration is uniformed away so that multi-hits do the same damage as single-hits.

Kenny asks to review what the equation for penetration damage, and it's this:

(ATK / DEF - 1) * penetration_scale

So, one thing we've been grappling with, today, is that base_damage has no impact on penetration damage.

What is a proposed equation for scaling the penetration penalty / bonus based on scaled_damage. Is that something that we can do or is it a fallacy to even think that we want to do that.

I'm talking about somehow scaling the penetration bonus to be proportional, somehow, to the scaled_damage. But just saying that makes it clear that my second instinct (above) is true: that I'd be making the damage uniform for both single and multi-hits. You don't WANT to scale the stinking penetration damage to the scaled_damage. That defeats the whole point. But how can we avoid this issue of the penetration penalty becoming so extreme as we lose scaled_damage. Penalty goes up, scaled_damage goes down, so we get this double-whammy of damage reduction. It's more than a 'double-whammy': it's like some kind of exponential damage reduction.

One thing that we could do is literally just use an 'if' fork to change our equation very slightly when DEF is higher than ATK, right?

We could just say, if DEF > ATK, then cut the penetration penalty in half.

You could run the same equation, but the 'if' statement would change the value of 'penetration_scale' before running the equation.

if atk > def:
    penetration_scale = 5
else:
    penetration_scale = 2.5

That's all that you would need to do to curb the ratio between scaled_damage and penalty. Basically, what we're talking about is curbing the ratio between scaled_damage and penalty. You want for the penalty to be less harsh when you're already losing so much damage to the damage scaling.

The idea is that, when DEF is higher, you're LESS INCLINED TO USE MULTI-HITS. When DEF is twice that of ATK, single-hit does 3.75 and double-hit does 2.5. That's a pretty dramatic reduction (but, on the other hand, having twice as much ATK as DEF is pretty dramatic).

Maybe we should try some less-dramatic values and see how halving the penetration_scale for penalties really looks.

Kenny's proposing that we change penetration_scale from being a constant to being the product of some equation involving our multiplier.

What Kenny's really proposing is changing the equation for penetration_bonus to:

(ATK / DEF - 1) * (1 / (DEF / ATK) + 1)

KENNY VARIANT:
15, 10 -> 16.25, 17.5

10, 15 -> 6.111, 5.555

I think the Kenny Variant is genius and what we're probably going to settle on -- but, just like the old equation, we need to set a scale between base_damage and penetration_scale. It seems that 1/10th might be too extreme.

Theoretical note: the point of penetration is NOT to reward the player for having high ATK. That's what scaled_damage already does. Obviously, when you factor in this damage_multiplier, you're getting a huge benefit for having higher ATK than your opponent has DEF. The point of penetration is to reward or penalize multi-hits.

When I say that I want to make this penetration 'softer,' I'm talking about ONE of two things:

1.) Reduce the OVERALL SCALE OF PENETRATION TO TOTAL DAMAGE.
2.) Reduce the scale of penetration PENALTY to penetration BONUS.

We have to create some language to differentiate between these two concepts.

I feel like we absolutely need to have a PENETRATION_SCALE constant which we can simply play with to INCREASE and REDUCE the relative impact of PENETRATION DAMAGE to SCALED DAMAGE. That it is to say, how much does penetration really matter in our game.

In the pre-Kenny variant, that's exactly what PENETRATION_SCALE did: it made the penetration bonus and penalty (which, at the time, were pretty much even) more or less of a factor in our damage calculation.

I think we still need that. I think what Kenny has introduced -- this new constant is really, maybe, more like a factor which reduces the impact of a PENALTY compared to a BONUS. Maybe we need to call this PENALTY_SOFTENER or something.

Kenny points out that what he did is make our PENETRATION_SCALE not a flat number -- but I disagree with that. What Kenny really did is essentially scale the scale and add a constant -- and that constant is really what's significant, because it's a new value that we have control over.

BUT it doesn't change the fact that we still need a constant to DIRECTLY scale the impact of penetration damage compared to base damage.

I want to prove that the new 'Kenny constant' is what softens penalty compared to bonus. That's our end-game: soften penalty compared to bonus.

That's our goal for tomorrow. We need to record some observations and see how the Kenny constant affects some kind of relative-softening of penalties compared to bonuses.


