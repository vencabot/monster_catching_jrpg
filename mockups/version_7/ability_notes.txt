04/08/19

It's been a while since we talked about game-design. Over the past couple weeks, we've been doing some development -- some actual programming -- regarding the implementation of our game's Dynamic Rule System. Now that it's fully-functional, it's time to start developing other aspects of our game. The problem is that we need to review how we want for these aspects to behave.

I think our first order of business is to start working on 'abilities,' which are the actions your units can take in battle to consume AP. Think of these like the four 'moves' that Pokemon have.

To test the Dynamic Rule System, I created a very simple ability called 'Slap' which I think already nails down some CORE concepts about abilities, but we also had some more in-depth, complicated aspects that I'd like to review and attempt to development.

Let's review what we know about Abilities:
    * Abilities belong to 'classes'.
    * Abilities always consume the Leader's AP.
    * Abilities may consume resources from the unit or carry some cost.
    * A unit's 'MP' attribute is designed specifically as a resource for
      abilities to consume.
    * The use of abilities is the core of our combat gameplay. The idea is
      to choose them carefully and use them to give yourself an advantage in
      battle, and to use them over and over until you win.
    * Aside from dealing direct damage to enemy resources, abilities will
      also engage the Dynamic Rule System by implementing favorable rules
      for your party and disfavorable rules for the opponent party.
    * As a side-effect, some abilities may implement rules that are DIS-
      FAVORABLE for YOUR party or FAVORABLE for the ENEMY party. This could
      be the result of an ability 'backfiring' or just as a cost for an
      otherwise powerful ability.

    * We talked at depth before about how much 'chance' should play a role
      in the core mechanics of using abilities. One thing that we discussed
      was the idea of an 'effectiveness' gradient. Maybe this would be a
      good time to review that.
    * Every ability has 3 levels of effectiveness: 'glancing' effectiveness,
      'normal' effectiveness, and 'critical 'effectiveness.
    * When an ability is used, a dice is rolled to determine effectiveness.
    * Attributes on both the AGGRESSOR and DEFENDER will have an impact on
    * How wide the areas are for the dice-roll to land in any of those three
      levels.
    * These attributes are 'Skill' on the aggressor and 'Parry' on the
      defender (these names both suck, let's reconsider as time goes on).


I guess the moral of the story, today, is that we need to take our 'Slap' demonstrative ability and give it three effectiveness levels and see how we're gonna handle that dice-roll.

At first, we're not gonna fuck around with 'Skill' and 'Parry' attributes. We're just gonna roll a dice and choose a tier to activate when an ability is used.

Even at first, we want to determine a way to weight this randomness -- and that's something that I've had trouble with in the past: randomness weighting. There's many ways to do it and I've never been 100% satisfied that I've found the best way, programatically.

Enough developing: let's talk about DESIGN again. How are we going to calculate effectiveness. We have to change the weights of 'critical' and 'glancing' based on the interplay between the aggressor's Skill attribute and the defender's Parry attribute.

If an aggressor's Skill attribute is substantially higher than the defender's Parry attribute, we're going to have a HIGHER chance of getting a critical and a LOWER chance of getting a glancing hit.

If the defender's Parry attribute is substantially higher than the aggressor's Skill attribute, we're going to have a LOWER chance of getting a critical and a HIGHER chance of getting a glancing hit.

If they're even... Then we fall-back on some default weighting.

What if there was a MINIMUM CHANCE to GLANCE or CRIT. Let's say that we can simply get a 'interplay' value just from combining our 'parry' and 'skill':

Vencabot has 20 Skill
Kenny has 25 Parry

Effectiveness multiplier would be -5.

So, as this number goes into the negatives, we reduce our chance to crit UNTIL IT HITS ITS MINIMUM. You're gonna always have a chance to crit, but the chance bottoms out. Once that chance bottoms out, your chance to GLANCE goes UP. So, what we're really talking about is our chance to 'normal' shrinking. The more dramatic our 'effectiveness multiplier' becomes, the smaller our chance to 'normal' becomes.

Positive multipliers would work the opposite way: your chance to 'glance' would go down until IT hits a minimum, and then your chance to crit would start to go up, eating into your chance to 'normal'.

If our multiplier is 0 (Vencabot has 20 Skill and Kenny has 20 Parry), what are our default weights and how far are they from the MINIMUM weights?

I think, because we're working with a multiplier with 0 -- which is probably gonna be somewhat rare -- maybe we should have more dynamism: higher chances to glance and crit than we've been working with.

15% Glance (minimum 5%)
70% Normal
15% Crit (minimum 5%)

I wanna make a note that the WHOLE POINT of the 'effectiveness system' is to mitigate saltiness, because, unlike some RPGs where 'crit damage' is a pre-baked calculation, our abilities have THREE DIFFERENT FORMS: a 'glancing' form, a 'normal' form, and a 'crit' form, and all three are unique to every ability.

Therefore, you can always choose to use abilities where there isn't a whole lot of variance between the forms. Or you could choose to use abilities where there's a dramatic difference between the forms. So, it's in the player's hands how much they want to lean or be victim to the random effectiveness.

The downside of having lower 'default' values for Glancing and Crit would be that, as you grow your character to have higher Parry or Skill, there's less Crit and Glancing to TAKE AWAY.

The UPSIDE of having lower 'default' values for Glancing and Crit, is there they can grow MORE. It really depends on how extreme we expect the differences to be between an aggressor's Skill and a defender's Parry -- and what I will say is that, looking at how we've designed growth and attributes so far, it does seem somewhat likely that there could be a very large gap (multiplier). So perhaps it would make more sense to have the 'default' values be somewhat rare and then, as that multiplier goes up, we get higher likelihoods to get 'glancing' or 'crit'.

The next step would be to fine-tune the multiplier, but let's not fuck with that, because that really is dependent on character growth, which we haven't looked at yet: we don't know if a normal level for Skill would be '10' or '10,000'. We don't have a sense of scale.

So let's just mock this up and see where we're at.

For our mock-up, let's assume that '5' is a normal amount for Parry or Skill, and let's say that having twice the value of your opponent's attribute will give you a 50% chance to crit (or glance, depending on if you're attacking or defending).

We made some good progress: the next step will be to create a method which takes this 'effectiveness augmentor' (or whatever you want to call it) and returns weights. Since we're lowering ONE weight to a certain level before we start to RAISE the other weight, there's going to be a little bit of coding involved.

## side note: I forgot to fuck around with 'cure conditions' for our DynamicRule system. So, we're not really complete on that, yet.




04/15/2019

Let's make a to-do list for what I want to accomplish with the game this week.

So far, we've created a lot of mock-ups for the games most-complex mechanics (at least, seems to me). They've been proofs-of-concept just to demonstrate that some of this stuff is workable. Now, I want to look at battle in a more wholistic way; I want to actually start creating a full battle that can play out from start to finish with respect for the mechanics that we've discussed during our game-design streams.

So, a few things we're gonna need:

We're going to need Leaders, with their own attributes.

We're going to need to flesh out the Battle object with respect for which Units are in the 'ring' and in the back row.

We're going to need to flesh out the Units with more Attributes, including their slots for Dynamics.

Before we implement Leaders, let's flesh out our existing objects: Battles and Units.

I take that back. Let's get a very simple mock-up Leader object and use that for some Dynamics just to prove that it works. We're not gonna fuck around with giving them permanent Dynamics or AP limitations or their own abilities just yet.

## I'm not totally satisfied with the hierarchy of data in our battle so far. The 'BattleParty' needs a list of units, and the BattleUnits need to know their BattleParty. Futhermore, we're introducing a Leader object, which needs to know the Party that it's leading -- but, at the same time, the Party needs to know who its leader is. It'd be nice to come up with some way to make these objects less dependent on each other.

## Let's talk about hierarchy: it seems to me that, so far, the Battle object is the highest-level object we have (of course), and then, below that, we have the Parties. That makes sense to me: the units know what party they're a part of, but not what battle they're apart of (because we're managing state). The units don't need to know what battle they're a part of, because they know which party they belong to and the party knows what battle it belongs to.

## That being the case, the Leader doesn't really need to know what units it's leading or what battle it's a part of. As long as it knows its own BattleParty, it has access to the Battle object and the BattleUnits through that BattleParty. So, the hierarchy of data is sort of like this:

          Battle
            |
       BattleParty
           | |
BattleLeader BattleUnit

## Because the costs of using Abilities in our game can be so complex, it sort of necessitates not being able to abstract away the code of paying those costs. What I mean is, it would make sense, from an object-oriented standpoint, to give each Ability an 'ap_cost' attribute -- and then, when a BattleUnit tries to use an Ability, it could automatically subtract that AP cost from the Leader.

That makes sense. It would make sense if the gimmick our game wasn't that rules are so dynamic. Because, what if the costs of an ability change based on circumstance? What if you had an ability with a description like such:

Desperate Slap: If used when the leader's AP is at max, it costs 4 AP to use. If used when the leader's AP is below max, it costs 2 AP to use.

In that case -- and it seems very reasonable -- the Leader is punished for using Desperate Slap at the start of their turn. Because of dynamic systems like this one, I feel like we don't really have the luxury of implementing an 'ap_cost' attribute in an object-oriented way. Instead, it seems as though we need to implement the subtraction of costs into the actual code of using every individual Ability. That seems lame, from OOP standpoint, but it does make our mechanics more flexible.

I'm gonna make a new DynamicRule and we're gonna call it "NerdStamina." If the leader's AP drops below 3, every unit on their team loses 30% of their attack power. I'm trying to make a Rule that brings the new 'leaders' into play.

Right now, we've made our mock-up work under the assumption that we would only ever have one action take place in the battle. Now, we're taking more than one action per battle (as you would expect), and I'm finding that we need to reset the Battle's DynamicRule's recurrence_counter's. The question is, when is the best time to do that?

It would be done between player actions.

But how do we calculate that. How do we know when the player has done an action.

Well, it would be after the unit uses an ability. Leaders can also use abilities, including switching units. So... maybe... we need a better way to universally understand that a 'battle action' has taken place. We want to restore the Rules' recurrence_counter's after an action takes place.

Maybe, temporarily, it would just make sense to give the Battle object a 'reset_rule_counters' method that we can call between actions.

Final thoughts for the day: we implented a 'leader' object which has an AP value that we can consume when we use abilities. We made our first rule that cares about the leader and their AP, and we also, for the first time, took advantage of the fact that our DynamicRules are INSTANCES, which means that we can use them to save persistent data about how they've been triggered in the past to alter how they behave when triggered subsequently. So that's kind of cool.

We also implemented a method for our Battle objects to reset the recurrence counters of all of the rules to be called between 'actions'. It'd be nice to have this be automated, but, for that, we'd need a way to know when an action is being used.

I mean, fuck -- we could fix that right now. We should just append 'battle.reset_dynamic_recurrence' to the end of our battle_3.UnitAbility.use method.

For next time, we need to add a lot of attributes for BattleUnits and Battles, at the very least: including a 'ring' in the battle for units to populate and some slots for the BattleUnits to be under the influence of a LIMITED NUMBER of Dynamics. This is something that me and Kenny talked about as a way to balance the Dynamic system: have there be a limit to how many rules a single unit can be subject to.


04/17/19

First of all, I want to program a 'ring' into the 'Battle' object, so that we know which party members from each team are currently 'active' in the battle.

That means adding a new attribute to the Battle object (or would it be the 'Party' object??? It would be the Party object) and making some new Rules that would only target the unit in the ring.

I've mentioned in the past that a big difficulty with object-oriented programming is knowing how to divide and share responsibility. I think it'd make more sense for the 'ring' attribute to belong to the Party objects, in the long-term. It really is all about how you're deciding to abstract your ideas to make your current and future objects behave.

It would make more sense to give the 'in_ring' attribute to a Party object, because the Battle already has two parties and so figuring out who's in the ring would be as trivial as iterating through the Parties and reading their 'in_ring' attribute. What's cool about this is that it would work even if, hypothetically, we had 3 or 4 or 10 parties in the battle.

Furthermore, if the battle had a 'in_ring' attribute, it would need to be some kind of list, because we'd have two units in the ring for two teams. And then, to figure out which team those units are ON, we'd need to iterate through the in_ring list and read their .party attribute. It's just a little bit sloppier.

It makes more sense to have the 'in_ring' attribute belong to the Party objects.

Now that our BattleParty objects have a method for swapping units into the ring, we're going to expand upon that, later -- fuck it. Let's do it now.

Point_units have been implemented (in-ring units), so now we need to design some Rules that take advantage of this. I want 1 Rule that only affects the point_unit of a certain party, and so we want to change our point_unit mid-fight to see if the rule applies not to a PARTICULAR unit but to whoever is currently in the ring.

I want 1 Rule which only affects units who AREN'T in the ring.

I want 1 Rule which triggers when a painted unit is swapped INTO the ring.

Let's create a 'poison cloud' rule which subtracts HP from both point-units every turn? We don't have turns working yet. We could fix that first? Turns would be implemented at the Battle object level. The Battle would have an attribute: current_turn. Now, would current_turn refer to a Leader? Or a party? It doesn't really matter, but that's exactly why we need to consider this carefully: which would make more sense in the long-term.

The parties can't have a 'next_turn' method, because they don't strictly know (without going through their .battle attribute) what the other party is. So, if we're going to do a 'next_turn' method, it should definitely belong to the Battle object. Only the Battle object knows all of the parties.

I just had a horrible vision, dude. It strikes me that we probably want to have Rules that are triggered whenever leader AP is restored (never mind) by unnatural means, such as when an Ability is used that has a chance to restore AP when it crits. I don't want for these rules to get triggered when the turns roll over and the AP is restored back to maximum.

But that's fine, because DynamicEvents have 'perpetrators' for that very reason. If an AP restoration is perpetrated by an Ability, that would trigger the rule -- and it'd ignore the DynamicEvent if it was perpetrated by a turn-change.

It is REALLY ANNOYING that our 'DynamicAttributes' can't be read directly, because they're objects. To get the value of a DynamicAttribute, we have to use DynamicAttribute.value. That's pretty frustrating. Is there a way around that? I thought about it, before, and I couldn't think of a solution. for now, we'll continue using .value.

The thing to do to re-implement DynamicAttributes in a more readable way would be to override __setattr__ of the OWNER object -- NOT of the DynamicAttribute object, which would no longer even be necessary.

So, in object-oriented programming, Objects have 'attributes,' which are values that belong to that object.

So, if we have a 'protagonist' in a JRPG, he has an 'HP' attribute, and that value is constantly changing, but it belongs to the protagonist.

Because the gimmick of our game is that, wheenver a value changes in battle, it can trigger RULES, we created a new type of object which abstractly represents the same concept as an object attribute: a 'DynamicAttribute'.

This way, we can bind behavior to whenever the DynamicAttribute gets updated. So, instead of saying:

protagonist.hp = protagonist.hp - 10

We would say:

protagonist.hp = DynamicAttribute(self, "hp", 100)
protagonist.hp.update(protagonist.hp.value - 10, monster)

The problem with this is that we can't just say something simple like:
print(f"Your protagonist's health is currently at {protagonist.hp}.")

We can't say that because protagonist.hp is NOT an integer. It's a DynamicAttribute. So, instead, we need to say:

print(f"Your protagonist's health is currently at {protagonist.hp.value}.")

Because .value is an attribute of the DynamicAttribute object which refers to its current 'value'.

This works fine, but it's sort of confusing to read because we're intentionally abstracting away the default object-oriented behavior of the language. That's the problem. We're abstractly re-assigning a value, but we're not actually using Python's built-in assignment tools: we made our assignment tools that can trigger Rules. This necessitates an object with a method to do that, and so, when referring to the protagonist's actual HP integer, we need to refer to the 'value' attribute of this DynamicAttribute object -- and that's confusing, because we want to think of 'hp' as an integer.

But I think I have the solution. The solution would be to COMPLETELY GET RID OF the DynamicAttribute object and instead create a DynamicObject class which overrides __setattr__ . Whenever one of its attributes gets changed, it calls the method which has been, up to this point, DynamicAttribute.update().

We don't need an object which abstracts the idea of an 'attribute that can trigger things when changed.'

We need an object which says, 'if you change one of my attributes, things can get triggered'.

The problem with this idea is that, if we just use simple assignment to trigger Rules we don't have any way of knowing who perpetrated the change, and that's super important to our mechanisms.

If I say:

protagonist.hp.update(protagonist.hp.value - 10, monster)

We know that the monster lowered the protagonist's health.

However, if I just say,

protagonist.hp = protagonist.hp - 10

We don't have way of knowing how or why or who lowered that value, and that's super important to our mechanisms.

I'm not gonna have time to fix this today. Let's take a few minutes and think about if there's any solution to this issue. Can we possibly abstract away the DynamicAttribute object by replacing it with true Python object-oriented utilities via the __setattr__ method. Can we possibly have these Rules be triggered by __setattr__ when __setattr__'s only arguments are the NAME of the attribute ("hp") and the NEW VALUE (protagonist.hp - 10).

Is it important that we know WHO changed the protagonist's HP. The obvious answer is YES, obviously. We use DynamicAttribute.update to create these DynamicEvent objects which sort of act as reports to tell the rules what just happened.

With __setattr__, we could create and manage EVERY ASPECT of our current DynamicEvent report EXCEPT FOR the 'perpetrated_by' attribute.

We have to have the full report to make the rules work, and a huge part of that report is not only WHOSE value GOT changed, but WHO initiated that change.

If KReichJr attacks Vencabot and Vencabot's HP gets lowered, we're gonna need for Rules to know that Kenny is the attacker. That's pretty much the whole point of the dynamic system. We have this report that gets generated and which all of our Rules read to decide if they want to trigger or not. The report explains:

Who is the target of this change.
What attribute got changed.
What was that attribute's value, before.
What is that attribute's value, now.
Who initiated this change.

From __setattr__, we can get ALL of this data except for the last part.

I'm sad to say that it seems like our solution is the best solution for our problem considering our unique needs. In order to trigger rules whenever an attribute is changed, we need to generate this report which we're calling DynamicEvent. To generate that report, we just can't rely on a simple, vanilla, object-oriented attribute assignment.

If we say,

protagonist.hp = protagonist.hp - 10

We just can't load in information about HOW or WHY or WHO lowered that value. We NEED some kind of special object with special methods that simulate 'assignment'. In our case, we're using an object called DynamicAttribute which simulates a vanilla, object-oriented 'attribute' but which you DON'T assign using the assignment operator; instead, you assign it using a special method, 'update,' which requires that you supply the identity of whoever is 'perpetrating' that change.

I was really hoping to negate the necessity for 'protagonist.hp.value,' but it seems that we don't really have that luxury.

I mean, would it make more sense to just give 'DynamicObject' the method 'update(),' and then, when we changed the protagonist's health, it would be like this:

# This is what I want, but it doesn't supply a perpetrator.
protagonist.hp = protagonist.hp - 10

# We have this. The hp attribute is not an integer, but a DynamicAttribute.
protagonist.hp.update(protagonist.hp.value - 10, monster)

# We could do this, but it's the same issue, really.
# This way, we can access protagonist.hp as an integer, but we still can't
# assign directly to HP. It's the same problem, though; it's unintuitive.
# If, one time, you forget to call protagonist.update_attr and instead call
# protagonist.hp =, then Rules won't get triggered.
# This way makes more sense. It's more clear what's going on. It's saying
# very explicitly, "update this value but also do some other things (check
# rules)." Basically, we're creating our own __setattr__ method, except that
# it takes a perpetrator argument.
protagonist.update_attr("hp", protagonist.hp - 10, monster)

We gotta play 3rd Strike, but I guess, for our next sit-down with this, it probably would make sense to replace DynamicAttribute with DynamicObject. DynamicObjects can have their attributes updated through a method, 'update_attr', which explicitly checks rules.

protag.hp = protag.hp - perp.damage

That doesn't work because, to override __add__, we would need to override 'integer', in this case.

We gotta end the stream. We'll definitely sleep on it. I still think that the most elegant way is closer to what we've been doing, but maybe we would go toward having DynamicObjects with an update_attr method instead of DynamicAttributes with an update method.

But it's definitely worth looking at subclasses 'int' and seeing if we want to override the behavior of straight-up numbers so that we can add them together and get special information out of it. Worth looking at it.

04/18/19

Now that we've replaced the old 'DynamicAttribute' way of handling the rules with the 'DynamicObjects,' we've solved our problem of having to access attribute values using object.attribute_name.value .

So, the old way of updating an attribute in such a way that it would trigger rules was like this:

my_unit.hp.update(new_hp_value, enemy)

The problem with this was that, in order to see how much HP 'my_unit' currently had, we had to access it like this:

my_unit.hp.value

With this NEW way, if we want to update a value in such a way that it would trigger rules, we do it like this:

my_unit.update_w_rules("hp", new_hp_value, enemy)

And then we can access the unit's current HP like this:

my_unit.hp

I think that's a little more elegant. It's a little bit more clear what's going on. It's much easier to access attributes in a sensible way. The only downside is that we STILL can't just use vanilla assignment -- but that's probably for the best, really. I mean, it's very important with object-oriented programming to minimize 'side-effects' -- that's a danger of 'state'. When you start overriding 'addition' and 'subtraction' and, if we could, 'assignment' so that it does OTHER things aside from what you see on the tin, then that's probably not a good idea.

It probably makes sense to use an overt method for triggering rules when a value is changed. That way, anyone looking at the code can tell that's what it's supposed to do. Otherwise, if we COULD override assignment to do the same thing, it might be easier to read AT FIRST:

my_unit.hp = new_value

But then it might be confusing when crazy shit starts happening just because we made an assignment (if we could do that). So having a separate method probably makes sense.

DynamicObjects need to know their own list of Rules. The Rules are subservient to the Battle object. Does the Battle object need to be a DynamicObject.

Well, yes. Yes it does. Let's say that we could somehow re-construe 'active_party' as an attribute of the parties, themselves. Like, party.is_active = boolean. Even if we could do that, I don't think there's a way to have a Rule like this if the Battle is not a DynamicObject:

Status Quo: Whenever a new Rule is added by Party B, Party A gets their health restored.

For this reason, I think it makes sense for the Battle object to be a DynamicObject.

But. A problem arises. So far, our DynamicObject.update_w_rules method assumes that all of DynamicObject's attributes are immutable. It takes the old value and replaces it with a new value. That doesn't really work for mutable objects, such as lists, which might change and require rules to be triggered when a new value is appended to them. Is that going to be a problem?

Well, the first thought is that every attribute of a DynamicObject that's going to trigger rules MUST BE TREATED AS IMMUTABLE. This is a necessity because so much of the 'report' system, based on DynamicEvent, is founded on the idea of comparing the OLD VALUE to the NEW VALUE. We're always gonna need to know what the OLD VALUE was and what the NEW VALUE is. That's super important to the very basis of the Dynamic Rule system.

So, if you have something like a LIST -- like, let's say that you have a Rule that gets triggered whenever an item is added to the leader's inventory. In order to compare the old list to the new list, we need to have two different lists: so, we're talking about mutable objects being treated as immutable. We almost might as well just use tuples.

I'm not sure if that's a problem. I don't necessary THINK that's a problem, except for what I just got done saying about the DynamicObjects needing access to a permanent, mutable reference to the current battle's rules. THAT BEING SAID, we also just found out that the battle's 'list' of rules is actually a dictionary.

So, maybe the dictionary is what gets passed in to DynamicObject and the DICTIONARY never changes. It just contains a before and after phase.

The Battle object has a dictionary, 'Battle.rule_phases'. It's a dictionary of phase-names to the lists of DynamicRules that are checked on that phase.

As a DynamicObject, we could call 'update_w_rules' on it -- BUT WE COULD NOT use that method to change a List of rules, because the Lists of rules are not attributes of our DynamicObject: they're values in a Dict which is an attribute of our object.

So, as of right now, if we wanted for a Rule to trigger when a new rule is added to battle, it would need to work like this:

new_rule_phases = {}
new_rule_phases["before"] = battle.rule_phases["before"].copy()
new_rule_phases["after"] = battle.rule_phases["after"].copy()
new_rule_phases["after"].append(some_new_rule)
battle.update_w_rules("rule_phases", new_rule_phases, perpetrator)

We have to treat it as being immutable. We have to make a whole new dictionary with whole new lists and replace the old dictionary of lists.

It's kind of ugly, right now, but I think that's mostly because we have this dictionary, "rule_phases," when maybe we just need to use attributes. That's one major reason it looks ugly. Maybe we should do something more like this:

battle.before_rules
battle.after_rules

Instead of,

battle.rule_phases = {"before": [], "after": []}

Having a dictionary for rule_phases is kind of wasteful, because we're just matching a string to a value -- and that's exactly what object.__dict__ is for. If we're just matching a name to a value, we might as well make it a attribute. It's not like we're going to be dynamically adding in more keys to this dictionary.

On the other hand, I think that having a dictionary of phases makes it more clear how we process the rules. Because attributes have no order (technically, neither do dictionaries, but at least they have a visible order in the source code). We treat both phases equally, just one after the other. So, by having two totally separate attributes, you sort of lose that relationship -- abstractly, they're the same thing, just different phases.

Here's my idea: what we need is a new type of object, 'RuleSet'. RuleSet has attributes:

RuleSet.before
RuleSet.after

What's cool about RuleSet is that it can be a DynamicObject. So, when RuleSet.before or RuleSet.after is updated, we can trigger Rules. And, by virtue of being a classed object, RuleSet is mutable -- so we can pass in a RuleSet when defining a DynamicObject.

But hang on though. How do we pass the RuleSet as its own RuleSet.

Let's go implement that.

Today, in review, we really drastically changed the way that our dynamic_system library is laid out and the way that it behaves, internally. The result is that its API has effectively changed, although it works mostly similarly. The 'battle' library is completely broken by these changes and needs to be adapted to the new dynamic_system. Also, our actual mock-up at 'rules_and_events' mostly needs to have its example DynamicRules updates to match the method-name changes of dynamic_system.DynamicRule .

It should be a relatively quick porting job, but we don't really have time to do that right now. That'll be our project for Monday: get everything working again, so that it's as effective as it was BEFORE -- but with much cleaner internal code.



04/22/19

We have a problem. Understandably, our new Ruleset object has two attributes -- 'before' and 'after' -- which reference lists of DynamicRules to be checked on those phases.

To this end, we removed the old 'check_phase' attribute from the DynamicRules, themselves. They don't need to know their own check-phase.

But, if the DynamicRule object doesn't have a tag that we can use to find out its check-phase, how do we know which list of Ruleset to add that Rule to at the start of battle (or any other time).

It seems to me like the DynamicRules DO need to have some way to communicate when they're supposed to checked. So... That seems a bit redundant considering that our Rulesets also have 'before' and 'after' lists.

On the DynamicRules, the 'check_phase' attribute could be thought of as a 'tag,' because it's not an attribute in the sense that the Rule, ITSELF, will ever access that attribute. Usually when you have an object and it has attributes you're going to be using those attributes in the methods of that object.

In this case, it's just important that other objects which play with the DynamicRules be able to tell when that Rule is supposed to checked.

Let's review the basics of the 'dynamic rule system' and then talk about how our code is laid out.

In many JRPGs, characters can inflict and be inflicted with 'status changes': 'poison', 'paralyze', etc. Also, they can use 'buffs' to give themselves and their allies a temporary boost to some attribute.

The central gimmick of our game's combat system is that these status changes take on a much more significant role. For one thing, every status change can be complex beyond what we're used to seeing in JRPGs.

Instead of having a vanilla 'poison' attribute, we're talking about having a 'DynamicRule' that says something these along these lines, which some kind of 'rogue' class might have inflicted upon their opponent:

When the inflicted target uses any skill to heal an ally, they take damage equal to the amount that their ally recovered.

That's a 'dynamic rule'. The idea beyond inflicting these 'status changes' is to limit your opponent's options and to strengthen your own team's dynamic. Buffs behave the same way:

Whenever the target gains attack power, they also gain defense.

As you might imagine, implementing a system like this, in OOP (or otherwise), is an interesting challenge -- because we're talking about being able to dynamically alter the rules of the game, itself.

The solution that we've come up with is what I'm going to show on-screen right now.


This stream, today, hasn't been a huge success in terms of making progress, and a part of that is, coming back from the weekend, I'm not 100% sure of where the version 4 mock-up begins and the version 3 mock-up ends

The big changes in the version 4 mock-up are as follows:

DynamicAttributes are being traded for DynamicObjects.
We're implementing 'Ruleset' objects, which manage all of the rules in a battle.

Because of those two changes, we need to re-write all of our existing test DynamicRules: Invincible, Hench, ExtraDamage, Persistence, Rage, MagicMan, OldManGenes.

Where we're at, right now, is how do we append new DynamicRules to this Ruleset.

I think that DynamicRules still need a 'check_phase' attribute. They need this attribute because, when we add the rule to the game, we need to know what phase to append it to. It's kind of sloppy, it's kind of ugly, it's kind of redundant. I don't like it.

One solution, at least as far as REDUNDANCY, is to have the Rules in a Ruleset all be a part of 1 list -- and then, when you're checking the 'before' phase or the 'after' phase, you just use a list comprehension to create those phases.

Let's make a very simple "append rule" method and fix the DynamicRules to have a check_phase attribute.

Just to celebrate Penguin joining the stream (and because I'm on the fence myself), we'll go with having only one list of Rules.

I have a problem. When should the recurrence counters be reset?

The obvious solution would be to reset them once the 'after' phase is completed.

But I'm not sure that's what we want, because the main thing that DynamicRules do is CREATE OTHER UPDATES which, in turn TRIGGER OTHER RULES. So, if one update completes and the recurrence counters get reset, couldn't that cause bugs with other updates happening at the same time? I want to say yes, but I can't prove it.

If I have two rules that read as such:
"If Vencabot takes damage, he loses attack power."
"If Vencabot loses attack power, he takes damage."

That's an infinite loop, and that's why we implement the recurrence counter.

Let's draw up an order-of-operations for if the recurrence counters were reset after a successful update.

We propose an event where Vencabot takes damage.
Nothing triggers in the Before phase.
In the after Phase, we update Vencabot's attack power.
We propose a change to Vencabot's attack power.
Nothing triggers in the Before phase.
In the after Phase, we update Vencabot's HP.
In the before phase, nothing happens.
In the After phase, we try to reduce his attack power, but we're at the recurrence limit.
Now that Vencabot's attack power has been updated, recurrence counters get reset.

THE BUG HAPPENS RIGHT HERE. If we DID have more Rules than just those two, we would have a problem with recurrence counters being reset after his attack power was updated.

Now that Vencabot's HP has been updated, recurrence counters get reset.


But the 'update' happens in the SAME THREAD. So, we don't reach the end of the first 'After' phase until we're done processing this attack power update.

So, we can't reset recurrence_counters after a successful update. We have to reset them once all updates on all phases are complete.

So, this is a job for an object much greater than what we're working with, now. Basically, the recurrence_counters would need to be reset between unit turns -- and, right now, we don't have a mechanism for moving between unit turns or otherwise completing an entire action.

Well, I mean. That's a problem. We could implement this 'recurrence_counter reset' at the end of every Ability in the game. But, the problem with that is that we have actions the player can take which aren't strictly 'UnitAbilities', such as Swapping team members, using items -- attempting to flee from combat or whatever -- which should be able to trigger Rules (and, by extension, reset recurrence_counters).

Basically, we might need some kind of parent object which abstractly represents an entire 'action'. An action that can trigger rules -- and, when it's over, the recurrence_counters get reset.

For now -- for mock-up version 4 -- let's just reset them MANUALLY. We're gonna reset the recurrence_counters manually.

Our dynamic_system_4 library is complete for mock-up 4, as of now.
battle_4 objects need porting. They still use 'DynamicAttributes' instead of 'DynamicObjects'. That's our project for Wednesday.

Once that's ported over, we'll need to rewrite rules_and_events_4 somewhat drastically especially to change the way that our existing 'test rules' operate.



04/24/18

Today, we're porting over the battle_4.py so that it's compatible with dynamic_system_4.py -- and that means, mostly, taking situations where we were using DynamicAttributes and replacing them with situations where we can use DynamicObjects. The other big change is that we're using Rulesets, now, with our Battles.

One thing that I want to point out right away is that we need to temporarily dial-back our features to accommodate the changes for the version 4 mock-up. A lot of the problems that we had with Version 3 which necessitated the move to Version 4 are problems that we're not going to be prepared to handle, yet, until we get our old mock-up battle running, again.

So, that means that we're not fucking around with turn-taking yet -- alternating turns between parties. We're just going with a mock-up where somebody is slapping somebody else 4 times in a row.

So far, in our code -- considering that we now have a 'Ruleset' object -- our Battle object is entirely pointless. Before, the Battle object's main job was to contain the DynamicRules -- but, now, Rulesets do this. Of course, I think, in the very near future, we're going to need more from the Battle object -- especially when it comes to accessing all of the Units that are currently in battle.

For now, though, we could probably do without it.

Maybe, the thing to do -- with respect for where this code is HEADED -- would be to create a DynamicRule, today, which necessitates the use of a Battle object.

The most fundamental purpose of the Battle object would be to -- I don't know. Let's make a list, real quick, of what sorts of data would sensibly be contained in a 'Battle' object -- an object which represents the STATE of the current battle.

A Battle object would have data regarding:
    * What parties are taking place in the battle.
    * What the battle's ruleset is.
    * Outside of the MECHANICAL aspect of battle, it might contain data
      regarding presentation: what sort of environment the battle takes
      place in.
    * Maybe information regarding whose turn it is and methods for in-
      crementing turns.

If the Battle is, itself, a DynamicObject, then it inherently knows the Ruleset.

It's important to have some object at the top of hierarchy which knows all of the parties in battle.

Lemme dial that back: we only have TWO parties in battle. I'm getting ahead of myself. Sometimes I think that, with how far we've abstracted a lot of our battle code, so far, we could hypothetically easily create battles with more than two parties. I feel like, as long  as we stay on this course of abstraction, that would be trivial. But as soon as we start to INFORM our DECISIONS to maintain the possibility of many-teamed battles, we're going off-course.

We have two parties. It's still important that we have an object at the top of this hierarchy that knows both parties, because we need that in order to have Rules like this:

If Unit A is healed by Ally Unit B, then a random enemy unit takes damage.

That sounds like a very simple rule considering our mechanics so far, but the problem is that Unit B healing Unit A generates a DynamicEvent report -- and, since neither of those units is on the OTHER team, the Rule receiving that report has no way to access the other team.

Maybe I'm going about this wrong. This is a bugbear of object-oriented programming, in general. This is a problem of state. Is it actually wise to be able to access a random unit on Party B when you're only given a unit from Party A. Why should a function be able to mess with Party B if it's only given a unit from Party A as an argument.

Maybe this is not indicative of us needing a top-level object. Maybe it's indicative of the fact that we need to re-assess the way that our functions are doing their jobs. Is there a way that we can better-manage the arguments that we're providing to our functions so that it's more clear how data is being accessed.

Here's what I do know: DynamicRules need to have access to EVERYTHING in a battle. Yeah, they get a report in the way of DynamicEvent and they can use that report to DECIDE what they want to do -- but their access to the battle shouldn't be limited to what they have in that report. That's a problem I just realized that we have. It should go without saying that any DynamicRule should have access to every single object in a battle.

What's cool about this revelation is that it makes you think about how VERY FEW OPERATIONS in battle actually need access to all of this data. It helps us to trim down our state.

Like, why should every Unit have some kind of reference to every other object in battle. I'm pretty sure it would never, EVER need that. I'm starting to think that, really, only TWO things need access to everything in a battle: the RULES and whatever code we use for the INTERFACE. The player needs to be able to do things like TARGET ANY UNIT that they want for an ability. The player needs to be able to CHECK ALL OF THE RULES.

So the PLAYER needs access to all of this stuff. And the RULES need access to all of this stuff.

I'm pretty sure no other object in battle -- be it a 'Party' or a 'Leader Unit' or a 'Battle Unit' actually need to know jack shit. I think we're giving these objects WAY too much access to data. We need to trim down our state.

Let's re-examine the way that DynamicRules are instantiated. Because I want for them to have EXPLICIT ACCESS to everything in a battle.

Before we even start taking DynamicRules apart, let's look at our other battle objects and decide if they fucking EVER need access to their parent objects. Maybe we could have a true hierarchy where slave objects are not even aware of their master object. That would cut down on SO much redundancy.

Why do we have a Party object which has Units and a Leader when we could just have a Leader object which knows its subordinates.

Mock-up version 4: no more Parties. Instead, we just have LeaderUnits, and they have subordinates.

For some reason, we have our Units set up so that they can have more than one ability by the same name. One Unit could know two different moves that are called 'slap,' and they could be both totally different moves.

I'm not sure I'm about it. I had this idea of moves that have VARIATIONS. The idea was that, if "Pikachu" learns 'Thunder Shock' at level 30, then maybe different Pikachus would learn fundamentally different takes on 'Thunder Shock' at level 30, as a way to make each pikachu more unique.

I still think that's a cool idea, but do they REALLY need to all have the same name. If we have 5 variations on Thunder Shock, couldn't we call them different stuff, like, at level 30, a Pikachu might learn:

Super Thunder Shock
Poisonous Thunder Shock
Sticky Thunder Shock
Cruel Thunder Shock

We could give them different names but have them be variations on the same ability. I don't think it's a good idea at ANY point in our development to entertain the notion tha ta single unit might have more than one ability with the same exact name.

So, I'm just going to change the Unit's ability attribute to a list. Yeah, it means that we won't be able to access it, INTERNALLY, by name, any more -- but we can fix that later.

Is it safe to say, for the purpose of managing state, that an object should only manage data that's unique to that object. That sounds right when I say it like that. I mean, internally, there's really no good reason that a unit should need to have a list of its own abilities -- or, if it does, the ability doesn't need access to its owner.

What if we moved UnitAbility.use(targets), to, BattleUnit.use(ability, targets).

Now, the ability doesn't need to know who its owner is, necessarily.

Let me ask a very important question to the future of how our objects are instantiated:

DO WE NEED TO INSTANTIATE ABILITIES. Should they just be classes that are never truly instantiated -- class methods, class attributes. What is unique about one Slap compared to another.

The obvious answer is that, if we want for units to be able to POWER UP or LEVEL UP their abilities, which would not be unusual in a JRPG, then they need to be instantiated.

But I mean, OTHERWISE, no, right? We don't need for there to be 10 different 'slaps' floating around.

I want a structured concept of an 'ability,' but I just want one of them. I want for there to be only one 'Slap'.

Would it make more sense to have a class, Slap, and INSTANTIATE IT ONCE PER BATTLE (or whatever -- per game sitting, per launch -- per state), or would it make more sense to create a CLASS and then just use its CLASS ATTRIBUTES and CLASS METHODS to get our job done -- or is there a third option that I'm not aware of?

With this new approach, an Ability is just three functions:

_use_glancing
_use_normal
_use_critical

These functions should have access to each other (so they're probably methods) so that _use_critical can just run _use_normal and then do something extra. It could almost just be one function. It's just that every 'Ability' can occur 3 different ways.

With my education, it just seems like you would want to make a class with class attributes (if necessary) and class methods. And you would never instantiate that class. It's just... the fact that you would never need __init__ is what makes me feel like maybe it shouldn't be a class.

Maybe I just need a dict like:

slap = {"_use_glancing": some_callable, "_use_normal": some_callable, "_use_critical": some_callable}

The problem with this is that the functions can't access each other. Also, in terms of architecture, we now have to define our Abilities like so:

def slap_use_glancing(user, targets):
    pass

def slap_use_normal(user, targets):
    pass

def slap_use_critical(user, targets):
    pass

slap = {"use_glancing": slap_use_glancing, "use_normal": slap_use_normal, "use_critical": slap_use_critical}


singleton Slap:
    def method_1(single, arguments):
        pass




Abilities should have access to the whole battle. Even if the explicit 'target' is Unit B, the ability might want to splash damage to a random opponent -- or a random unit. We could have an Ability defined as such:

Big Shell: "Hits target for massive damage but at the risk of misfire damage to a random unit on the field."

So yeah, you target a particular unit, or units, or whatever -- but Abilities still need access to the state of the battle.

We have a problem. An interesting problem. We just got done talking for like an hour about how Abilities don't need to be instantiated -- but if Abilities are gonna have access to the current state of the battle, they gotta be instantiated.

Maybe it would make more sense to give the 'battle' object as an argument to use_glancing, use_normal, and use_critical.

But, we have a problem. An architectural problem.

Never mind.

The problem with giving the 'battle' as an argument to use_* is that the Unit doesn't know what battle it's a part of.

Are we being overly cautious? When you're working with object-oriented design I feel like it's a battle between over-relying on state and under-relying on state.

I'm gonna make a hard rule: NO. REDUNDANT. REFERENCES. That's where we're drawing the line.

Right now, with our Rules behaving as they do, ABILITIES CAN BE PERPETRATORS. That way, we can say,

Steel Cheek: If Unit_A is Slapped, they will take 0 damage.

We've lost this rule:

Steel Cheek: If Unit_A is Slapped by Unit B, they will take 0 damage.

Maybe it does make more sense for a report like DynamicEvent to supply more information: the PERPETRATOR and WHAT THEY DID.

Before, because Abilities were instances that knew their owner, we could INFER the actual unit using the ability knowing only the ability that was used. But now we don't have that luxury.

But I kind of like the idea that Abilities are things that you DO, and, as such, they don't really need to be instantiated. So maybe the perpetrator could be the UNIT, and then there's another attribute of this report which explains what Ability was used.

The problem with this is that, historically, 'perpetrators' haven't always been Units, either. For instance, a perp might be a Rule.

If we have a Rule that says,

"If Unit_A takes damage, then they gain attack power," sure, it could be triggered by Unit_B using Slap -- but it could also be triggered by a Rule that says, "Every unit on Party A takes 1 damage every turn."

I mean, it seems like we definitely have a limited number of objects that can be a perpetrator.

Before, only Units, Abilities, and Rules could be perpetrators of a DynamicEvent.

Now, I'm feeling like we have two types of perpetrators: Units and Rules. If the perp is a Unit, we also report what Ability they used.

Maybe a part of solving this problem would necessitate looking at a Rule like this. We couldn't make this rule work, before:

"If Unit_A takes damage from a Rule implemented as a result of Unit_B using Poison Slap."

This requires a report more complex than we've ever fucked with. We need to know what ABILITY implemented the Rule and we need to know what UNIT used that ability.

It'd be ideal if the Rules were, like abilities, just a static class. In our mockup-3 code, the Rules were also instances because they needed to know --

The Rules have to be instances, because they might need things like arbitrary counters, and they definitely have a 'cure condition' which is going to be updating over time.

So, the Rules could save some data regarding what ABILITY SPAWNED THEM and what UNIT used that ability. That's a luxury we can afford because Rules need to be instances.

But that same design doesn't follow for Abilities, which seem to be working more-or-less just fine without being instances.

The good thing is, with this trail of logic, ALL REPORTS WOULD DEFINITELY have a perpetrating unit and a perpetrating ability, right? Maybe not.

So, basically, where we're at is we're re-examining our DynamicEvent report system. I think, we have two options presented to us:
    * Go back to having 'redundant references' between objects, which means
      that object A has a reference to object B and object B has a reference
      to object A. This is what we had before, I've done this with many
      other projects in the past. It's just mad ugly and can cause some
      terrible bugs.

    * The other option is to somehow give more information in our
      DynamicEvent reports and ideally make it uniform in some way.


Maybe there is no way to make it uniform. Maybe we just need different kinds of reports depending on what sort of object is abstractly 'perpetrating' the attribute change.

Maybe we need a different format of report of Unit A's HP is lowered by rule Poison vs if Unit A's HP is lowered by being Slapped by Unit B.

Penguin's talking about a 'foreign key' to associate things together.

Maybe he's saying that the Leader doesn't need to know the Subordinate and the Subordinate doesn't need to know the Leader. Instead, they both know the Battle, and the Battle has a dict of leader -> units.

That way, you don't even necessarily have a hierarchy of data: you have a sort of CENTRAL structure that coordinates all of the objects that orbit it.

class Leader:
    def __init__(self):
        self.suboordinate = None

class Suboordinate:
    def __init__(self):
        self.leader = None

leader = Leader()
suboordinate = Suboordinate()

suboordinate.leader = leader
leader.suboordinate = suboordinate


At some point in your code, you do:

suboordinate.leader = leader

But you forget to do

leader.suboordinate = suboordinate

To solve this problem, on the leader, I used to have a method:

class Leader:
    def __init__(self):
        self.suboordinate = None

    def append_suboordinate(self, suboordinate):
        self.suboordinate = suboordinate
        suboordinate.leader = self


04/25/19



04/29/19

So, the order of the Rules is significant when determining whether or not they'll trigger, which can be confusing for the player. For instance, if 'Invincible' is triggered before 'Hench,' Hench will not trigger -- because Hench will only trigger if the target_unit was going to do damage.

So, if Invincible triggers first, then the attack isn't going to do damage, which prevents Hench from recognizing that an attack was attempted.

That's fine. We can just word 'Hench's trigger condition as, "If an attack would have done damage, damage is doubled."

That's great, BUT, with our new and improved DynamicEvent report system, we can actually go back in time and see that an attack WAS attempted even if the damage is going to be absorbed.

So, maybe we should use that extra knowledge to make it more clear to the player what's happening.

If KreichJr has a rule on him that says, "If Vencabot attacks KReichJr, Vencabot takes poison damage." I don't want Hench to affect the poison damage. Is there a way, given our current DynamicEvent reporting system, that I can implement this?

What's the difference in DynamicEvents if Vencabot is dealing extra damage from Hench vs if he's dealing extra damage from Poison?

Well, actually, that should work fine -- because the extra damage from Hench REPLACES the original damage. The extra damage from poison ADDS NEW DAMAGE. So, that answers my question about whether or not the 'original event' can have a triggering_rule. The answer is "yes."

In the case of poison, the ORIGINAL EVENT would have a triggering_rule value.

GOOD NEWS! It seems as though our new Dynamic Rule System is fully functional -- not only insofar as being as feature-rich as it was before, but also such that we can implement all new kinds of rules and features (including custom error messages when a rule fails to trigger in a situation where a player might have expected it to trigger).

That means that, next time (Wednesday), we should go about experimenting with Rules that we couldn't have gotten working before, including Rules that are triggered when different Leaders get their turns, or even some example Rules where we maximize the complexity of our reports (DynamicEvent), which would be worded along the lines of:

"Vencabot gains HP when KReichJr triggers Persistence by attacking Zanzhu with Slap three times."

We need to find situations where we'd WANT to trigger Rules where, up to this point, we haven't been able to, such as:

On a turn change.
When a new Rule is added to the ruleset.



05/01/19

So, last night I was thinking about the way that our Rules are currently working, internally. Right now, they're split up into three main methods which can be overridden when defining a Rule:

'will_trigger_on' is a method that returns True or False depending on whether or not the Rule will trigger on a certain DynamicEvent.

The 'trigger' method is separate from that just so that we have some tidiness, internally. I think it's a bit nicer to be able to see, separately WHAT triggers a Rule and then what it does when it's triggered.

Finally, we have an optional 'fail' method, which is triggered only when will_trigger_on returns False. It can take the same DynamicEvent and return a custom error message (or animation or whatever) depending on WHY the Rule failed to trigger (especially in situations where the player may have expected it to trigger).

That's all well and good, but it strikes me that this rigid structure -- this rigid abstraction -- of Rules either "triggering" or "not triggering" -- this binary -- limits what we can do with our Rules.

For instance, what if I want to have a DynamicRule which gets more severe if a secondary condition is met.

Let's give an example:

Vencabot takes poison damage after every action he takes. If Vencabot is healed by another unit, the poison's severity increases.

So, in this case, we have a sort of double-decker Rule. It's "triggered" in two different situations, with two different results:

Vencabot takes an action. -> He takes damage.
Vencabot is healed by another unit. -> The poison's severity increases.

With our current mechanisms in place, perhaps the most sensible thing to do would be to split this over two different Rules.

But my thinking, last night, was that it would make sense to de-standardize the whole 3-method DynamicRule override.

Instead, we would have only ONE standard method, which would be called something like, "process_event". You feed it a DynamicEvent, and, instead of returning True or False, it will automatically call any number of methods based on the event that it gets.

That's much simpler. Although it would be nice to have a standard so that all Rules look the same, to some extent, it does sort of limit what we can do with our rules -- and that's been something that we've been butting our heads against for a long time, now. The balance between maintaining clear-to-read 'standards' but also keeping the 'dynamic' part of 'dynamic rule system'.

I think the best compromise would be to have Rules with this one standardized method, "process_event". Then everything else could be unique to that Rule.

But what I didn't think of, last night, was the possibility that we could split these complex Rules over more than one Rule. Right off the bat, I don't think this is the best solution, but I don't want to write it off until I consider the pros and cons thoroughly.

Pros of splitting complex Rules over multiple, simpler rules:
* We can keep the Rules internally standardized with a simple 'trigger' method. When it triggers, it triggers; it can't trigger in a variety of ways.

* It might be simpler for the player to read. It means that individual rules are easier to parse, and it's easier to understand what's going on when an action takes place because each summary of a rule is simpler.

Vencabot takes damage every time he takes an action. The damage is increased every time his HP is healed.

Vencabot takes damage every time he takes an action. (Poison)
Vencabot's Poison increases in severity whenever his HP is healed.

The cons of splitting complex Rules over multiple, simpler rules:
* It means that we need more Rules to describe what might be, conceptually, a single idea.

* It might add problems when we consider that Kenny and I have been working with different ways to balance Rules. The idea that I've settled on is to limit the number of Rules that a single unit can be subject to at once, and that means that, if we have multiple, simpler rules, we're gonna hit that limit a lot faster and may need to reconsider this as a balancing method.

* If we have Rules that are directly impacting Rules, we may need a way to communicate to the player exactly what Rule we're talking about. In the example above, we had to clarify that the first Rule is called 'Poison' so that we could later clarify that Vencabot's 'Poison' is what's going to be increasing in severity.



Much to my surprise, putting the pros and cons side-by-side makes me realize that there really isn't that big of a difference between the two options. Maybe de-standardizing Rules isn't as much of a benefit as I first expecting. I would say that the REAL difficulty with splitting complex Rules into simpler Rules is that it becomes difficult to decide how to limit rule-stacking on a single unit.

The way to deal with that would be to consider the SECOND Rule in our example ("Vencabot's Poison increases in severity when his HP is healed") to not be stacked on VENCABOT but rather to be stacked on the POISON -- as though Rules, themselves, could have slots where they take on other Rules.

Is that a more elegant solution? Maybe.

Before we go too deep down that rabbit hole, let's consider what I expected to be a standard feature of all Rules: 'trap' conditions and 'cure' conditions.

When we were discussing everything we could explore with the Dynamic Rule System, we talked about how, instead of just 'curing' or 'dispelling' a Rule using some kind of Final Fantasy'esque "Dispel" or "Remedy", Rules should be curable BY those but also by fulfilling conditions, such as, "5 turns pass," or, "Vencabot is swapped to the back row." It could be anything. It could be, "Vencabot's curse is cured when he's attacked 3 times." It could be anything. That would be a 'cure condition'.

'Trap conditions' would be situations where a Rule has NO EFFECT when it's put into play, but it would be THREATENING the affecting team by saying something like, "If Vencabot attacks 3 times, he'll become subject to poison for 10 turns."

In that case, we're limiting what Vencabot can do not BY inflicting poison but by inflicting the THREAT of poison.

So, one option, programming-wise, would be to standardize these 'trap' and 'cure' conditions as a part of the DynamicRule object.

But it was during my meditions about this that it struck me that perhaps it would make more sense to destandardize the DynamicRule object and allow each Rule to decide, on its own, how to process any given Event with any number of conditions and results.

Because, like I mentioned earlier, having a standardized 'trap' and 'cure' conditions doesn't cover the possibility of a condition that increases or decreases the SEVERITY of some effect. Maybe, under a certain condition, the TARGET of an affect is changed. Because these Rules are truly meant to be 'dynamic,' I feel like, to maintain the most freedom, we need to limit how much standardization we do between them.

On the other hand, one thing I've found in some of my previous projects is that, when you refuse to standardize a mechanism so that it can be as FLEXIBLE as possible, what you end up with is a situation where you actually have no objects or anything concrete. Things become so abstract that you're essentially just re-writing the language that you're composing your code in.

So, what we end up with is essentially two possibilities:
We allow for COMPLEX RULES which take a DynamicEvent and process it FREELY. We do away with the abstraction of the 'triggered' or 'un-triggered' binary and, instead, allow every Rule to do whatever it pleases with a certain Event. That seems reasonable, to me -- and powerful.

Or we could enforce SIMPLICITY on INDIVIDUAL rules, but have them be able to STACK ON EACH OTHER. So, considering things like 'cure conditions,' 'trap conditions', 'severity change conditions,' 'target change conditions' -- all of these things. You could stack them, as MULTIPLE RULES, like this:

Vencabot takes poison damage after every action he takes.
    - Rule is supressed until he attacks 3 times.
    - Rule is cured after he is attacked 3 times.
    - Rule changes target to whoever heals Vencabot.

All four of these rules can only trigger under a single circumstance and have a single effect. So, we can maintain the 'triggered' or 'untriggered' binary. It is quite simple to read. That's an advantage.

I'm starting to see that a problem with THIS mechanism is that, when you have Rules that change the effect of other Rules, it becomes difficult to know what order to process the rules in. How does the first sub-rule -- the trap condition -- suppress poison. For one thing, it wouldn't be written that way. It'd be written such that the Trap Condition is the PRIMARY RULE, and it later 'creates' or 'initiates' the poison rule.

But that doesn't really answer my question about Rules stacking on other Rules. Supposing that we do allow for Rules to stack on other Rules (which I think is very sensible), what if we had a Rule that suppressed another Rule until some condition was met. How would we go about doing that?

The most obvious way to suppress a Rule would be to simply give every DynamicRule a flag -- True or False -- which communicates whether or not it's suppressed. We definitely need more standard attributes for Rules, including their Severity level, which is a mechanism that I do want to be standard across Rules: the ability to raise or reduce severity.

We still have this problem of ORDER of operations when you're talking about Rules which affect other Rules.

I mean, maybe there is no problem there: maybe it's just first-come, first-served like we've been doing. I can't immediately imagine a situation where that would be a problem.

What's cool about THIS method -- keeping Rules simple, individually, but having them stack on each other -- is that it opens up a whole new class of unit abilities where we can manipulate existing rules. Like, we do want to have a class which could have an ability like, "choose a rule to suppress for 3 turns." That makes sense.

Maybe we want a class with an ability like, "change the cure-condition of a rule," or something like that.

I feel like, even if we have super-complex rules, we're going to need to allow rules to stack on rules, and we're going to need to STANDARDIZE some situations.

We can't get away with NOT standardizing things like TRAP CONDITIONS or CURE CONDITIONS, because we need to be able to have abilities which EXTEND trap conditions and SHORTEN cure conditions.

I would say that the MAIN disadvantage of splitting complex Rules into an arbitrary number of SIMPLE Rules is that it becomes a bit more difficult to convey to the player that this 'package' of Rules all conveys a single concept.

But, I don't necessarily think that's a big issue.

To clarify what I mean, I'm imagining a UI for the player to peruse to understand what Rules are in play in the current battle -- and, now that I think about it, this isn't a problem that's unique to 'rules-stacking-on-rules'. Our Dynamic Rule System IS so dynamic, by design, and creating a UI that makes it easy for the players to understand what Rules are in play is going to be a challenge.

Maybe, instead of going into too much code, today -- we've only got another forty minutes, here -- maybe we should begin musing about UI and maybe make some decisions about how this system is going to play out based on that. With DynamicRules being hypothetically so complex, what is an effective way to communicate what Rules are currently in play so that the player can make decisions effectively and understand the flow of battle.

Taking WORKING examples from the genre, you would TYPICALLY have STATUS CHANGES be AFFIXED to a UNIT. Usually, this is communicated with an icon over the unit's head and probably some entry on their 'status' page.

That's how you would handle traditional Poison, and Blind, and Protect, and all of these abstract 'status changes' which are one of the closest things to our idea for DynamicRules.

It's been brought up that DynamicRules also have some similarity to the 'Law' system in Final Fantasy Tactics Advance and its sequel. In those games, the only way to know what Laws are in play are by bringing up a special 'Laws' screen which just lists them, top-to-bottom. But it should be noted that this only works because Laws don't target any individual unit AND there's a very limited number of them per battle. You typically would have less than 10 laws per battle, and they're pretty easy to explain on a single line.

Let me propose an abstraction: CAN WE SAY that EVERY RULE has a TARGET? In the past, I've considered that, and I've usually just defaulted on, "No," you can't strictly say that every Rule has a target.

But maybe, if we think more about it, we'll decide that it isn't true. Maybe every Rule could be said to strictly have a target. That we could, in terms of UI, 'attach' that Rule to.

It goes without saying that some Rules target a specific unit. In our example above, "If Vencabot takes an action, he takes damage," it's clear that this Rule relates strictly to Vencabot. In a UI, we could definitely be forgiven for putting an icon over Vencabot's head or putting some kind of entry on Vencabot's status page that says that he's under the affect of this Rule.

If any unit heals another unit, a random unit on either team will die.

In the past, I've said that this kind of Rule would be said to apply to "the battlefield." So, if "the battlefield" has a status page, we could put that Rule there.

So, what are our targets?
A Unit.
A Battlefield.
A Party (leader?).

That seems fair. I don't think that there's any Rule that I could come up with that couldn't be said to target one of those three things. So, if each of those three things has a 'status' page, we could list the rules that are affecting them there.

If the Unit has a status page where you can view the Rules they're exclusively under the affect of,

And the Party has a status page where you can view the Rules it's exclusively under the affect of,

And the Battlefield has a status page where you can view the Rules it's exclusively under the affect of,

Then we can expect for the player to not have too much difficulty keeping track of what Rules are in play.

Not that we NECESSARILY need Rules this complex if it's going to fuck up our whole UI, but what about a Rule like this:

If Unit A (Party A) and Unit B (Party A) and Unit C (Party B) and Unit D (Party B) heal another unit a COMBINED NUMBER of 4 times, then Unit E (Party A) and Unit F (Party B) are killed.

That's a super-complex rule. It 'targets' 6 different units, split among both parties. I guess that would be a 'battlefield' rule, right? Or could it be said to be a Rule that essentially 'individually' targets those 6 units.

For balance reasons, this would probably need to be a Battlefield rule, and let's talk about Balance real quick.

A few weeks ago, it came to me and Kenny's notice that, by stacking a few VERY SIMPLE RULES, you can break this game -- like, super easily. The example we gave was something like this:

We have a 'priest' unit, and it's casting buffs on our team.

Vencabot takes 20% less damage from physical attacks.
Vencabot takes 20% less damage from physical attacks for 5 turns.
Vencabot takes 10% less damage from enemy units A, B, and C.

That all could hypothetically be cast in a single turn. And that's just one example. When you have as many ideas for DynamicRules and the abilities and classes that inflict them as we do, it stands to reason that breaking the game becomes trivial. Any time you can stack Rule A and Rule B on a single unit, you're risking breaking the whole game.

We'd developed this idea for WEEKS before this very simple revelation hit us.

A solution that we came up with, which I think is pretty elegant, is that we need to LIMIT THE NUMBER OF RULES WHICH INDIVIDUALLY TARGET ANY SPECIFIC OBJECT, whether it be a UNIT, a PARTY, or a BATTLEFIELD.

But there's more.

If we did that, STRICTLY, we have a problem where we have to start abstracting Rules as being either 'buffs' or 'nerfs,' which creates this binary that's contrary to the very idea of a Rule's dynamism. Because many Rules are going to have a very serious trade-off, like, "Vencabot does double damage but 1/4 is reflected back at him." Is that a buff or a nerf? I can imagine situations where that'd be inflicted on Vencabot by an ALLY and other situations where it might be inflicted on Vencabot by an ENEMY.

So, what we thought of was this: every kind of object can have a limited number of Rules inflicted upon it BY EACH PARTY.

So, Vencabot can only have one Rule inflicted upon him by his ALLIES and only one inflicted upon him by his ENEMIES at one time. The same would be true of each Party and the Battlefield; there's a limit to how much control EACH PARTY can inflict over each type of object.

This also solves the problem that we would've had regarding 'blocking' if we limited the number of rules that a single object could be under the influence of but we DIDN'T keep track of whether they were inflicted by an ALLY or an ENEMY.

For instance, let's say that we set a 'rule-cap' for each unit at 3 rules.

Well, on the first turn, the party inflicts three 'buffs' on Vencabot. Now, he's immune to 'nerfs' on the enemy turn. That's a problem.

So, intead, we limit the number of rules that can be inflicted on Vencabot by the ALLIES and the ENEMIES.

Speaking of UI, supposing that we're limiting the number of Rules, in battle, based on what object they're affecting, it's fair to say that you would peruse the current rules, in battle, by looking at various 'status screens' for the Unit, the Party, and the Battlefield. And maybe we could put icons over the heads of Units and, for the Party, an icon over the head of the Party Leader -- and, for the battlefield, icons in the corner in something.

I think that, UI-wise, it's not going to be a herculean task to keep track of what-all rules are currently in play. We can manage that.

To step back to our original question, then: yes, Rules can be said to have a specific target. And the three possible target-types would be "unit," "party," and "battlefield". And we would balance Rules -- and the whole Dynamic Rule System -- by limiting the number of Rules that any PARTY can inflict on any of those targets.

It strikes me that we have to add one more possible target type to that list: "unit", "party", "battlefield", and RULE. Because Rules can target other Rules.

SO, maybe we can even STANDARDIZE the SLOTS -- maybe not, but maybe -- that a given Rule has to entertain other Rules.

As a rough draft, a Rule could have THESE SLOTS for other Rules:

A 'cure' condition. This Rule will determine when the parent Rule falls out of play.

A 'trap' condition. This Rule will determine when the parent Rule comes INTO play.

A 'severity increase' condition. This Rule will determine when the parent Rule increases in severity.

A 'severity decrease' condition. This Rule will determine when the parent Rule decreases in severity.

It's a little bit abstract, but I think we would need some sort of wiggle-room for a Rule such as,

"Vencabot takes damage after every action he does. If Vencabot is healed, this curse moves to the unit that healed him."

For sub-rules like that one -- and probably countless others -- I feel like we can't really set aside a standard 'slot,' so maybe it makes sense for us to not have ANY standard slots for sub-rules. We just have parent Rules and sub-rules which affect that Rule. That makes more sense, because then we could have more than one 'severity increase' condition.

Lemme raise another abstract question. If Rules and Sub-Rules are the same object type, it stands to reason that sub-rules could have sub-rules attached to them. WOULD THAT MAKE SENSE?

Well, I would say that it makes sense for a sub-rule like, "If Vencabot is healed, his healer takes on this curse," could take on a sub-rule like, "Is cured after 3 turns." That's a sub-rule with a sub-rule DYNAMICALLY ATTACHED TO IT.

Okay, let's clarify one thing, here: sub-rules SIMPLY CAN NOT be SO dynamic and SO abstract that they can necessarily apply to ANY OTHER RULE. DynamicRules are objects which are invited to have their own, non-standard attributes, and we do want for sub-rules to be able to play with those... right?

What's an example of a DynamicRule which would need its own, non-standard attribute to do its job correctly, and can we make a sub-rule which affects THAT PARENT RULE EXCLUSIVELY which wouldn't work on other Rules.

"Every 3rd turn, Vencabot takes damage."

This Rule needs an internal counter for how many turns have passed since Vencabot last took damage from it. Very simple, but a necessary, non-standard attribute that this Rule instance needs to keep track of.

Now, what if we wanted a sub-rule like this:

"Slow Poison: Every 3rd turn, Vencabot takes damage."
"If Vencabot's HP is healed, Slow Poison takes affect every 2nd turn."

So now, we have a situation where the SUB-RULE is manipulating the PARENT-RULE in a way that wouldn't necessarily TRANSLATE to other Parent Rules. We could probably abstract this out so that, "If Vencabot's HP is healed, the severity of the parent Rule increases," which we could have wired up in Slow Poison so that, if its severity increases, it takes affect more often.

But that's just one example. I feel like it's safe to say that not every sub-rule is going to be able to apply to every parent rule.

So, what we NEED to do is decide on a LIMITED SET of UNIVERSALLY USEFUL attributes that EVERY RULE needs to take into account. That would maximize the dynamism of these relationships BETWEEN parent and sub-rules.

For instance, if every Rule has a TARGET, we can change that target. This and other considerations I've been making makes it clear that we're going to need to start TAGGING Rules so that we can understand how they work, at a glance, and match them up APPROPRIATELY with other sub-rules.

Every Rule has a TARGET, and it has a flag regarding whether its target is a UNIT, a PARTY, a BATTLEFIELD or ANOTHER RULE.

Every Rule has a SEVERITY LEVEL between 1 and 10. '1' would be 'barely taking affect' and '10' would be 'a very dramatic affect'. So, EVERY RULE would take into account its CURRENT SEVERITY when triggered. This way, we could dynamically change the severity of a Rule and have it play out in interesting ways.

We need a flag that defines whether or not the Rule is currently 'suppressed'. These Rules would be VISIBLE on a status screen because their suppression is TEMPORARY. It's visible, it's in-play, but it will not be triggered. We would neither either a 'suppressed' flag or an 'active' flag, depending on which boolean we want.

We need, like, a 'type' flag? To communicate -- for instance. Let's say that we have a Healer class which has an ability that can REDUCE THE SEVERITY OF A CURE-CONDITION.

Some Rules:
Vencabot takes 10 damage at every turn change.
    - Parent Rule is cured after 10 turns.

We would want a Healer class which could use an ability to REDUCE THE SEVERITY of that cure-condition. Boom, the priest casts a spell, and now:

Vencabot takes 10 damage at every turn change.
    - Parent Rule is cured after 3 turns.

We have reduced the severity of the cure-condition. So, for this Priest's ability to MAKE SENSE, we NEED to TAG the sub-rule with some kind of 'cure_condition' tag. We need to tag rules so that we understand how we can interact with them.

So, these tags SHOULD NOT NECESSARILY BE INDIVIDUAL ATTRIBUTES, because we're gonna need an arbitrary number of tags. So, we can use these tags, as a list, to give other Rules and Abilities an idea of how they can interact with each other.

This idea actually solves a problem I've been having for a LONG TIME about Rules, and that's kind of cool. For instance, let's say that you have a priest ability that says, "Cures Rules that deal HP damage over time." Up to this point, we've had no way of communicating, at the programmatic-level, which Rules "deal HP damage over time." Because that's kind of an abstract idea. For instance, what is "time"? When a unit takes an action? When a turn ends? Also, we really have no way of INTROSPECTING which Rules are doing HP damage.

The idea of 'tags' solves this: we can just tag Rules with, "deals_hp_damage_over_time," and then ANY ABILITY or ANY RULE which excusively targets Rules which deal damage over time now know that this Rule is an applicable target.

So, yeah, Rules need to have a .tags attribute where we can apply tags that other Rules and abilities can look for.

Also, Rules need a get_description() method. We could supply a .description attribute, as a string, but, because Rules are instances with attributes that might change over time, it makes more sense to get_description() and get a string back which might be different every time.

Let's talk about the direction of our coding for tomorrow:

Rules need some standardized attributes:
    .severity
    .is_active
    .tags
    .get_description()
    .target_type
    .affected_by

Instead of having a 'target' attribute, the Objects which ARE the targets have a list of Rules that are targetting them. The 'targets' that a Rule saves, internally, could be totally different from the 'targets' that it has, ABSTRACTLY, for the purpose of balance. But it does need a tag for what kind of target it takes, and that should be standardized.

BattleUnits, BattleLeaders, and Battles need:
    .affected_by (a dict of parties mapped to the Rules inflicted by them)
    .rule_limits (a dict of parties mapped to the int limit for that party)

We know that we're limiting the number of Rules that a single Unit can be under the effect of PER PARTY. Vencabot can be affected by two rules inflicted by Party A and two rules inflicted by Party B.

At this point, we should port our existing Rules to take advantage of 'severity'. Then, we need to start coming up with and testing sub-rules and situations where we're dynamically messing with severity and other attributes of Rules.



05/02/19

So, today I'm adding some new features to the DynamicRule objects. In particular, we're adding 'tags' and 'severity' -- and that means changing our existing test rules so that they take advantage of these new features.

So, first, let's go through our existing rules and implement severity, and then we'll test that.

A couple of problems just came to mind regarding the flexibility of rules.
    1.) Is it possible to record when a ability crits, for rules like,
        "If Vencabot gets a crit, he loses health."
    2.) Is it possible to record when a rule triggers, for rules like,
        "If Rage triggers 3 times, Rage is removed from the ruleset."

These are situations where we would need some kind of 'report' to trigger Rules that we haven't accommodated in our DynamicEvent system. DynamicEvents always and only record when an attribute is changed. That makes sense, for the most part. We could even use it to record turn-changes by having, like, battle.current_turn be a dynamic attribute.

But there are some situations, I feel, where it would make sense to trigger rules when an OBJECT ATTRIBUTE couldn't be said to be strictly CHANGING.

Like, can we change an attribute when getting a crit? Maybe. Sounds kind of hack'ish.

Can we change an attribute when a Rule triggers. Maybe. Sounds kind of hack'ish.

In the latter example, we could just standardize a mechanism where Rules record how many times they've been triggered.

Maybe. It's. Worth. Recording the EFFECTIVENESS of an ability when reporting on it for DynamicEvents.

Right now, DynamicEvents record quite a lot of data about the CAUSE of the event:

DynamicEvent.perpetrated_by : the UNIT who 'perpetrated' the attribute
                              change.

DynamicEvent.using_ability : the ABILITY that was used to change the
                             attribute.

DynamicEvent.triggering_rule : the RULE which was triggered by the ability.

So, maybe we just need another report attribute, "with effectiveness".

DynamicEvent.perpetrated_by
DynamicEvent.using_ability
DynamicEvent.at_effectiveness
DynamicEvent.triggering_rule

It seems reasonable, to me, to give every DynamicRule a counter for how many times its been triggered. When this number goes up, we can run other Rules which would trigger when that rule is triggered.

Time for some salty notes.

I just noticed that current DynamicRules aren't given a 'Battle' object as an argument upon instantiation. But, in a previous rant, I established that, just like with Abilities, every Rule must, by definition, have access to a Battle object -- because it needs to be able to change things in the battle.

Or does it?

I mean, Rules are given arbitrary arguments, right now. If a Rule needs access to a Battle, we can give it a Battle. None of our existing Rules require access to a Battle.

Which raises a question: is it okay for every Rule to take arbitrary arguments? I don't think that it's okay for ABILITIES to take arbitrary arguments, because they ALL NEED TO BE 'used' IN THE SAME CONTEXT. In the same way.

But Rules are 'initiated' during Abilities, so, in that 'use_ability' code, we can instantiate Rules however we please.

So, by that logic, Rules don't necessarily need to have Battle arguments and, furthermore, they don't necessarily need to have ANY particular arguments: their instantiation can be completely customized during 'use_ability'.

We're ending our game-dev stream, so let's take some notes about what we accomplished, today:

We enhanced both the DynamicRule and the DynamicEvent objects.

DynamicRules became, themselves, DynamicObjects, which means that when their 'severity' and 'triggered_counter' change values, they can trigger other Rules.

Also, we implemented 'severity' and tags and demonstrated that both are working. We created an ability, "Blood Song," which increases the severity of all rules in the current battle which increase attack power. We used tags to understand which rules raise attack power, and we made sure that these rules will give the target unit more attack power based on how severe the rule currently is.

We added a new report to our DynamicEvent objects, "at_severity". This records whether the 'with_ability' was Glancing, Normal, or Critical. Now, we can trigger certain rules based on whether or not an ability was a crit, such as, "Whenever Vencabot gets a Crit, he loses 10 health."



05/06/19

Today, I want to get Rules stacking upon other Rules. In particular, I want to play with 'cure conditions' and 'trap conditions'. I also want to implement a Rule which temporarily 'seals' or... what was the word I was using? Anyway, a Rule which can subdue other Rules for as long as it's active.

So, we're gonna have rules stacking on rules stacking on rules.

We still don't have a way for Rules to trigger on a turn-change, or 'on any action'. Like a poison that would trigger whenever a unit uses any ability.

I want to make a 'poison' which damages the target every time they use an ability. Then, I want to create a rule which subdues that poison until a certain condition is met.

Poison works. I want to make a new Rule which can SEAL ANY RULE for the length of 3 ACTIONS taken by Party A.

I want to make a new ability which inflicts this Rule upon the battlefield.

I'm gonna make a new ability called Seal Rule.

We have a conundrum. The abstraction of a rule being 'cured' isn't necessarily as simple as removing it from the rule list.

What about situations where a rule being 'cured' would change something attributes back to 'normal'?

Well, actually, that problem ISN'T a problem if you think about rules in the correct way. Rules always DO something when triggered, and they don't do anything if they AREN'T triggered. So, I'm looking at 'seal rule' entirely the wrong way.

Rules DON'T need an 'is_active' attribute. You don't seal a rule by making it 'inactive'. You seal a Rule by PREVENTING IT FROM DOING WHAT IT WANTS TO DO.

You can pretty easily do this by just checking the 'triggering_rule' attribute of a DynamicEvent. If the 'triggering_rule' is the target_rule, you need to prevent it from doing it's thing. So, for a Rule to be sealed by another Rule, the SEALING RULE would definitely have to come after the SEALED RULE in the rule-order.

But that stands to reason; if you're going to initiate a rule to prevent another rule from taking place, it would necessarily come after.

I have a conceptual problem that probably needs addressing. What if I wanted to have a Rule that is as follows:

All Rules which alter HP damage are ineffectual.

I don't know if that sort of Rule is possible with our current setup. Because, if Hench came after this rule in the rule-order, its effect could not be prevented.

You can't prevent a rule that comes later in the rule-order from altering a dynamicevent.

For the first time, we're talking about rules that target other rules, and I'm starting to see some unexpected difficulties arising.

Let's not worry about that for now, because we don't have time; that's a very abstract problem that we're going to need to put a pin in and come back to later.

##### RULES CANNOT PREVENT ANOTHER RULE WHICH COMES LATER IN THE RULE-ORDER FROM ALTERING A DYNAMICEVENT. ######

We can still 'seal' the effect of a Rule that was put into the rule-order beforehand. We just can't, right now, put a rule into play which will pre-emptively alter the affects of a Rule that's added to the ruleset later.

If we want to prevent the effect of a Rule, we have to look at the .triggering_rule attribute of a DynamicEvent and 'prevent' that event from occuring. It seems to me like there's two ways to do this:

1.) Prevent the change all together by doing:
    dynamic_event.replace_value(dynamic_event.__dict__[dynamic_event.attr_name], self)

That would disable the event by turning the NEW VALUE into whatever the value was ORIGINALLY.

But that's not necessarily what we want to do.

We don't want to replace the event's value with whatever it was ORIGINALLY. We want to replace it with whatever it was going to be BEFORE THE TARGETED RULE KICKED IN.

So, what we really want to do is step backward through the event's timeline until we reach a point before the targeted_rule kicked in and then replace the event's value with THAT value.

So, we need to do OPTION 2 if we can go back in time far enough that the rule hadn't triggered, yet.

We need to do OPTION 1 if we can't: the ORIGINAL EVENT was created by this triggering_rule.

I WANT THE OLD_VALUE OF THE FIRST DYNAMICEVENT WITH TRIGGERING_RULE TARGET_RULE.

I WANT ROLLED_BACK_EVENT TO BE THE FIRST DYNAMICEVENT WITH TRIGGERING_RULE TARGET_RULE.

I WANT TO STOP REPLACING ROLLED_BACK_EVENT AS SOON AS THE EVENT THAT IT REPLACES NO LONGER HAS TRIGGERING_RULE TARGET_RULE.

### OUR DYNAMICRULES NEED TO KNOW THE EFFECTIVENESS OF WITH_ABILITY. ###


When Vencabot uses Seal Rule, he does two things:
He adds a Rule to the Ruleset, "Seal Rule".
he adds a Rule to the Ruleset, "Fade Rule".

AFTER BOTH OF THESE THINGS HAPPEN, hang on... hang on...

Why isn't Poison triggering twice? Vencabot is effectively 'doing' two things in a single turn. Poison should be triggering twice. I don't WANT it to trigger twice, but I just realized that there's a bug that should be causing it to trigger twice. Because it's NOT triggering twice, that means that our BUG has a BUG.

Nevermind. When we use an ability, we reset the recurrence_counter AFTER the ability is complete. So, Poison CAN'T trigger twice in the time between when an ability STARTS and when an ability ENDS.

WHEN VENCABOT USES SEAL RULE, HE DOES TWO THINGS:
HE ADDS A RULE TO THE RULESET, "SEAL RULE".
HE ADDS A RULE TO THE RULESET, "FADE RULE".

AFTER BOTH OF THESE THINGS HAPPEN, POISON TRIGGERS. no, no, no. Poison only triggers after the FIRST event, which is Seal Rule being added.

Vencabot takes Poison Damage.

AFTER THAT, we add Fade Rule.

So, the solution to this problem... I'm not sure that "solution" is the right word... but we could make this behave the way we expect by stealthily adding 'Seal Rule' and then overtly adding 'Fade Rule'.

But actually, the thing to do would be to add them both, overtly, but at the same time.

So, the reason that I decided to add them both overtly, INDIVIDUALLY, is because, when you have a Rule that's triggered whenever a Rule is added to the ruleset, you would expect for it to trigger twice if more than one rule is being added.

But, in this case, CONCEPTUALLY, the rules ARE being added together. So, I'm going to add them both at ONCE, overtly. This would trigger rules that occur whenever a rule is added. If that rule really wants to trigger once for every new rule, it can check, itself, how many rules were just added.

So, the solution is to add both Seal Rule and Fade Rule at the same time.

Everything's working fine. Next time, I want to try to implement THIS rule:

"All effects from Rules which alter HP damage are negated."

That's going to be a challenge.


05/15/19

Back from Texas Showdown. It's been about a week since we last did any programming. Let's first of all create a new text document to contain our 'test abilities'. In the past, we had all of our 'test rules' within the main 'rules_and_events.py' module, but they become so complex and numerous that it made more sense to separate them out.

Now, we're sort of in the same position for Abilities. They're taking up a lot of space in our rules_and_events.py module, so why don't we move them to their own module just to make things a bit tidier.

Why did we decide that Abilities shouldn't be instantiated? I think it was just because we wanted to avoid the problem of 'redundant references,' which is something that I decided was important to the sanity of our architecture. It makes me wonder if the benefits of going with instantiated ability classes would outweigh the problems caused by redundant references -- or even if there's some way that we could implement ability instantiation without needing to rely on redundant references.

What if we reversed the hierarchy of our object tree? Would that make the problem of 'redundant references' a bit easier to deal with? Like, what if, instead of the 'battle' object having parties and the parties having units, we just had a bunch of loose units and THEY had parties and the parties had a battle.

The reason why it's difficult to implement a Rule like "All Rules which damage HP have their effects negated" is that a Rule can only 'prevent' or 'roll back' an event which is triggered BEFORE that Rule is checked.

So, it'd be trivial to implement a Rule like:
"All preceding Rules which damage HP have their effects negated."

However, inhibiting event-updates that occur AFTER a given rule in the ruleset might be impossible with our current mechanisms.

They have to ALTER HP damage -- not inflict HP damage. Stopping a NEW event, such as damage infliction, is trivial. Stopping an ALTERATION is much more difficult.

But why is that, necessarily? Can we make Events into DynamicObjects so that updating them can trigger rules...? That immediately seems like a bad idea, but maybe it isn't that bad.

Like, it makes sense for DynamicRules to be able to trigger whenever damage is altered. That makes sense, to me. But I feel like we're getting so meta that there's gonna be some weird difficulties that arise from trying to do something like that.

I feel like this would require a re-imagining of our DynamicEvent system, but maybe that's for the best. Maybe this cause is worth fighting for. On the other hand, I really like our current DynamicEvent system -- where you can sort of walk back in time to find the previous versions of events. Could we somehow do both...? Maybe not.

Well now wait a minute. Maybe all we'd really need to do is make DynamicEvent a DynamicObject and then... do:

my_event.update("replaced_by", new_event, etc., etc.)

That would effectively trigger rules whenever an event is replaced. That's what you want.

Before we commit to this notion, let's examine whether or not there are any other benefits -- or pitfalls -- to making DynamicEvents into DynamicObjects.

DynamicEvents are pretty immutable. The only attribute they have which is ever meant to change is 'replaced_by'. Would it make more sense to have some kind of external, 'timeline' object which is just a list of the event's progress? I think that would make a lot more sense.

my_event.timeline = [self]

and then, when you use my_event.replace_value(new_value, triggering_rule)

And then, whenever we update the timeline, we can get the newest version very easily.

Well, no, no, no. That defeats the purpose of what I'm trying to accomplish, here. The idea would be to make the timeline a DynamicObject so that the DynamicEvent could be immutable. Is that something that we could accomplish or that we'd want to accomplish?

If we were to make a 'timeline' into a DynamicObject, would it really have any other attributes that would be interesting to see?

We would never subtract an event from the timeline. Also, let's consider whether or not we really need to know the entire timeline of an events alterations.

This is where things are going to get really abstract and probably where we're going to end this stream so that we can play some 3rd Strike.

Would it make more sense to just have an 'original event' attribute and not worry about a whole timeline. Would any Rule really benefit from being able to see the entire timeline of an event's changing? So far, we've used the 'original_event' attribute to understand what the event was SUPPOSED to do. And, of course, the most up-to-date version of the event is what's going to actually END UP HAPPENING.

Are the events in the middle actually worthwhile?

Yeah, they are. And here's why:

We have a Rule which says, "If Vencabot was going to do 10 damage and that damage is negated, he gets pissed off."

We have another Rule which says, "If Vencabot is going to do 3 damage, he'll do 10 damage instead."

Vencabot slaps dixxucker for 3 damage.
So, he's going to do 10 damage instead.
But Dixx is invincible (as you'd expect), so Vencabot does 0 damage.

Our first Rule sees that Vencabot is going to do 0 damage. It checks the ORIGINAL_EVENT to see if Vencabot was going to do 10 damage, but he was only going to do 3 damage, so Vencabot doesn't get pissed off.

That's a bug.

We need to be able to see the ENTIRE TIMELINE of an event's alterations in order to understand that Vencabot was going to do 10 damage but the damage was negated.

And what's cool about this is that it works with any number of rules. We could have a situation like this; here's our ruleset:

If Vencabot is going to do 3 damage, he does 10 instead.
If Vencabot is going to do 10 damage, he does 5 instead.
If Vencabot is going to do 5 damage, he does 2 instead.
If Vencabot is going to do 2 damage, he does 0 instead.

So the final result is that Vencabot does 0 damage, and he was originally gonna do 3 damage.

But we can LOOK THROUGH THE TIMELINE of alterations to this event to see that, AT SOME POINT, he WAS going to do 10 damage. And in the end, he did 0 damage. So we can surmise that, "Vencabot was going to do 10 damage, but that damage was negated."

We do benefit from having the entire timeline at our disposal when it comes to investigating an event to see if a Rule should trigger.

Soooo... Now that I've realized that it makes more sense to have a 'timeline' object, as a List, than to have this tree of "replaced_by" and "replaces" attributes, we should make DynamicEvent into a DynamicObject so that, whenever an event is UPDATED, we can trigger rules to examine that update. Okay.

We'll do that next time. Now, it's time for 3rd Strike.

Tomorrow is going to be quite a big overhaul. Maybe even worthy of moving to mock-up version 5? Before we move to version 5, it might be worth re-examining the hierarchy of our battle objects.

Right now, we have a hierarchy like so:

         Battle
            |
         Leaders
            |
       BattleUnits
            |
        Abilities

I went through a lot of work in mockup version 4 to eliminate what I call "redundant references," which is to say that the hierarchy should only go one direction. For instance, the Abilities do NOT know who their owner is. The BattleUnits do NOT know who their leader is. The leaders do NOT know what battle they're a part of.

The problem with this is that abilities are really dumb. They're never instantiated, even, so we need to feed them all of the information that they require to do their job, including the perpetrator (their owner) and the battle that they're being used in. Also, it means that, INTERNALLY, there's no logic that limits a unit to using only the abilities that it 'knows'.

That's not a major problem, but it's sort of an aesthetic problem with the architecture.

Originally, we were fucking around with having abilities be INSTANTIATED, and then, of course, they could have an attribute which would point toward their owner -- among any other number of attributes.

There really are a lot of advantages to having abilities be instantiated. For instance, they could gain EXP and level up over time. They could have special qualities, such as, "If 'Slash' is used 3 times, it'll be gauranteed a crit." Right now, doing something like that would rely on having a Rule in play -- and that's consistent, at least, but maybe a little bit overkill for something that simple.

On the other hand, if we're not keeping a reference to the ability's owner, it seems like an architectural misstep to necessarily make abilities instantiated.

So, what if... it made more sense to turn the hierarchy UPSIDE DOWN.

     Abilities
         |
     BattleUnit
         |
    BattleLeader
         |
       Battle

Whenever we take measures to avoid 'redundant references,' we're going to have to do some SEARCHING for the objects that we want to find. If we just let the objects reference EACH OTHER, up AND down, it really minimizes the searching that we have to do. I just hate redundant references because of the architectural ugliness that you get from every object being able to directly reference every other object. The 'state' becomes way too entangled. So that's not an option for us.

Right now, with the hierarchy being 'rightside up,' the searching is pretty minimal.

For instance, if an ability is going to target 'the entire enemy team,' we need to look at the perpetrator and then iterate through all of the battle's leaders to see which team they're on.

Once we know what team they're on, we need to iterate through the leaders to find the one that ISN'T that team's leader.

Then, we can afflict every unit on that leader's team.

When I say 'searching,' I mean that we're literally iterating through some lists to find someone in particular that we're looking for -- instead of just KNOWing who they are (having a reference to them directly).

I feel like, if the hierarchy were 'upside down,' we'd have much more searching to do, right? But let's consider WHO is doing the searching.

The UI is doing the searching. It's when we want to TARGET somebody or something. Once we know who are target is, yeah, we have a direct reference to them. So, what sorts of things are we targeting, and how is our UI behaving. Let's examine these ideas real quick.

The UI behaves like this: we have two units in the 'ring', and, when it's your team's turn, you can use an ability from that UNIT or from that LEADER.

So, the UI has a reference to the 'battle' object, but the battle object doesn't know shit anymore if we're upside-down. So... that seems weird.

I guess what I'm trying to do is limit the number of arguments that we need to pass whenever a unit is using an ability. Right now, because I don't want for the ability to know who's using it -- as an attribute, I mean -- we need to pass a TON of arguments to these abilities in order for them to do very basic tasks.

If I want Vencabot to heal Lucian, I need to pass not only Vencabot AND Lucian to the classmethod, but I also need to pass a reference to the BATTLE object. In the case of 'Vencabot's healing ability,' both the PERPETRATOR (Vencabot) and the BATTLE are pretty much ALWAYS GOING TO BE THE SAME.

So it seems like a waste to pass them as arguments every time -- but the alternative is to instantiate the 'ability' and give it attributes including its perpetrator (Vencabot) and the battle. But, to comply with my design philosophy, if the ABILITY has a reference to VENCABOT, then VENCABOT can NOT have a reference to the ability. That's... sort of my thing right now. I'm trying to eliminate every situation where two objects have references to each other.

In the UI, when you're picking an ability to use and the currently selected unit is Vencabot, it makes sense to just say,

print all of the abilities from Vencabot's list of abilities

But, if Vencabot has a reference to all of his abilities, I'd prefer that his abilities not have a reference to him.

And this design philosophy results in this problem where I need to search through pools of objects to find what I'm looking for, because I can't just rely on a reference in many cases.

And for those who weren't here during previous streams, the reason that I've become hesitant to rely on 'redundant references' over the years is that they result in these situations and METHODS where you need to simultaneously and CONSISTENTLY update two attributes at the same time.

For instance, if the unit Vencabot knows who its leader is, WodoWiesel, AND WodoWiesel knows who's on his PARTY, we have to do something like this in order to add Vencabot to Wodo's party:

wodo.party.append(vencabot)
vencabot.leader = wodo

That seems really simple, but it gets out of hand REALLY quickly. Because the one time that you forget to do BOTH of those things, you end up with a horrifying bug. So what I've found is that it's better to only have the reference go ONE way. It seems to simply things but it means more PROCESSING when you're having to SEARCH the hierarchy for what you need rather than having a direct reference to it -- and it also means a lot more arguments.

         Battle
           |
   |-------|----------|
Leaders   Units   Abilities


The problem I see with this (and I'm sure it's because I don't fully understand Luthian's recommendation) is that neither the Leader nor the Units know who belongs to who. No, no, no. The Battle could have a map.

Ohhhhhhh, and then the Leaders wouldn't need to know their units and the units wouldn't need to know their leaders and the abilities wouldn't need to know their owners because the Battle knows all of that stuff, and the Battle is what you supply to the UI so that the player can actually make use of all of this stuff.

So, rather than giving each object a reference to whatever other objects it needs in order to work, we just have a separate object ("battle") which knows all of the relationships.

That makes so much sense. Not only does that simplify the relationships between the objects, but it simplifies the relationship between the UI and the gameplay. Because now you have this 'battle' object which sort of MANAGES the gameplay. It manages things. You could think of the individual objects below it (leader, unit, ability) as being like ARMS of the Battle which the Battle uses to do ITS job. And then, the UI interacts directly with the Battle.

So, in this case, it's not conceptually the UNIT which uses an ability: the battle uses an ability with some given units (a perpetrator and a target, etc.)

Before I call it quits, let me do some more thinking aloud to nail down where we're at, or where we wanna be:

To really understand the most effective way to internally structure our gameplay, we probably need to look harder at the UI and think about what sorts of things the player is really going to be doing -- so let's do that again and think about how we can apply Luthian's solution to that problem.

The battle's ring has two units in it who are fighting directly: one representative from each party, where each party has a leader.

So, when Party A completes their turn, we move to Party B. Here's what the UI presents us with:

A list of abilities that the Leader has access to
and
A list of abilities that the ring Unit has access to

When any of those abilities are selected, a target must be selected. An ability entails some character doing something to some character.

So, it's player B's turn. I want access to Leader B's abilities and the abilities of the unit representing party B in the ring.

The Battle could have a map of leaders (which represent parties) to their unit list. But that's the wrong way of thinking, already,  because we don't need to know the whole unit list. I need to know who's currently in the ring.

So, what I kind of need is a map of leaders (which represent parties) to their representative unit. Because, as player B, I can provide my leader. I have a reference to my leader, Leader B. I want to know who's representing my leader in the ring. Then, I can present a list of all of the leader's abilities and all of the unit's abilities.

Well kind of. Because that's still thinking that the leader and the unit have a reference to their own abilities.

So, here's what I'm thinking. The 'Battle' object has these attributes, all of which are maps:

our_battle.ring_units = # a map of LEADER to their representative unit
our_battle.teams = # a map of LEADER to a LIST of their units
our_battle.leader_abilities = # a map of LEADER to a LIST of their ABILITIES.
our_battle.unit_abilities = # a map of UNITS to a LIST of their abilities.

That's kind of sick. I feel like this one object knows EVERYTHING we need to know to make a complete player turn without the individual objects needing to know too much. That's one way to look at managing state.

Previously, I've tried to DIVIDE THE STATE into a bunch of portions that were AS SMALL AS POSSIBLE -- as a way to avoid having a bunch of objects which each had TOO MUCH ACCESS to the state.

But Luthian's alternative solution is to have as small a state as possible in ONE MONOLITHIC OBJECT and keep the state THERE. And then the individual objects have virtually no access to the state.

That probably makes more sense. If you're talking about simplifying the state, maybe the solution isn't to DIVIDE IT UP but rather to CONSOLIDATE IT. You have all of these objects which have their own little micro-states, but you have this one MANAGER which deals with the more involved aspects of the state. That way, you keep things simple. You don't have all of these complex interactions between objects.

I might try something like that for the version 5 mock-up, starting tomorrow. Because I've never used a design quite like that before, I'd be surprised if it was entirely smooth sailing, but I think it's definitely worth looking at.

So, tomorrow, mock-up version 5: we move as much of our state as possible to the 'battle' object. We update DynamicEvents to have a 'timeline' that, when updated, can trigger rules.





05/16/19

So, today we're beginning work on porting mock-up version 4 to mock-up version 5. In version 5, I want to focus on simplifying and empowering the relationships between objects by using a central registration or "management" object, whose entire job it will be to allow objects to reference each other.

Also, in mock-up 5, we're going away from DynamicEvent.replaced_by and instead moving toward a timeline mechanism where events register themselves in a timeline.

I don't know if I want to necessarily repurpose the existing 'battle' object as this registry or if I want to create a whole new object with a whole new name.

I'm kind of leaning toward the latter, because we need to consider that I'm re-engineering the way that I'm LOOKING at this code.

The idea of the 'battle' object was to organize objects into a hierarcy with the 'battle' at the top. Now that we're flattening things out, I don't necessarily feel like we need this idea of a 'Battle' at the top of things, where everything else occurs inside. Even if we DO need an object like that, I don't know if I'd want for THAT object to be the one that manages all of these relationships.

So, maybe we need another object whose job it is EXPLICITLY to manage the relationships between objects. Something like "BattleRegistry" or something like that.

Let's just do that, for now. We're going to make a new object.

What sorts of attributes would a 'battle' or 'battlefield' need if we have all of our relationships being managed by a third-party 'BattleRegistry' object?

We established that battlefields can have tags that may affect different Rules that are in play. I think that's really all they have, these days. The battlefield could have a 'ring' that's populated by one unit from each team, or alternatively the teams could just have a 'representative' as an attribute of that object.

We do want a Battlefield object, for sure. So, it can have tags. Does it really need anything else? Well, it can have slots for Rules to apply. We've talked before about how we want for objects to start having slots for Rules to occupy.

So, what have I really accomplished with this new object. Now, units don't know their own abilities, internally. Nor do abilities internally know what unit they belong to.

Have I made a terrible mistake? Do we really need this central registry to search for objects? I've been trying to avoid this problem of 'redundant references', and, in a sense, this registry does solve this problem: no two objects now have a direct reference to each other.

But we've sort of created another problem that I wouldn't have imagined, before: NO object has a direct reference to any other object. So we've solved the problem of having too many direct references by disallowing objects to have direct references to each other at all.

That seems sort of contrary to the spirit of OOP.

Like, does it make sense for a unit to not simply have a list called ".abilities" which contains all of their abilities?

Why should I need to ask some database what abilities this unit has. I can just give it an attribute that contains all of its abilities.

The reason why we strayed from that simple design is because it's so difficult to understand if the UNIT owns the ABILITIES or if the ABILITIES own the UNIT. Again, to solve that problem we prevented anybody from owning anybody.

But the reason that I'm really starting to backpedal on this 'BattleRegistry' object because I'm starting to see all of the design trappings that I was trying to avoid in the first place: we need these 'register' methods whose job it is to literally create redundant references. The only difference is that, now, all of these redundant references are housed within the same object -- which, admittedly, does simplify things a bit.

But the problem is that this simplicity seems like a small consolation for not just moving these same REDUNDANT REFERENCES out to their respective objects.

Like, if we're going THIS FAR into redundancy to make objects able to quickly 'search' for each other, why not just give Unit an 'abilities' attribute and the ability an 'owner' attribute? It's pretty much the same thing. It's just that this redundancy, in that example, is split up among multiple objects where-as, with this 'battle registry,' all of this redundancy is at least encapsulated within a single object.

I just feel like it's counter-intuitive. I feel like a Unit should have an attribute which is a list of the abilities it can use. Unit.abilities. Very simple, very obvious. Are we really accomplishing a noble ends by preventing all of these objects from seeing each other DIRECTLY.

Maybe the thing to do would be strike a middle-ground. Maybe we should not create units or abilities DIRECTLY but rather through some kind of manufacturer object whose job it is to manage these redundant relationships upon instantiation.

That doesn't seem like a real solution, because it creates chicken-or-egg problems. Do you 'manufacture' the ABILITY or the UNIT first? The idea would be to simultaneously connect them to one another, but that isn't reasonable.

On the other hand, if we can AVOID having a developer directly instantiate a class -- and, instead, have them 'manufacture' an object through some method I do think that we get more control over these 'redundant relationships'.

So, you could create a Unit and then the unit could 'learn' an ability. That was a solution that we had literally on day 1. In fact, let's go back to the day-1 code (if I still have it) and examine the trappings that we were trying to avoid in the first place.

Looking at the day 1 code, it seems to me that maybe the BIGGEST PROBLEM with redundant references ISN'T that you have two objects which directly reference each other and you need a method to manage that. Maybe the biggest problem is that you don't know which object to put that method ON. Because there is no hierarchy.

So maybe what we need, in the case of our chicken-or-egg example, is to have a delegating third party which can 'register' these objects to each other.

We would make the unit, and it would have no abilities, yet.
We would make the ability, and it would have no owner, yet.
Then, we would call: BattleRegistrar.register_ability_to_unit(ability, unit)

So, we don't have a third party object to MANAGE relationships. Instead, we have a third-party object to ESTABLISH relationships. That way, we don't need to answer the question of, "which object should have the method to manage their relationship". We just have one master object whose entire job it is to do that.

I kind of like that, but it suffers from the same problem that we always have with redundant-relationships: we can not allow the developer in question to directly manipulate some attributes, which is against the spirit of OOP and Python in particular.

For instance, if we make a unit and we make an ability and then run:

my_registrar.register_ability_to_unit(ability, unit)

We have to assume -- at the risk of INCREDIBLE BUGGINESS -- that no one will ever manually change ability.owner or unit.abilities . These attributes MUST be manipulated ONLY by the BattleRegistrar. They essentially become 'read only'.

But, on the other hand, is that such an extreme expectation? There's gotta be countless cases, in the real world, where manually updating an attribute will cause your software to bug out. If you're fucking around with some attribute of an object, maybe you have to expect that it's going to bug something out.

I'm going around in circles, man. I would love to simply REGISTER AN ABILITY TO THE GAME by saying unit.abilities.append(ability). That's my end-game. That's what I want.

I just don't think that I can accomplish that because the ABILITY needs to know who its OWNER is. That's the problem that we've been having since day 1. If I were a stronger, more educated programmer, I'm sure that I could think of a design paradigm that would solve this most basic of problems.

But there is no solution, right? Even I can see that. To make things as abstract as I can, we can very basically word the problem like this:

The unit must know what abilities it has access to.
The ability must know the unit that's using it.

If I want to just do:
unit.abilities.append(ability)

I can not inform the ability, at that time, the unit that it belongs to.

If I want to do something like, I'm going to need a method of some kind. 100%.

I don't want to override 'append' so that it tampers with 'ability' in some way, to tell it its new owner -- nor do I want to tamper with 'remove' so that it tampers with 'ability' in some way, to tell it that it now has no owner.

We NEED a method whose job it is to manage this relationship. This two-way relationship.

Kenny brings up the idea that we could just use 'init' on the ability class, and then it would change its OWN 'owner' attribute and tamper with its owner's 'abilities' attribute:

def __init__(self, owner):
    self.owner = owner
    owner.abilities.append(self)

But that's exactly the situation I'm talking about, above: in the most abstract of senses, if we're going to have two-way relationships -- for any purpose -- we're going to need methods to establish and manage those relationships. We can't just go raw, vanilla Python OOP and say something as PROFOUNDLY CLEAR as "unit.abilities.append(ability)". As much as I would like to, that doesn't solve the problem of giving 'ability' a reference to 'unit'. It gives UNIT a reference to ABILITY, but it doesn't give ABILITY a reference to UNIT.

And we've been spending weeks asking so many questions like, "well, does ABILITY really NEED a reference to 'unit'." That's why, in mock-up version 4, our abilities are just Classes that never get instantiated, and they always take their 'perpetrator' or 'owner' as an argument to all of their class methods. Because we couldn't give 'ability' an 'owner' attribute by using unit.abilities.append.

So, our solution was to go in a more FUNCTIONAL direction, and just have abilities which have no attributes and when you want to use them you need to supply a fuck-ton of arguments.


class Unit:
    def __init__(self):
        self.abilities = []

class Slap:
    def __init__(self, owner):
        self.owner = owner

my_unit = Unit()
my_unit.abilities.append(Slap(my_unit))



my_unit = Unit()
my_ability = Slap(my_unit)
my_unit.abilities.append(my_ability)

It's still a two-step process, even if you use syntax to condense it onto one line. The thing we're trying to avoid is a situation where a developer establishes ONE HALF OF THE RELATIONSHIP without remembering to establish the SECOND HALF of the relationship.

In the example above, when we instantiate 'Slap' as 'my_ability', my_ability now has an owner: my_unit.

At that point, though, my_unit does NOT have slap as an ability. Slap has my_unit as an OWNER, but my_unit does not have Slap as an ability. That's the nature of SO MANY BUGS that I've experienced in my years of doing OOP. This two-sided relationship where it's understood that both sides have an equal reference to each other when there is no mechanism in play to be certain that this is actually the case.

In the most abstract of senses, IF we're going to fuck around with equivalent two-directional relationships, we NEED some kind of intermediary method or function or even a class to establish these two-way relationships AND we need to trust that the developer in question will USE that intermediary and not just tamper with things directly.

And my profound frustration with that is that it means, when you want to append an ability to my_unit's ability list, you CAN'T just do:

my_unit.abilities.append(ability)

It seems like you SHOULD be able to do that, but, if you did, you would be breaking the game. You absolutely HAVE TO UNDERSTAND that, to append an ability to that list you actually need to do something like,

my_unit.learn_ability(ability)

Or,

my_ability.set_owner(my_unit)

That's where my frustration comes from: immediately, we're looking at 'setter' methods, which I fucking hate. When you SET SOMETHING in PYTHON you should just be able to do it with an assignment operator. We got 'setter' methods, now? Because we need to have side-effects when we're setting things?

So, I've been trying to make all of our relationships ONE-DIRECTIONAL in a strict hierarchy to prevent these sorts of problems, but this DEFIES the very design of our game. It looks nice INTERNALLY, but it's just as simple as the fact that the units NEED TO KNOW what abilities they have and there's no getting around the fact that the ABILITIES need to know who their owner is.

It's not a real solution to just go functional for the abilities and have the unit supply itself as an argument EVERY TIME IT WANTS TO DO SOMETHING WITH AN ABILITY. Like, if you're supplying the same arguments EVERY SINGLE TIME, that's exactly why objects were created. At that point, the ability might as well have a direct reference to its owner -- any time you want to do something with it, you have to supply owner, anyway. We haven't really solved any problem. All we've really done is save ourselves from having to use these methods to establish these two-way relationships. We can't deny that there is a two-way relationship there. We're just disguising as an argument.

So, before we end today's stream, let's enumerate our possible solutions -- like, for real. Let's just lay out the tools that I have access to, with my relatively limited programming experience, and decide which one is the most reasonable to go with:

SOLUTION #1: Just use vanilla Python and expect the dev to manually maintain these two-way relationships.

class Unit:
    def __init__(self):
        self.abilities = []

class Ability:
    def __init__(self):
        self.owner = None

my_unit = Unit()
my_ability = Ability()
my_unit.abilities.append(my_ability)
my_ability.owner = my_unit


SOLUTION #2: Establish methods to manage the relationships between objects.

class Unit:
    def __init__(self):
        self.abilites = []

    def learn_ability(self, ability_class):
        self.abilities.append(ability_class(self))

class Ability:
    def __init__(self, owner):
        self.owner = owner

my_unit = Unit()
my_unit.learn_ability(Ability)


SOLUTION #3: We could make all relationships one-directional and rely on arguments to convey information to lower-level classes / objects on a need-to-know basis.

class Unit:
    def __init__(self):
        self.abilities = []

class Ability:
    @classmethod
    def be_used_by(cls, user):
        print(user, " used the ability")

my_unit = Unit()
Ability.be_used_by(my_unit)


SOLUTION #4: We could take away all inter-object references ENTIRELY and have all of their relationships be managed by a manager object which can be searched to find anything you need.

class Unit:
    def __init__(self, manager):
        self.manager = manager

class Ability:
    def __init__(self, manager):
        self.manager = manager

    def report_owner(self):
        print(self.manager.unit_by_ability[self])

class RelationshipManager:
    def __init__(self):
        self.abilities_by_owner = {}
        self.unit_by_ability = {}

    def register_ability_to(self, ability, unit):
        self.unit_by_ability[ability] = unit
        self.abilities_by_owner[unit].append(ability)

    def register_unit(self, unit):
        self.abilities_by_owner[unit] = []

manager = RelationshipManager()
my_unit = Unit(manager)
my_ability = Ability(manager)

manager.register_unit(my_unit)
manager.register_ability_to(my_ability, my_unit)
my_ability.report_owner()


SOLUTION #5: All objects have their respective direct references to each other, but there's a manager object whose methods ESTABLISH those relationships. So, sort of a fusion between Solution #2 and Solution #4. In solution 4, we have this idea of a 'manager' object. And in solution 2, objects have direct references to each other and they're managed by methods. So now, we just export these methods to an object whose job it is to have these methods. This saves us the problem of having to decide whether Unit should have 'learn_ability' or if Ability should have 'be_learned_by'.

class Unit:
    def __init__(self):
        self.abilities = []

class Ability:
    def __init__(self):
        self.owner = None

class Manager:
    def register_ability_to_unit(self, ability, unit):
        ability.owner = unit
        unit.abilities.append(ability)

my_unit = Unit()
my_ability = Ability()
my_manager = Manager()

manager.register_ability_to(my_ability, my_unit)



In solution #5, the 'manager' doesn't contain a database the way that it does in solution #4. Instead, all of the relationships are more vanilla OOP: each object has a sensibly-named reference to the objects that it is closely related to and requires access to. However, the methods which establish these relationships do not belong to the objects, themselves: they belong to a third-party object / class / module whose entire job it is to establish these relationships. It's a 3rd party mediator so that we never have to ask the question of which object owns which object and should therefore have the method for managing the relationship.

Five solutions:
1.) Just manage two-way relationships manually.
2.) Give one of the objects a method which establishes the two-way
    relationship.
3.) Make all relationships one-way and use arguments when needed.
4.) Manage all relationships between objects through an intermediary
    instead of having objects own a direct reference to each other.
5.) Establish all two-way relationships through an intermediary, but allow
    objects to own a direct reference to each other.

Solution #1 isn't really a solution. I just included it for completeness. We don't want to manage all of these two-way relationships manually.

Solution #2 creates some chicken-or-egg questions. For instance, either a Unit can get a list of its Abilities upon instantiation OR an Ability can know its owner upon instantiation, but not both. So we have to be careful about the order that we instantiate things in.

Solution #3 isn't really a solution, either. We're gonna need two-way relationships, and to disguise them as arguments doesn't really solve any problem.

Solution #4 is a sensible solution except that it defies some of the basic principles of OOP by preventing objects from having a direct reference to each other when it would make a lot of sense for them to have a direct reference to each other. For instance, the 'manager' object knows which abilities belong to which unit, but the unit doesn't know what abilities it owns. Therefore, we can't have a my_unit.abilities list, even though that seems very reasonable.

Solution #5 may be the best of all worlds. It allows us to have a my_unit.abilities list, as you would expect -- and a my_ability.owner reference, as you would expect -- and it allows us to instantiate objects in any order. The real downsides are that it requires this bizarre, 3rd party 'manager' whose entire job it is to manage these relationships. It's basically no different from solution #2 except that having these establishing-methods outsourced to a 3rd party prevents us from having to worry about hierarchy or instantiation order. So, instead of saying, "my_unit.learn_ability(ability_class)", where my_unit MUST be instantiated first and we have to know, as a developer, that my_unit establishes the relationship and not my_ability -- instead of that, we get, "manager.register_ability_to_unit(my_ability, my_unit)," where the instantiation order doesn't matter and you don't need to know which of those two objects establishes their relationship, because NEITHER of them do.

So, I actually -- the more I talk about it, the more solution #5 seems like the solution that we want. Because you could think of this 'manager' object as being a sort of HELPER.

Because really, what we're talking about is solution #1: the developer is expected to entirely manage these two-way relationships on their own. BUT we have this HELPER class / object / module whose job it is to SIMPLY that task. That's what you want.

Okay, so, next Wednesday we're going to truly begin our version 5 mock-up using this design paradigm: vanilla-ass two-way relationships, but with a special manager object whose job it is to simply the establishment of those relationships.

We could call this object something to do with "introducing," right? It introduces objects to each other and establishes their relationships.




05/22/19

It's been a few days since we put any work into this project, and I'm sort of in a position where I'm going to need to rediscover it.

First, let's look at the significance of our existing classes -- outside of the progress that we've made so far -- and decide on what their purposes really are:

Battle objects include:

Battlefield
Leader
Unit
UnitAbility

The Units in our game represent the 'monsters' that the player is going to be collecting and adding to their team. These units have a variety of attributes that determine their effectiveness in battle as well as a library of abilities that they can use on their turn. They can also be subject to various rules -- either inherent to them ('Unit Dynamics') or which are inflicted upon them by their own team (buffs, probably) or by the enemy team (nerfs, probably).

The UnitAbilities represent the moves that a unit can use on their turn. These can have a huge variety of affects and costs, and they can have three levels of effectiveness which are randomly rolled for when that ability is used. Although we haven't implemented in any of our mock-ups, these Abilities will be managed into libraries that we've been referring to as 'classes' or 'roles'.

The Leader object represents the 'trainer' or the player character in this battle scenario. They have abilities that THEY can use (although we haven't implemented any in our mock-up, yet) including the ability to switch which unit on their team is currently in the ring. They also have attributes (especially 'AP', which determines how many actions can be taken on that party's turn) and also may be subject to certain rules. They have a list of units which represents their entire party. So, previously, we'd had 'leader' and 'party' objects, but I think it's pretty clear that we don't need both. Rather, the 'party' is just a list of units that's an attribute of the leader.

Finally, we have the Battlefield object which represents the current state of the battle. The Battlefield has a 'ring' which can be occupied by one unit from each leader's team. It also has properties and rules which may have an impact on every character in the battle.

So, with these abstractions, we still have some questions to answer when it comes to the turn-to-turn action of the battle. For instance, where do we save information such as whose turn it currently is? In an abstract sense, is it even important that objects at this level are aware of whose turn it is, or is that something that we should think more about as we develop the UI.

The more I think about it, the more I'm convinced that the turn-to-turn action or movement is inseparable from the notion of a UI. Because it implies a 'prompt', right? I mean... We could do something INTERNALLY without prompts that generates error messages when certain units and leaders try to take action when it isn't their turn? But that seems overkill. So, again, I feel like the idea of turn-to-turn motion, from battle start to battle completion, is dependent on some kind of battle UI. Perhaps it's the future UI classes which propel battle.

In terms of the underlying mechanisms, we have these 'Dynamic' classes whose purpose it is to handle the Dynamic Rule System, which is our game's central gimmick:

DynamicObject
DynamicRule
Ruleset
DynamicEvent

DynamicObjects are just very basic extensions of Python's 'object', except that they have a method where you can reassign their attributes but while testing that update against a ruleset.

So, rather than manipulating a unit's 'HP' directly, you can choose to update it using the method 'update_w_rules', which will check the current ruleset to see if anything is supposed to happen before or after this unit's HP is updated.

One weakness of this mechanism is that it relies on attributes being updated in order for rules to be triggered. This has been effective for 100% of the rules that we've imagined so far, but it could be an issue when we would like for Rules to be triggered when some kind of action is taken by the player which, in an abstract sense, may not directly update any attribute of a DynamicObject.

For instance, if we want for all of a party's units to take damage when the leader ends the party's turn, I can't currently imagine a way to handle that.


05/23/19

We got cut off, last time, by a Comcast outage. Picking up where we left off, we're examining the weakness of the DynamicRule System, as it stands now, insofar as the only way to trigger rules is to update the value of some attribute of some DynamicObject.

For 99% of use-cases, this is perfectly fine. One situation that I can think of where this isn't going to work (perhaps) is when we want to trigger a rule like,

"When Leader A ends their party's turn, every unit on their team takes damage."

One way to hack around this would be to give Leader A (which is a DynamicObject) some attribute that counts the number of turns they've taken. Then, when that attribute increments, we could inflict damage to their entire team.

But the real reason that I mention rules like this is that I can imagine there being situations in our game where a certain action might have to trigger a rule without necessarily updating an attribute of a DynamicObject.

On the other hand, maybe that's not the case. Maybe we could just hack these sorts of situations using things like a "turn counter." In fact, a turn-counter might not be a bad utility to have in any case.

So... Yeah, maybe this isn't a huge problem. Maybe it does stand to reason that rules could be triggered using DynamicEvents.

But, before we go too far, today, let's reexamine the anatomy of a 'DynamicEvent' and decide how ugly it is or isn't to have all of these optional attributes. Let me show you what I mean:

class DynamicEvent:
    def __init__(
            self, target, attr_name, new_value, old_value,
            perpetrated_by, with_ability, at_effectiveness, triggering_rule,
            original_event=None, replaces=None):
        self.target = target
        self.attr_name = attr_name
        self.new_value = new_value
        self.old_value = old_value
        self.perpetrated_by = perpetrated_by
        self.with_ability = with_ability
        self.at_effectiveness = at_effectiveness
        self.triggering_rule = triggering_rule
        if original_event is not None:
            self.original_event = original_event
        else:
            self.original_event = self
        self.replaces = replaces
        self.replaced_by = None

Before we talk too much about these attributes, I want to point out that one of the core concepts of our version_5 mockup is that we're doing away with dynamic_event.replaces and dynamic_event.replaced_by and instead we're giving them a dynamic_event.timeline attribute, which is a list, organized from earliest-to-latest, containing versions of this same event.

So, what we really have are: target, attr_name, new_value, old_value, perpetrated_by, with_ability, at_effectiveness, triggering_rule.

With these 8 values, I've proposed that we can describe an event in the game in as much detail as we would ever need for Rules to do their job.

First of all, IS IT IMPORTANT THAT WE HAVE AN OLD_VALUE. old_value has no purpose in rules that take place in the 'before' phase, because we can just CHECK the old value of an attribute by looking at target.attr_name .

However, once we're talking about the AFTER phase, old_value does become significant because the target.attr_name has already been updated at that point. So the only way we can know the old value is to look at this attribute of the DynamicEvent.

Is that enough to justify its inclusion? Because, for 'before' rules, it really is redundant. I would say yes. This attribute IS justified because 'after' rules DO need it. The only alternative would be to have a whole different kind of object for reporting to 'after' rules, and it would basically be the same exact DynamicEvent as for the 'before' rules except that it includes old_value. There's no reason that we should make two different kinds of reports in this situation.

The most fundamental attributes of a DynamicEvent are new_value, old_value, target, and attr_name. With these four attributes, we can tell what attribute of WHO is being changed to WHAT. This allows us to trigger basic rules such as, "If Vencabot's HP goes down..." For a rule like that, we just need those first four attributes.

The latter four attributes examine the PERPETRATOR of this change, so that we can create more advanced regarding who DOES WHAT to WHO: perpetrated_by, with_ability, at_effectiveness, triggering_rule .

With these four attributes, we know the unit who USED the ability which instigated this change. We know what ability they USED. We know how EFFECTIVE it was (glancing, normal, or critical), and we know both WHETHER this update was implemented by a RULE and WHAT rule it was, if so.

So, this final attribute -- "triggering_rule" -- is the most bizarre of these report attributes. It's ONLY POPULATED if the change being made to the target's attribute was done BY A RULE. Otherwise, it's 'none'. If the change WAS instigated by a rule, then this attribute points toward that rule instance.

So, in example:

"If Vencabot gains attack power, a random opponent takes damage."

In that example, if Vencabot uses 'charge up' and gains attack power, it's going to cause a random opponent -- KReichJr -- to lose HP. When Kenny loses HP, we're gonna get an event like this:

Kenny's HP went from 10 to 7. This is because Vencabot used Charge Up at Normal effectiveness, triggering our Example Rule.

That's the entire report and is currently the most complex report that we're capable of generating, now. So, Kenny could hypothetically have some rule upon him which says,

"If Kenny is going to take damage as a result of Example Rule, that damage is nullified."

So, from that report, we can tell that, although the damage was, in a sense, triggered by Vencabot using Charge Up, it was actually directly inflicted by the rule Example Rule. So, in this 8-attribute report, we sort of get an entire picture of what instigated this change in Kenny's HP.

We can have very particular rules, this way. For instance, Kenny might be immune to HP damage from 'glancing' effectiveness attacks. Maybe Kenny takes 50% more damage from critical hits. Maybe if Kenny takes damage from a Rule which was triggered by a critical ability, he gains defense or something.

I think, all-in-all, this is a pretty tidy way to organize a report. If I had one hesitation about it, it would be that, in version_5, we're moving toward having Abilities be instances again, and they're going to know who their 'owner' is. As a result, perhaps we don't need both 'perpetrated_by' and 'with_ability'. If we know the ability which caused this update, we know who used it, right? I can hardly imagine a situation where an ability could be used by someone who isn't its owner.

The only situation where this could arise would be if some class did have the ability to use another unit's abilities, be it something like "mirror-move" in Pokemon or some kind of Blue Magic from Final Fantasy -- maybe a unit can temporarily steal another unit's abilities.

If that were the case, though, we could just temporarily instantiate a new ability for that unit, right? That's what we would do.

If abilities know who their owner is -- and supposing that all updates are being done VIA ABILITY -- we don't necessarily need a 'perpetrated_by' attribute.

But, that raises another question. So far, 'with_ability' has always pointed toward an instance of UnitAbility. But what about when a change occurs as the result of, say, a Leader ending their party's turn. What do we have, then, for "with_ability"? Because, outside of that sort of situation, we always have a UnitAbility to reference. Also, supposing that we include some sort of 'inventory' or 'usable items' that a Leader can use (at the cost of AP, probably) instead of having one of their units take an action -- what do we show for 'with_ability' then?

Well, the first thing to point out is that Leaders have 'abilities' that will behave ALMOST IDENTICALLY to 'UnitAbilities'. They may (or may not even) require a 'LeaderAbility' class, but they're capable of doing pretty much the exact same sort of actions as UnitAbilities.

LeaderAbilities can directly attack the opponent. They can buff an ally. They basically can do all of the things that UnitAbilities can do -- but more.

For instance, we might need a LeaderAbility to use inventory items. We might need a LeaderAbility to end the turn prematurely. We might need a LeaderAbility to flee from battle. The LeaderAbilities are more META, right...? But, for instance, I don't see any reason, really, why a Unit wouldn't be able to do all of those same things.

Why wouldn't we be able to have a Unit which has some ability like, "Uses an item from the Leader inventory with a 20% chance of keeping the item afterward." Why shouldn't we be able to have a Unit with an ability like, "Guaranteed critical damage but the party's turn will end."

So, that begs the question: what really is the inherent difference between a Battle.Unit and a Battle.Leader?

Well, Leaders have an AP attribute which determines how many actions their party can take in a single turn. In this respect, Leaders represent the limitations of the party as a WHOLE.

Also, I don't see any reason why a Leader should ever need to have an HP value. Based on the design that we've been sticking to since Day 1, Leaders (like Pokemon trainers) don't take damage directly. Now, in a game like Yugi-Oh!, the 'units' or 'monsters' act as a shield for the 'trainer' or 'leader' and, once all of the units are out of the way, the leader can take HP damage directly -- and the fight is over once the leader has been knocked out.

There's no reason that a leader COULDN'T have HP... It's just that, based on our design so far, we're going with a more traditional monster-collecting-JRPG style where, once all of the units are DOWN, the party is defeated. The 'leader' just stands there and cries about it.

In terms of THEMING, we've sort of described that, when the party is defeated -- just like in Pokemon -- there's the implication that the Leader FLEES and returns to the last safe spot in the game to heal or otherwise reconfigure their party. On the other hand, it could be kind of cool to give the leader HP so that they have the chance, maybe, to use an item to revive a party member even after the entire party is defeated -- and the party is only truly out of the fight once the leader has lost all of its HP.

Really, I'm not all about this 'leaders have HP' idea quite yet. For one thing, it means that, once the entire party is dead, a leader that has no way to revive their party would have to wait for the enemy team to kill them. Unless they just have some inherent 'forfeit' option.

The only REAL appeal that I see for Leaders having HP is that we could make them more uniform with the 'units'. It's sort of seductive to have these two tiers of units: both have the same types of 'abilities'. And both are subject to 'Dynamic Rules'. You could almost even have the player choose an ARBITRARY UNIT to be the leader of their party, which is sort of a trippy idea. Because it never really struck me, until now, just how similar Units and Leaders otherwise are.

As a NOTE, though. Leaders DO need to be balanced differently. They HAVE to be balanced differently:

The core combat gameplay of this JRPG is such that, although each team has 4 Units and 1 Leader, only ONE UNIT can take actions at a time -- the unit in 'the ring', similar to Pokemon. The exception to this, and where I imagine a lot of the game's strategy will come in, is that the LEADER can take actions at any time. And the Leader doesn't take damage.

So, you may have chosen to put a certain Unit in the ring, and now you have access to all of that Unit's abilities. At the same time, though, you ALWAYS have access to your Leader's abilities. So, using your Leader and Unit abilities in tandem is probably key to victory. And what's more is that the player is going to be able to choose from a variety of Leaders, which may have different abilities, which may better-suit different parties.

So, I'm kind of in love with that idea -- and that really does mean that Leader Abilities and Unit Abilities are FUNDAMENTALLY DISTINCT, even if, internally, MECHANICALLY, they are not distinct.

They're distinct in the way that we need to think about BALANCE, because a Leader Ability can be used AT ANY TIME, REGARDLESS of who's in the ring. So those Abilities really shouldn't be anywhere near as focused on directly dealing damage to the enemy party because we don't want for players to just have this Leader Unit, who's immune to damage, just carpet-bombing the enemy team. So, if a Leader has any ability to directly attack or directly buff or otherwise DIRECTLY TAKE PART IN the battle, those abilities need to be very limited.

UNITS ARE MEANT TO DIRECTLY PARTICIPATE IN BATTLE.
LEADERS ARE MEANT TO HAVE AUXILIARY ABILITIES WHICH GUIDE THE FLOW OF BATTLE?

Like, what traits do Leaders really have?

Again, they ABSTRACTLY REPRESENT the abilities that your team can use, on your turn, BEYOND what the ring-unit is capable of:

Using items.
Swapping ring-units.
Fleeing from battle.

All of these basic things that you would expect to be able to do regardless of what unit is in the ring.

Furthermore, different leaders will bring their own RULES into battle, making each leader distinct. Some leaders might have a property where their entire team gets a 15% boost to HP. Some leaders might have a property where their party's 'fire' attacks do more damage or something. So, they have these 'perks' or 'rules' or 'dynamics'.

So, recapping, Leaders, so far, are: generic turn-abilities, party-level dynamics, party-level limitations (AP).

Another thing that I've always imagined that Leaders would have is unique abilities. For instance, we've talked before about how the PLAYER is going to be able to choose their leader. Maybe one of the leaders has an ability to heal a unit's HP.

What this implies is that, REGARDLESS OF WHAT UNIT IS IN THE RING, this team ALWAYS HAS ACCESS TO A HEALING ABILITY. For that reason, the healing ability would need to be somewhat weak -- because we're talking about A HUGE ADVANTAGE, otherwise. We want for these leaders, whose abilities can be used REGARDLESS of what unit is in the ring, to have interesting abilities which can augment their party's strategies. But not necessarily DOMINATE their party's strategies.

In our battle system -- some of the people watching understandably haven't been here since day 1. Let's quickly review the very basics of our battle system.

Each team has 1 leader and 4 units. There are two competing teams.

Each team has 1 'point' unit which is currently "in the ring." Only the unit which is "in the ring" can take actions on that party's turn, along with the leader.

So, so far, exactly like Pokemon. In Pokemon, you have a trainer which can use items and flee from combat and switch Pokemon, and you have a Pokemon which is currently OUT OF ITS BALL and FIGHTING, and you have FIVE OTHER POKEMON which are on your TEAM but they can't be DAMAGED nor can they DO ANYTHING until they take their turn in the ring.

Our game is exactly like Pokemon in all of those respects. Yes, you have a team of FOUR UNITS, but only ONE of those units can act and only that unit can take direct attack, for the most part.

When describing the game's core mechanics, I've been pointing out the SIMILARITIES to Pokemon. The game's main deviation from Pokemon is that, unlike in Pokemon, your team can take MORE THAN ONE ACTION PER TURN.

In Pokemon, when your monster uses an ability, your turn is over and the opponent gets a turn. Likewise, if the Leader (trainer) uses an item or swaps a Pokemon, that also ends the turn.

In our game, when a monster ('unit') uses an ability, the turn isn't over. It just drains AP from the leader. Likewise, when the LEADER uses an ability, it also drains their AP. When the AP is completely drained, the turn is over.

So, unlike in Pokemon, in a single turn, before our opponent can act, we can have our Unit attack, be swapped for another Unit, and have that unit attack.

If our Leader has 10 AP at the start of a turn, our unit can use an attack that costs 3 AP. Now we have 7 AP left. We can swap for 3 AP. Now we have a new unit in the ring and 4 AP left. That new unit can attack, at some AP cost, and, by this point, our AP is probably too low to do anything else, and so our turn ends.

Even with this, we only have one unit in the ring to directly take damage and use abilities. Like with Pokemon, we have a team of 'back-up units,' but they aren't strictly 'in the fight'. It's not like Final Fantasy or Dragon Warrior or whatever else where you have an entire party of ACTIVE units. Only one of our units is active, along with the leader, at a time.

So, the REAL ADVANTAGE of giving our leader HP -- maybe the only advantage -- is that it would allow the leader to potentially stage a comeback after all of their units are defeated. Even if your final unit goes down, you would maybe have a turn to revive them, again.

Another cool advantage of having a leader with HP is that it could give us another abstract win-condition. Let's say that some unit has an ability which has a 1/10 chance to do some damage directly to the enemy leader. Now, the fight could be won before the enemy's party is even defeated. Maybe you could somehow directly attack the leader -- although this would have to be very rare.

It's kind of a cool idea to have this secondary win condition. BUT EVEN THEN. It would be a whole 'nother balancing act to decide HOW MUCH HP a leader should have compared to a unit. Because, although they would both share the name "HP," they're not inherently similar. Because one is just a counter toward that unit being removed from battle and the other is a counter toward that entire party losing the battle. What we'd really be talking about is a sort of 'super LP.' We talked, before, about how units are going to have a secondary HP value called 'LP,' which represents their ability to get back up after being defeated.

When a unit's HP reaches 0, they can't act, anymore, and they lose one LP. When a unit has no more LP, they can no longer be revived. And we talked about how some rare moves or critical hits could directly damage LP even when that unit still has HP remaining. So, you could defeat a unit before even reducing its HP to 0.

We could sort of GO DEEPER and have a 'super LP' attribute which, when diminished to 0, causes that team to lose the battle. You could look at the leader's HP in that light, and, just like some rare attacks could directly damage a unit's LP, some other attacks may directly damage the leader's 'HP', which could bring the whole team closer to losing the fight.

In review of todays' notes:
    *) DynamicEvents currently have 8 attributes to communicate their event
       report: 4 representing the TARGET and 4 representing the
       PERPETRATOR. I would say these attributes are all that we need AND
       that we may be able to discard the perpetrated_by attribute if our
       with_ability instance knows its owner.

    *) We're examining the differences between Unit objects and Leader
       objects. How similar are they? How dissimilar are they? Although
       both have Abilities which, in the most abstract of senses, could do
       exactly the same things, those abilities need to be BALANCED
       drastically differently. Because a Leader can use their abilities at
       any time, regardless of who's in the ring, we need to think about
       their abilities much differently than we think about a Unit's
       abilities.

    *) Can or should Leaders have HP? If they did, it would move our
       'victory' condition from 'defeat every opponent on the enemy's
       party' to 'lower the enemy leader's HP to 0'. As with games like
       Yugi-Oh!, perhaps units can directly attack the leader's HP once
       they have no more units left. Maybe some rare abilities could even
       directly wound the leader's HP while they still have units on the
       field. What are the pros and cons of giving leaders an HP limit?

       Two main 'cons' are that, once all of the Units in the party are
       downed, now the Leader is awkwardly stuck waiting to lose the fight
       in many cases. This is sort of a minor problem. That's true of other
       RPGs and it hasn't been a major issue. The other issue comes with
       balance: if we have Leaders who have HP, and when that HP reaches 0
       the fight is over, there's this strategic depth that emerges which
       demands that some rare abilities can directly damage the leader's
       HP. Immediately, that begs the question: are these attacks too
       powerful. Does it diminish the strategy of the game if certain Units
       can just directly attack the leader (although it wouldn't be easy
       and would probably require crit)? How do Leaders heal themselves in
       battle? Is that a thing?

       Pros are that it adds this extra layer to the strategy, and that's
       immediately attractive. I like the idea of 'LP' on our units. If
       Leaders had HP, it'd sort of be an extension of that: a secondary
       route to victory. That's kind of cool.


05/27/19

It's a fresh week, and I'd say that it's a good time to take inventory of where we are in our project.

We're migrating over to a 'version 5' mock-up, which is bringing us back toward 'redundant references' -- where it's more important for each object to have SENSIBLE ATTRIBUTES rather than worrying about trying to keep objects from having direct references to each other.

Another big change in Version 5 is that we're moving away from DynamicEvent.replaces and DynamicEvent.replaced_by and instead our going with a list of events, which, in order, replace one-another, as DynamicEvent.timeline .

Last time, we did a lot of worrying about the real difference between 'Leader' objects and 'Unit' objects. How similar are they, really?

I think that we should go ahead and give Leaders HP. We could even give leaders MP. Maybe even Str and Def. In fact, is it possible for us to go back and look at what attributes Units have?

On second thought, no, let's not do that. Let's just focus on getting the Dynamic Rule System up-and-running with these Version 5 sensibilities. After that, we can worry about giving the objects all of their game attributes.

What arguments should be required to update_w_rules?

I feel like, ANY TIME AN ATTRIBUTE IS UPDATED, we should have a perpetrated_by object. Probably a with_ability and at_effectiveness, too.

But, what if a unit takes damage from poison when a turn ends.

Well, then the perpetrated_by would be the Leader unit and the ability would be 'end_turn' or whatever.

Should leader abilities be subject to effectiveness? Yes.

Should 'end turn' be a traditional ability? Maybe.

So, let's talk briefly about the way that battles run, internally. Last time, we talked about how, perhaps, battles can not -- or maybe 'should not' -- run without a UI. The UI propels the battle.

I was thinking about this, last night, and I'm not sure that's how I want to handle this. Perhaps battles could be coordinated INTERNALLY in some way and the UI just plugs into it.

So, if we were going to do this, how would we do it? How do we run a battle without a UI?

Basically, I feel like we do need some kind of 'battle' object to keep track of whose turn it is, for one thing. We had this problem before: if we have a 'battle' object, it seems as though we would need to send commands THROUGH the battle object in order for everything to register correctly.

For instance, if Vencabot, the unit, uses some ability and it brings his leader unit down to 0 AP. The battle's turn should go to the other team. Also, if Vencabot tries to act and it isn't his team's turn -- or he isn't the in the ring -- we would need some kind of failure. And that seems like a responsibility that should belong to some higher object.

It almost seems like it makes more sense to PLUG these objects -- units, leaders, battlefields -- into a GAME which RUNS, including some UI. How do we, for instance, automate a battle without a UI? Maybe we can and maybe we should. Yes, we would need some sort of 'battle' object to observe everything that happens and manage some things, but maybe that's for the best.

How much of these responsibilities can we attribute to the 'Battlefield' object? The Battlefield is subject to certain rules and attributes. When we talk about what units are in 'the ring', that could be an attribute of the battlefield or the leaders or both.

But one thing that the 'battlefield' should NOT know which the 'battle' object SHOULD know is whose turn it is. I feel like we need some kind of master object which records whose turn it is.

We've been stuck in a planning phase for a very long time. Some of our ideas are very abstract and difficult to implement. We're almost there to a point that we can get a playable version such that we can start seeing how the game behaves IN ACTION. We've been THEORIZING an awful lot, and I'm concerned that, once the game is playable, we're going to see that certain ideas that we've had are not going to be well-balanced or otherwise immediately FUN. We simply have to get battles working so that we can start to really see what our game needs to be more interesting and more fun. What sorts of ideas we may need to scale back. What ideas we could stand to explore more.

What if we have this 'battle' object, and it somehow manages battle. One thing that we ABSOLUTELY NEED a 'battle' object for is knowing whose turn it is. So, our battle has an 'active_turn' attribute which points to a Leader object. But what else does out 'battle' really need? And what does it really do?

Well, maybe it records win and loss conditions. Maybe, when some Leader reaches 0 HP, the Battle has some method which sends a victory or defeat message and divvies up EXP or whatever.

We could say that this 'Battle' object is the manager of the FLOW of battle. It handles turn transitions. It handles the start and end of battle. INTERNALLY. As something separate from the UI.

Perhaps, therefore, it should also handle Error messages. Nah, we should have error messages be per-object.

So, a focus of mock-up Version 5 is going to be having battles play out, internally, without a UI -- but to completion.

We were talking about what sorts of attributes would belong to the over-all 'battle'. We would need a ruleset, right? Or maybe not, because all of the DynamicObjects already know their own ruleset.

So, until we start giving Units and the Battlefield their own slots for rules, we don't need for the 'Battle' to have some special 'rules' value.

So, until we're ready to implement the 'Battlefield', we don't really need a Battlefield.

Right now, the Battlefield is basically just a vessel for rules and attributes that we have no purpose for, yet.

When we're talking about going back to 'redundant references,' we're talking in a major part about UnitAbility. Let's hash that out, first, and see what impact that has on our methods in our other objects.

Now that they're instantiated, do UnitAbilities need to be DynamicObjects?
 What sorts of rules would we want to trigger when an attribute of an ability is changed?

Well... abilities... can... maybe... gain EXP? Abilities can keep track of their own internal counters to change their properties. Including a counter which will prevent an ability from being used in some conditions.

Okay. UnitAbilities SHOULD BE DYNAMIC OBJECTS, just to be on  the safe side.

Let's say that we have an ability called 'gun'. And the gun can 'jam'.

Let's say that, when a unit uses 'Gun,' there's a 10% chance that it can jam -- and, when it's jammed, it can't be used anymore.

Maybe there's a rule on the battle (or on the unit) called 'unjamming' or something.

Basically, the rule can say, "If the Gun ability's 'is_jammed' flag changes to True, change it back to False."

So, we might need to know when an ability's attribute changes -- which means that it needs to be a DynamicObject.

Maybe it's sloppy that every DynamicObject has to have a reference to the 'ruleset'. Maybe instead of having OBJECTS BE DYNAMIC, we should have the Battle update these attributes and have the Battle be known by every object.

Because, in a battle, EVERY DYNAMICOBJECT SHOULD SHARE THE SAME RULESET. Right now, we're relying on the programmer to be certain that EVERY DYNAMIC OBJECT SHARES THE SAME RULESET. Maybe it would make sense for there to only be ONE reference to the ruleset and we update attributes THROUGH IT.

Right now, we update_w_rules like this:

target.update_w_rules(attr_name, etc.)

Maybe we need to do something like:

ruleset.update_w_rules(target, attr_name, etc.)

or

battle.update_w_rules(target, attr_name, etc.)

Of course, this relies on every dynamic object having a reference to the same BATTLE which is the same problem we have right now where every object has to have a reference to the same ruleset.

But it probably makes more sense to have every object have a reference to the battle that it's a part of, because then we can give those objects access to more interesting values than just what rules are in play -- including whose turn it is, etc.

I mean, we're talking about a LIBRARY CALLED 'BATTLE', where every object in it is meant to operate within a battle.

Maybe we should leave this for version 6, because, right now, we don't really fully understand what responsibilities this 'battle' object is really going to have. Yeah, let's just move forward with the traditional 'DynamicObjects'. We'll come back to this later; I think we're really onto something. I think that it makes more sense, in the long term, for every object to NOT have a direct reference to a ruleset. And, in doing that, we can get rid of the entire complexity -- the entire abstraction -- of this 'DynamicObject'. That makes sense to me.

We've fleshed out the Version 5 'battle' library, which means that, in our next session (Wednesday), we should have a fully-working battle, again. We're going to need to re-implement some test rules and test abilities, and we're going to need to implement the RelationshipHelper.

At that point, we should be able to start worrying about making a fully-working battle which even starts to throw errors if you try to do things that are impossible (such as using an ability when the unit can't pay the cost).

(Which strikes me: up until now, abilities GET USED and then their COST IS SUBTRACTED. The problem with that is that it allows abilities to be used even if the unit can't past the cost. Maybe abilities need some pre-emptive way to communicate how much they're going to cost? Some kind of can_be_used_when . I like that.)


05/29/19:

Would it make sense for the DynamicEvent to have a reference to the battle's ruleset so that we could implement methods like:

DynamicEvent.check_rules(), which runs the event through all of the current rules. That seems pretty tidy and it raises the question of whether or not we would even need DynamicObjects. If Events had a reference to the Ruleset, what else would even need a reference to the ruleset?

Some abilities would need reference to the ruleset to be able to add a new rule.

But, for instance, Leaders and Units and Battlefields definitely wouldn't need references to the Ruleset, anymore. We basically wouldn't need DynamicObjects.

In fact... Even if an ability was going to add a rule to the ruleset, maybe it would just target the 'battle' or something.

Okay... But here's the thing. Any time that a DynamicEvent is generated, the generating object needs a reference to the ruleset.

But what if only BATTLES COULD GENERATE DYNAMICEVENTS. Battles have a reference to the ruleset. And all of the objects in the battle have a reference to the battle they're a part of. I kind of like this LAYER OF ABSTRACTION, because it means that, again, every object in the game doesn't need a direct reference to the ruleset -- and, furthermore, it means that, when an object wants something to HAPPEN in the battle... it asks the battle to make it happen.

self.battle.create_event(target, new_value, self, effectiveness)

We'll save this for version 6, too. So, the main idea for Version 6 is to examine this "battle" object and have it replace the old idea of DynamicObjects and giving everything a ruleset.


Today, we got a lot accomplished in our Version 5 port. We've got the basic battle working again, but there are two major jobs left to be done:

1.) We need to port over ALL of the old Abilities and Rules.
2.) We need to implement the RelationshipHelper class to make it easier to create leader-unit pairs, etc.


05/30/19

I want to talk about moving away from 'DynamicObjects' and passing a 'battle' argument to the usage of a UnitAbility (or LeaderAbility, later).

Right now, all of our classes are DynamicObjects and they have an 'update_w_rules' method for altering their attributes against a ruleset. Therefore, all objects need to have a reference to the ruleset, which I think is a bit sloppy.

So, consider this:

Neither 'Units' nor 'Leaders' have any methods. Everything that they significantly 'do' in battle is relegated to their respective Ability classes. Therefore, you could think of Units and Leaders as being simple structures for organizing their attributes in an object-oriented way.

If we could move them away from being DynamicObjects, we could create an internal architecture that behaves like this:

Units and Leaders as organized data.

Abilities as motivators for action in our battle.

We have 'Battle' objects as the managers of battle, including managing the ruleset AND UPDATING UNITS, LEADERS, RULES, ABILITIES, ETC.

So, instead of, within an Ability, calling:

some_unit.update_w_rules("hp", new_value, etc.)

We would, in the ability, call this:

some_battle.update_w_rules(some_unit, "hp", new_value, etc.)

That would generate an event which would run through the usual 'rule' gauntlet.

Therefore, only one object would need a permanent reference to the ruleset -- the Battle -- and Ability.use_on would require an argument pointing toward the current battle.

That would minimize our references to the ruleset, and we wouldn't even need any permanent references to the battle. We could just supply the battle as an argument to use_on.

But what if we could simplify things even further by looking at the 'battle' simply as an event generator. What if the event had the methods for running itself through a ruleset, and we ran something like:

some_battle.create_event(some_unit, "hp", new_value, etc.)

That doesn't really many more sense than our other way of doing it.

So, we're pretty early in Version 5. Let's take tonight to translate over to this paradigm.


NOTE: In today's stream, we entirely moved away from the old DynamicObjects paradigm and, instead, created this 'Battle' object whose entire job it is to manage the 'dynamic' aspects of battle.

So, when you call an Ability, you give that method a Battle as an argument.

The Ability then uses that Battle's methods for 'updating' unit and leader attributes. The Battle, itself, generates and handles the DynamicEvents. Therefore, no individual object needs a permanent reference to the Battle or any Ruleset; instead, we just supply the Battle as an argument to any Ability that needs to 'do' anything.

This results immediately in some much cleaner code.

Next time, on Monday, I want to finish porting over the old test_abilities and test_rules to Version 5, and I want to implement the RelationshipHelper to shrink the overall size of our test_battle.py .

Also, we should change the name of battle.py to something less generic. We use 'battle' for a LOT of names, already, in all of our libraries.


06/03/19

New day, new stream. Right away, I want to focus on the RelationshipHelper whose job it is to marry objects together. Previously, to avoid having methods whose job it is to marry objects together, we attempted an architecture where every relationship was only one-sided: no two objects had a direct reference to each other.

Since then, I've decided that doesn't really suit the shape of our design, and so we're back to having objects that can directly reference each other -- which means that they need functions to effectively marry them together.

On the other hand, what I've decided to is to put those 'marrying' functions into a separate object. That way, we can keep things tidy and make it more clear, from a design-standpoint, that these functions aren't strictly necessary: they're just convenience functions.

Let's look at which objects need to be married together:

1.) When you make units, they take a leader as an argument. Then, you have to give the leader their party.

2.) When you make abilities, they take an owner as an argument. Then, you need to append the ability to the owner.

I think that's all that we have right now. So, what do our convenience functions look like:

A way to 'create' units directly onto a leader.

A way to create abilities directly onto a unit.

helper.create_unit_for(leader, unit_name)
helper.create_ability_for(unit, ability_class)

SIDENOTE: Although a lot of the responsibilities from the Ruleset have been moved to the new Battle object, we're leaving the Ruleset as the container for rules so that we can have an object to battle.update_w_rules against when we want to add or subtract rules. That way, we can have rules trigger whenever new rules are added.

So, ending today's stream, the RelationshipHelper seems to work, although it isn't saving us any lines. If it's saving us anything, in the long-term, it's in the way that it clarifies exactly what we're doing.

We're changing this rather impenetrable one-liner:

leader.party.append(Unit(leader, "Signopt"))

To:

battle.RelationshipHelper.create_unit_for(leader, "Signopt")

It's actually longer, but it makes it more clear what's going on: we're creating a unit into this party. It manages the arguments that the unit needs on instantiation.

This makes no sense. This method is pointless.

Will this RelationshipHelper become more useful as the relationships between objects become more complex? The whole point of this RelationshipHelper is to marry two objects together that need a reference to one-another that must be consistent.

For instance, we could very easily break our code in a way that's VERY DIFFICULT TO DEBUG if we did something like this:

a_leader.party.append(Unit(b_leader, "Signopt"))

I mis-typed ONE CHARACTER THERE. Now, a_leader has signopt on their party but Signopt thinks that its leader is b_leader. So, we have a broken relationship.

That's what the relationship-helper is supposed to manage:

battle.RelationshipHelper.create_unit_for(a_leader, "Signopt")

In that example, we don't risk that same bug.

I think, in the long-term, especially as the two-sided relationships between objects becomes more complex, the purpose of this relationship-helper is going to be realized.

For now, it's not really saving us any work or headache, but it's already
making things a bit more consistent.




06/05/19

I'm porting over the old 'seal rule' code. Seal Rule is supposed to UNDO the effect of a particular rule after it triggers. How is this going to behave, in practice?

Let's say that 'Hench' is sealed.

When Vencabot is attacked by Sirius, an HP change event is generated.

When Hench sees that Sirius is going to do damage to Vencabot, it doubles that damage.

Seal Rule gets a copy of ALL events that are being passed through the battle. It checks those events to see if they've been either CREATED BY or TAMPERED WITH by the sealed rule.

Then, it walks back through the event timeline to find a point before that event was tampered with by that particular rule.

My question is this: what if we have a situation where an event is tampered with TWICE before it reaches the check for Seal Rule.

So, if Sirius is under the effect of Hench and And One, he will do double damage and then ahve one damage added to his attack.

So, we have a bug. Because, if this updated event, after going through AndOne, reaches Seal Rule, Seal Rule will not recognize that the event was updated by Hench. It only looks at the most recent update, so it's going to see 'And One'. Not 'Hench'.

EVEN IF we walked back through the timeline to see if 'Hench' was ever triggered, how do we UNDO AN EVENT IN THE MIDDLE of this timeline? We can't. We would need to somehow REDO everything AFTER that mid-timeline event.

So this project is too ambitious for me to approach when we're already late for 3rd Strike.


NOTES FOR THURSDAY: We ported over (almost) all of the old rules, and we're going to test them tomorrow. We've tested Rage, Hench, and Invincible. After we're done testing Rules (which I don't think will take terribly long), we're going to port over the old Abilities (there weren't that many) and test those.

After that, we can finally start giving more attributes to units and leaders to better reflect how our game is actually going to play. We've been doing a lot of very BASIC tests to make sure that the Dynamic Rule System is behaving. Now that we're almost done with that, we can actually start to flesh out a real, working battle for our game. We'll hopefully be well into that by next week.



06/06/19

Today, we're going to finish testing the OLD rules from Version 4 and then see if we can get 'seal rule' working correctly, because, right now, it's totally bugged out -- and I feel like it's important to our concept that we be able to have rules like that.

I have a question. When we instantiate a Rule, we always need an ability that spawned that rule.

Nevermind. Let's just assume that, sometimes, rules are NOT spawned from abilities (they're inherent to the battle or attached to some unit), and so, whenever we check for a 'from_ability', we need to make sure that it's not None. We have to assume that it can be None.

But here's another question, then. Can we have DynamicEvents that trigger without a by_ability. The answer would appear to be 'yes,' because Rules, themselves, can trigger events. And Rules don't necessarily need to spawn from abilities.

So... can we say that DynamicEvents don't necessarily need to have a populated 'by_ability' field?

I think that we need to say that event.by_ability CAN BE NONE just as well as event.triggering_rule can be none. You could have both, or you could just have one or the other.

So, any time that I check for event.by_ability, I have to first check that it's not None.

Test what happens when a poisoned unit is invincible.

Okay, everything's working EXCEPT FOR SEAL-RULE. And I'm not sure how we're gonna get that to work. I thought we had it working, before, but it turns out that it was bugged all along. So, we need to reconsider the way that 'seal rule' works and re-implement it.

One thing that we can do... is look for when the sealed rule is triggered. But I don't think that, when the rule is triggered, we have any way of knowing what events were produced so that we can edit them.

But what if we did.

What if, whenever... an ability... is used... or an event is triggered... we somehow get a report of what events were generated.

Let's put that idea on the back-burner for now, because it would require reconsidering -- AGAIN -- some of the most fundamental ideas of how our game works.

Let's see if we can find a solution that fits better into the framework that we've already developed.

Dixx points out, "can we just check to see if the rule is sealed BEFORE applying it." That was my first idea for sealing rules, and it requires what's known in object-oriented programming as an "attribute".

That solution would involve giving EVERY RULE an attributed: "sealed". That attribute can return TRUE or FALSE.

By default, some_rule.sealed would return False.

If we use Seal Rule on it, then some_rule.sealed would return True.

We could then use this attribute to say, "It's time to run Poison. Is Poison sealed? True? Then don't run it."

The problem with this is that it requires STANDARDIZING the idea of a rule being 'sealed,' and there's many levels of rules being stacked on rules and affecting how other rules behave -- and we can't standardize them all. That's why I moved away from this idea of having a 'sealed' attribute. It's a bad precedent to set and I thought I had a better solution.

But, I'm glad that Dixx brought that up, because, SINCE WE LAST DEFINED 'SEAL RULE,' we came up with a new technology in our game called 'tags'. Back when we first conceived 'seal rule,' rule tags didn't exist. But now we have this standard ALREADY IN PLACE and ALREADY WIDELY USED and ALREADY KNOWN TO BE SUPER USEFUL.

The cool thing about TAGS is that they address the very problem that I just talked about above with 'standardization'. Tags don't need to be standardized.

Dixx's question is "what's the difference between attributes and tags," and it's an abstract difference that relates to the heart and soul of object-oriented programming.

So, basically, 'tags' is an attribute on rules:

some_rule.tags

And 'tags' is a LIST, and, by it's nature, a LIST is meant to be DYNAMICALLY EXPANDED and CONTRACTED. Things are all-the-time being ADDED TO THEM and REMOVED FROM THEM.

On the other hand, 'attributes' should almost always, whenever possible, be standard to a type of object -- in this case, a "rule". So, my big problem with adding 'sealed' as an attribute to rules would be that it would need to be an attribute of ALL rules and, if we made every 'affect' stacked onto a rule into an attribute we would end up with a ton of junk attributes on our rules that are very rarely used.

ON THE OTHER HAND, it makes perfect sense for us to ADD A TAG (because tags are a list) to a rule and then, when that rule becomes unsealed, we REMOVE THAT TAG. It doesn't suffer the same problem of 'standardization' as if we were to make it an attribute, where it would need to be on that rule all the time even if the flag was False.

In Python, you CAN check all of an object's attributes ESSENTIALLY AS A LIST, but it's meant for what's called 'introspection' or meta-programming and you don't want to fuck with that on a regular basis if you can help.

But let's move forward with the notion of applying a 'sealed' tag to our sealed rules and see how that affects our game.

We have other problems at play which would make it impossible for us to prevent a rule from triggering just because it has the 'sealed' tag. That wouldn't be impossible. It would even be quite reasonable -- but, again, it's a matter of setting a precedent that could become impossible to manage in the longterm.

So, the question really becomes this: CAN WE PREVENT A RULE FROM TRIGGERING WITHOUT LOOKING INTO ITS ATTRIBUTES (INCLUDING ITS TAGS) FOR A PARTICULAR FLAG.

The answer would appear to be 'no,' and that's exactly we had this 'rollback' system for Seal Rule in the first place.

You can't prevent a rule from triggering. It's gonna trigger if its trigger-conditions are met -- and we can't just make one of its conditions, "If I'm not sealed," because, again, the state of 'sealed' is just one of countless states that our game could end up requiring, and we can't just re-write every single rule every time we come up with a new state like this.

So, the question that we need to answer is CAN WE. UNDO. A SELECTED EVENT.

This is the problem that has haunted our development for the past few months that we've been doing this. This question always comes up and the answer is always "no." Often times we think that we have a solution, and it always ends up backfiring.

We've always found, consistently, that we can PREVENT rules from having an affect IN ADVANCE, but we can't come back AFTER a rule has triggered and UNDO it.

The problem, here, is the ORDER of the rules.

If I say, "Vencabot is poisoned."

"Now Vencabot's poison is sealed."

I can not prevent that poison damage because the sealing happened after the poison. But our game necessitates that.

Let's be real, though. The way things are engineered, now, I CAN PREVENT THAT POISON DAMAGE. 100%. I seriously can look at the damage event and say, "Was this damage generated or affected by poison? Then get rid of the damage."

The problem is finding WHEN, in the event's timeline, it was tampered with by the sealed rule and UN-TAMPERING IT. That's what's our current problem.

If we could KNOW WHEN AN EVENT IS UPDATED AND ATTACK ~THEN~, we could UNDO the event update. That would resolve the issue of us having to wait for the event to go ALL THE WAY DOWN THE ASSEMBLY LINE before it reaches us.

(And for the sake of clarity, I think I am going to use this 'assembly line' analogy more often.)

So, let's demonstrate out problem and think through it:

We have two modifiers for damage: Hench (doubles damage) and And One (adds 1 damage).

We want to seal Hench.

Let's see how the assembly line looks:

Vencabot Slaps Dixxucker for 10 damage (triggering no rules).
|
Vencabot Slaps Dixxucker for 20 damage (triggering Hench).
|
Vencabot Slaps Dixxucker for 21 damage (triggering And One).

At this point, at the end of our assembly line, we want to seal Hench.

I believe that this is something we can't do.

We can look through the timeline of this assembly line and we can SEE that HENCH was triggered in the middle.

But what we CAN'T SEE -- what we have no REPORT FOR -- exactly what And One did. And One happened afterward. We could easily roll back from where we were before Hench:

Vencabot Slaps Dixxucker for 10 damage (triggering no rules).

But we don't have a mechanism in place to then re-apply And One. It would make sense to roll back from Hench if Hench was the most-recent update to the event. The problem is that Seal Rule is occuring AFTER And One.

Maybe one solution would be insert Seal Rule directly after whatever Rule is being Sealed.

Seal Rule is a "before" rule. So, if it's sealing an 'after' rule, it can be at the end of the Before -- no, no, no.

If it's sealing an After rule, it needs to be at the START of the Before list.

If it's sealing a Before rule, it needs to be directly AFTER the rule it's sealing.

That's solution 'A': selectively position 'seal rule' in the rule list. Change it's place in the assembly line so that it always directly follows the rule that it's sealing.

Solution 'B': what if DynamicEvents were effectively DynamicObjects... and we could run Rules when the EVENT is updated.

Like, what if, when you run dynamic_event.replace_value(), it runs the new event through some 'meta rules' list.

That's kind of tidy.

We'll implement one of those two solutions next time. We gotta play third strike.

06/10/19

Solution A isn't a SUPER SOUND SOLUTION because it RELIES on the fact that the 'seal rule' always directly follows the rule that it's sealing. If it were to be moved around for ANY REASON, it would not only cease to work but would cause bugs.

The problem with the 'meta rules list' idea is that these special 'meta rules' would need to take a different shape of 'event' compared to normal rules, and I'd like to keep things standardized.

We could use battle.update_w_rules(some_event, "new_value", so-on and so-forth)

I guess the thing to do... would be... to change the 'replace_value' method to call battle.update_w_rules.

But, for that, Events would need to know the Battle they're a part of.

I don't see any reason why they shouldn't.

It'd be impossible to call update_w_rules on some_event.new_value, because 'new_value' never changes. Instead, we update the timeline. The timeline is the only mutable attribute of a DynamicEvent.

So, we would need to call battle.update_w_rules(self, "timeline", so-on-and-so-forth)

It seems to me that we now have a mechanism where, whenever an Event is updated, we can run some rules.

So, that changes the way that we can look at how 'before' rules work. Now, they can directly target a situation where a rule has altered an event.

Before we get 'Seal Rule' working, let's go back through our existing Rules and see if we can't change how they behave to take advantage of this new mechanism.

We've got a problem. We can't update the timeline to be a brand new list because we rely on the identity of the old list to keep all of the events in the same timeline synchronized.

I could make an EventTimeline object whose only purpose is to store a list as an attribute. That way, we could update the list while still having an identity to point all of the Events to. I mean, that would be a quick-and-dirty solution.

I like it, honestly. I like it because, if we're gonna have a DynamicEvent that gets generated whenever a timeline is updated, the architecture should reflect that.

Right now, we're saying:

"This event's timeline is being updated."

But, really, all of the events share the same timeline. So, that's deceptive. That could be engineered in a way that's more clear.

If we have an EventTimeline object, we can say:

"This timeline is being updated."

That's more clear, anyway.

Seal Rule is now triggered when:
    A DynamicEvent is fed in where a Timeline is being updated.
    If that Timeline is being updated by the sealed Rule:

Then what do we do?

For one thing, we could just PREVENT THE UPDATE. That's the easiest thing to do.

The problem with this is that it doesn't leave a paper-trail.

BUT IT DOES.

We just need to. Roll back. The event. It does leave a paper-trail.

Wait, wait, wait. Are we gonna end up having the same 'order of operations' problem that we always have?

I wanna say "no," because now we have this new vector of attack -- this DynamicEvent which targets the timeline. Now, we have a whole extra dimension to examine what's happening in our game. Because we can look at a timeline of timeline changes.

I want to roll the timeline back to what it was before this rule was triggered.

I feel like we're coming up on the same 'order of operations' problem.

We've had this problem since day 1 of this project, literally: "how do you roll back an event." "How do you prevent a proposed change from triggering."

How can I verbalize this problem?

KReich slaps Vencabot.
KReich is Hench.

The Slap proposes a HP change of -10 to Vencabot.
Hench sees this event and proposes a new event -- a timeline update -- where the HP change is -20.

Seal Rule looks for this timeline change and changes the timeline, again, so that the HP change is -10.

That makes no sense. We're proposing TWO timeline changes. The original timeline change never actually goes through. That's a huge problem.

Proposing and pre-empting changes to a timeline is a really weird idea. Oh. Well, this should. be. an 'after' rule. An 'after' rule. It takes place AFTER the timeline is changed. Okay. Let's look at it that way:

The Slap proposes an HP change of -10 to Vencabot.
Hench sees this event and proposes a new event -- a timeline update -- where the HP change is -20.

After the timeline has changed, Seal Rule sees that it changed and changes the timeline, again, so tht the HP change is -10.

On Wednesday, I'm gonna try my DAMNEDEST to break Seal Rule.

Seal Rule is now an AFTER Rule. How are we gonna break it? It's gonna definitely be contingent on two rules simultaneously looking for changes to the timeline. That's what's always broken these sorts of rules in the past, but I feel like, now that I've found a way to make it an AFTER RULE, that's not gonna be the case any more.

But we're gonna dedicate to Wednesday to making sure that I'm right about that. Is there a way to break Seal Rule, now -- or any Rule which depends on looking at a change being made by another rule and preventing it.


06/12/19

Today, we're trying to break Seal Rule. Let's theorize some situations to test that could potentially break a rule like this.

1.) The most obvious thing -- because it's what usually breaks these sorts of rules -- is to have two different rules waiting for the same sort of event such that they might interfere with each other based on the order of their operations.

So, Seal Rule is waiting for a certain other Rule to trigger, and then it effectively UNDOES its effect.

So, let's say that Seal Rule is sealing Hench. And then suppose that we have a Rule that's supposed to trigger whenever a unit's damage is doubled. So, if they're both essentially waiting for Hench, is this going to cause a problem where the second Rule's triggering will prevent Seal Rule from working correctly?

So, the only way to test this is to test it, because we're getting to challenges that are so abstract that it's giving me a headache just to try to imagine. So let's not imagine it: let's just test it. Let's design this new rule:

"If the target's unit's damage is augmented UPWARD, they take damage." What's the name of this rule? "Growing Pains".

It strikes me that a lot of our existing rules could probably be updated to look for event timeline changes, and that might be a more reliable way, over-all, to handle these sorts of rules which take affect based on the affect of other rules.

I hate to say it, but I need a lot more diagnostic code. Not a lot of code, but a lot more output. I'm just gonna make a one-line change to the way that 'update_w_rules' works to add a lot more diagnostic output.

In vanilla Python, you would say:

"Vencabot attacks KReich for 10 damage."

KReichJr.hp = KReichJr.hp - 10
or
KReichJr.hp -= 10

In our game, we don't directly modify attributes like this because we want to generate a REPORT that tells the DynamicRules about PROPOSED CHANGES to attributes and FINALIZED CHANGES to attributes.

So, instead of updating Kenny's HP directly through his .hp attribute, we do this:

our_battle.update_w_rules(KReichJr, "hp", KReichJr.hp - 10)

print(KReichJr.hp)
>> 20
KReichJr.hp -= 10
print(KReichJr.hp)
>> 0

Growing pains is working. The whole point of this was to try to break 'Seal Rule' by having two rules look for the same criteria but in a different order. So, let's examine this new "Growing Pains" scenario theoretically to see where and if it's gonna fail.

In our example, Seal Rule prevented Hench from triggering, the first time, and so Growing Pains did not trigger. Let's examine this situation.

Is it possible for Growing Pains to TRIGGER BEFORE HENCH is sealed.

Both GrowingPains and SealRule are waiting for an update to the event timeline.

When SealRule triggers -- and THIS IS THE CORE DIFFERENCE WHICH I BELIEVE WILL FINALLY SOLVE ALL OF THE PROBLEMS AND BUGS THAT WE USED TO HAVE -- when SealRule triggers to prevent 'Hench' from working, IT DOES NOT, ITSELF, MODIFY THE EVENT TIMELINE.

It CHECKS the Event Timeline, but it DOES NOT NEED TO ALTER THE EVENT TIMELINE IN ORDER TO PREVENT HENCH FROM WORKING.

Instead, SealRule updates the EVENT. The abstraction is so subtle, and that's what makes it so annoying -- but powerful.

It doesn't even add a new event to THIS TIMELINE. It's because it's not looking for the event that CHANGES THE HP. It's looking for the event which CHANGES THE TIMELINE. And whenever the timeline is changed, we get a BRAND NEW EVENT WITH ITS OWN TIMELINE. We events on events, we got timelines on timelines.

So the advantage we have with this new system is that SealRule and GrowingPains are not looking at the same event, really. I don't think so. Let's theorize. I'm pretty sure they're not looking at the same event.

Vencabot creates an event when he attacks Kenny. The event says, "Kenny's HP is changing as a result of Vencabot."

Hench looks at that event and UPDATES THAT EVENT, CREATING A NEW ENTRY IN ITS TIMELINE. It updates it so taht Kenny's HP is reduced twice as much.

SealRule is waiting for an event that says that an event was updated. It sees that the 'hp change' event was updated by Hench, and so it UPDATES THAT EVENT AGAIN, creating a new entry in the 'hp change' timeline, and creating a WHOLE NEW event that says that the timeline was updated.

Where does 'GrowingPains' fit into this? Why didn't GrowingPains trigger when Hench was sealed?

GrowingPains is failing twice when I only expected it to fail once. I think that it's failing twice because it's - no. It's because it's also triggering when Hench is updating the timeline.

It's failing when Hench updates the timeline and when Seal Rule re-updates the timeline.

But the question I have is, why is the timeline the same both times?

I was right about why it's failing twice. Why is it failing on Seal Rule before it fails on Hench? Hench is TRIGGERING first. Hench is FINALIZED first. GrowingPains is looking for a timeline update. But Hench's timeline update completes BEFORE Seal Rules, doesn't it?

Slap proposes an HP change [EVENT0HC created].
Hench proposes an update to that HP change [EVENT1TC created].
The update to the HP change event completes [EVENT0HC updated] [EVENT1TC finalized].
Seal Rule proposes another update to that HP change [EVENT2TC created].
That update to the HP change event completes [EVENT0HC updated] [EVENT2TC finalized].
GrowingPains sees




When Hench changes the timeline, Seal Rule is triggered immediately.
When Seal Rule changes the timeline, GrowingPains is triggered immediately.

Once that process is complete, then Hench's change finally dribbles down to GrowingPains. That's why GrowingPains sees Seal Rule first.

The reason that both times that GrowingPains is triggered it sees the same timeline is because timeline is a mutable object that we're referencing by identity. By the time it sees it the FIRST TIME, Seal Rule has already triggered. so, even though Growing Pains is triggered the SECOND TIME by Hench, the timeline change from Seal Rule has already taken place.



06/13/19

Today, I would like to break Seal Rule if I can figure out a way to do that.

As I was thinking about this problem last night, it struck me that perhaps a rule like "GrowingPains" is never going to break Seal Rule. I even theorized that we could successfully SEAL SealRule using SealRule. Having this extra axis of attack on the DynamicEvent system is really adding so much flexibility to our mechanics.

So, how WOULD you break Seal Rule?

Seal Rule looks for a DynamicEvent that occurs when another DynamicEvent is altered.

It's an After rule. I just can't think of a way to break this. I think that tonight -- the hour that we have -- might be better spent looking at progressing toward our fully-working battle.

I'm afraid that one day I might find a situation where our Dynamic Rule System breaks down. But I can't just keep wasting streams trying to find those weaknesses; the system is just too complex. In fact, we might be well-served at this point to start doing some kind of documentation.

Yeah. Before I start moving toward the fully-working battle, maybe it's time to start documenting the Dynamic Rule System so that another programmer that joins this project (like KReichJr) will have a clearer understanding of how it works.

Tonight, let's look through our battlelib and start looking at how we can commentate our features.

Right now, the biggest difference between our EXISTING mock-up and our FULLY-WORKING BATTLE is that we need a more fully-fleshed-out implementation of the Unit.

If a Ruleset is changed during the processing of a DynamicEvent, how does the change in rule-list length affect the 'for' loop? Is this a bug?

############## LOOK ABOVE ###############



06/19/19

Before we get started, I notice that, at the very end of our last programming stream, I theorized that we might have a bug with the way that we handle iteration through a rule-list. Because, during iteration, the length of the list can change. Let's make sure that we're working on this loop correctly.

To break Rule iteration, we would need an After rule which adds or removes another After Rule. I think that we'd get the better 'breaking' result by removing an after rule during an after rule.

So, we would need two Rules to test with: one generic 'after' rule (could just print a message) and one after rule which REMOVES that rule.

It strikes me that, whenever you update the list of rules, you're almost certainly going to be using Battle.update_w_rules.

What's particular about update_w_rules -- and, by extension, our entire Dynamic Rule System -- is that it doesn't support mutability at all. This has some interesting caveats when you start thinking about updating the list of rules, some of which will actually have ramifications on gameplay.

In particular, IF YOU ADD A RULE ON A TURN, YOU CAN NOT TRIGGER THAT RULE ON THE SAME TURN. Or, you CAN, but it will be somewhat unpredictable (which is kind of a problem).

Basically, whenever an event is being processed through a list of rules, that 'for' loop is fixated on a single list.

If the battle's ruleset is updated during that process, a brand new list is created (that's how 'update_w_rules' works). Therefore, the ongoing processing of the event WILL STILL BE USING THE ORIGINAL LIST OF RULES.

But then, as soon as a new event is being processed, it'll be using the NEW list of rules.

Let's focus on these 'bugs' one at a time. First, I want to make sure that we can't break rule-processing due to the mutability of the rule list. After all, not every update to the rulelist will necessarily be going through update_w_rules (although it SHOULD). We probably need to fail-safe or foolproof this, so let's prove that.

We solved our first, obvious bug. But now we have a new bug, which may itself not be a "bug" and may not need fixing, but it MAY result in behaviors which are somewhat unexpected by the player. And I want to demonstrate that.

So, if we have an after_rule which ADDS a new after_rule, that new after_rule can not be triggered in the same processing phase which triggered the first after_rule.

However, that new after_rule CAN be triggered by NEW events which are the RESULT of another after_rule. So, the problem that we're facing is that there will be situations which may be difficult for the player to discern where new rules are INSTANTLY TRIGGERED and other situations where new rules will NOT be instantly triggered. I would like to demonstrate both scenarios and how confusing this can be.

What I've proven with our first 'salty' example is that, although the same criteria of event triggers both goodvibe BECOMING salty AND his salt giving him ATTACK POWER, he doesn't gain attack power the FIRST time he becomes salty.

You might think that, because him BECOMING salty and him GAINING attack power are both triggered by him taking damage, that the sequence of events would go like this:

GoodVibe takes damage.
GoodVibe's 'salt' is triggered, meaning that, when he takes damage, he'll now gain attack power.
He gains attack power (because he took damage).

It doesn't play out that way because when 'Salty' is triggered, it adds a new rule (when he takes damage, he gets attack power), and that new rule can not be triggered on the same phase that it was created.

That's fair, that makes sense -- that's predictable. But what's NOT predictable (maybe) is that, although this new rule can NOT be triggered on the same "phase," it can be triggered on the same TURN or ACTION. Because these ideas, internally, are distinct. We can prove that simply by making GoodVibe take damage TWICE from the same action.

Maybe we have another Rule where, if GoodVibe takes damage, he takes damage again.

I've proven my point.

When GoodVibe is pessimistic, he can GAIN A NEW RULE WHICH GIVES HIM ATTACK POWER WHEN HE LOSES HEALTH, and that rule CAN BE TRIGGERED ON THAT SAME ACTION.

He loses health, which gives him a new rule that's triggered when he loses health.
His losing health causes him to lose health, again.
His new rule is triggered, because he just health.

That all happens based on him getting slapped.

However, this won't happen if he's not pessimistic.

He loses health, which gives him a new rule that's triggered when he loses health.
Nothing happens after that. The new Rule isn't triggered, even though he just health.

Is this a 'bug' worth addressing, or is it pretty clear to the player what the difference is between these two situations? Right now, I'm sort of leaning toward the latter. Even though both 'hits' are triggered by the same 'slap,' it's clear that, in the first example, the damage which TRIGGERED 'salt power' came from his Pessimism -- not from the slap, itself.

So, any time that a new rule is added as the result of another rule, it won't be triggered by that same event. But, if another event is created that WOULD trigger it, by that same action, sure, it can be triggered THEN. It just can't be triggered by the same exact event.

I'll look at this again, tomorrow, but I'm pretty sure that this isn't a bug that's worth worrying about. I think that the behavior will be more-or-less understandable by players. When any new rule is added as the result of some action, it can't be triggered by that same exact event.




06/20/19

Today we're going to be doing kind of a short development stream where we look at the 'units' for our battle system and give them the attributes they're going to need in order to satisfy our original design documents.

Units, right now, have a couple of attributes that we've been using for testing:

HP
ATK
MP

But they're going to need quite a few more attributes than that in order for our battle system to be considered fully-working. Let's break down what we know, so far, about the attributes that our units are going to need:

HP - The amount of damage that a unit can take before they're 'knocked out' and can no longer act.

ATK - A base value used for attack damage multiplication.

MP - A resource typically consumed by using abilities that represents a limit to how many abilities a single unit can use in battle.

Here are some ideas for other attributes that we've been strongly considering for our combat system:

DEF - A base value used to diminish damage done to this unit. It's meant to have a larger impact on weaker abilities; that way, attacks that hit multiple times for less damage (potentially adding up to MORE damage) will be less effective against units that have high DEF. In order to effectively damage a unit that has high DEF, you need to deal damage in large chunks.

SKL - An offensive value that raises the 'effectiveness' of abilities against another unit.

PRY - A defensive value which lowers the 'effectiveness' of abilities against this unit.

XST - A percentage which temporarily diminishes the maximum attribute values of a unit based on how many encounters they've been through since they last rested. Meant to encourage the player to swap party members to keep them rested.

LP - A value representing the number of times that a unit can be revived after being knocked out. Some attacks can damage LP directly. When LP reaches 0, the unit is 'destroyed' on a semi-permanent basis.

MAX HP
CUR HP

MAX LP
CUR LP

MAX MP
CUR MP

REAL XST
AUG XST

REAL ATK
AUG ATK

REAL DEF
AUG DEF

REAL SKL
AUG SKL

REAL PRY
AUG PRY

REAL TAGS
AUG TAGS

It's been a few months. Let's re-examine some of these ideas that we came up with when we were originally designing our game.

First, let's re-examine the idea of permanently-bound equipment. I still think that's a cool idea; that's probably all that we need to say about it for now. When you capture a new unit, you bind it to some item which will affect that unit's growth. We also discussed the possibility that this equipment would determine the unit's tertiary class and maybe even offer them some extra dynamic. In fact, we should lock that in: I don't think that units, in their most raw form, should have three classes. I think that units should have a Primary Class and a Secondary Class, and the Tertiary Class comes from their equipment, which is universal across any unit.

We talked about how units should have some kind of 'elemental' value which may affect how certain abilities affect them. We've since changed, updated, and improved that idea to this notion of units having 'tags.' Any number of tags.

Units have Dynamics. I think that this should be a list, and any unit can have any number of inherent Dynamics -- including some which may be attributed by their equipment.

Let's talk briefly about the idea of our game's 'class' system, which I've been re-examining on off-stream hours.

I feel like, for the sake of making each unit feel more unique, the abilities that each unit has should be, at the very least, re-named to suit that unit.

But I do like the idea of 'classes' determining what these abilities DO. Like, each unit would have a couple classes, and these classes would determine their abilities. But it's much more to do with what these abilities DO and are USED FOR than anything to do with theming. Because we're gonna have classes that might be shared between My Little Pony and Jason Vorhees, so I feel like we could get caught up in the idea of what these abilities are meant to represent. I think that it makes more sense to say that "warriors have a basic attack ability which does double their base ATK and costs 2 MP." And then every unit would have a different name and potentially graphical affect for this ability.

So, internally, how are we going to architect these units considering these classes?

Maybe. Every. Unit. Should have unique classes designed for THEM which are BASED on universal classes. That way, we could give the unit these 'classes' and their abilities (which, as we discussed above, are TECHNICALLY but not ENTIRELY unique to that unit) still live in those classes, which are, themselves, TECHNICALLY but not ENTIRELY unique to that unit.

On the other hand, if every unit has classes with unique names, then it doesn't really do the player any good to know what these classes are. That's kind of a dumb idea.

I think that units need an Abilities list, and they draw those abilities from some pool that's based on their class. In fact, we discussed that abilities should have permutations? And also I came up with the idea of units only being able to bring so many abilities into any given battle? We need to reexamine these ideas.

When Units are captured, they only know a few abilities from their classes. As they level up, they can learn more of these abilities.

But units can only equip a limited number of abilities at a time. As they level up, they can unlock more slots for these abilities.

What makes more sense, then: giving the unit a maximum number of abilities TOTAL, or giving the unit a maximum number of abilities PER CLASS.

If you give the unit a maximum number of abilities TOTAL to use at once, you're essentially giving them extra incentive to bring in their MOST POWERFUL abilities. Which are almost certainly going to be from their Primary Class.

If you give the unit a maximum number of abilities PER CLASS, you're encouraging them to mix the abilities of their classes together. But, is this the sort of encouragement that we want to give the player? Shouldn't the afforded tactical flexibility of multi-classing be incentive ENOUGH for the player to equip abilities from BOTH or ALL of their classes?

Consider Tertiary Classes. If a Unit is limited in the number of total abilities that they can bring into combat, you're almost never gonna see anyone bring in abilities from their Tertiary Class. The whole idea that we conceived for Tertiary Classes was to have weaker abilities which afford a very small amount of tactical flexibility that might be useful in edge-cases or otherwise when the Leader has little AP remaining or the unit has little MP remaining.

If there's little incentive to bring in these tertiary skills, is that a problem with the SKILL SLOTS (we should give them a limited number of abilities PER CLASS) or is it a problem with the whole idea of TERTIARY CLASSES (we need to make these classes / abilities more interesting to make the player want to take these abilities into combat).

I want to make an argument that the available ability slots should be limited PER CLASS: we could give the player an INTERESTING DECISION TO MAKE when it comes to WHICH class to expand in terms of abilities availble per battle.

Because, the Primary Class has access to that unit's most POWERFUL abilities. What if it cost MORE to unlock new slots for the Primary Class. Then, the player would be encouraged to fuck around with their secondary and tertiary classes despite the fact that those abilities aren't inherently as POWERFUL, NUMERICALLY.

Maybe a system like this would ENCOURAGE the player to EXPERIMENT with the notion of secondary and tertiary classes. Otherwise, they might over-fixate on the NUMERICAL SUPERIORITY of their PRIMARY skills and then find themselves tactically limited in battle and not understand why they're losing. So maybe if we made it more AFFORDABLE to multi-class, players would be more encouraged to do that and, as a result, experience battle more in line with what we expect as game-designers.

With this suggestion, LEARNING tertiary abilities would be cheaper (because the abilities, themselves, are weaker) and buying slots for the tertiary class would be cheaper (because only weak abilities are going into those slots).

Buying abilities for the Primary Class would be potentially more expensive (because this class has access to more powerful abilities), and buying slots for this class would be more expensive (because those slots could potentially be filled with more powerful abilities).

I like that idea. It encourages the player to experiment with their tertiary and secondary classes. It means that you're going into battle and you're always going to have access to your secondary and tertiary classes in some capacity, defining how that unit is used. You can't just load up on Primary Class abilities and only use the best of those and make a unit which is tactically less flexible but more specialized.

That, in itself, could be an interesting decision to offer to our players: do they want for their unit to be more FLEXIBLE or more SPECIALIZED. But I think that, with the way that our gameplay has been designed so far, it makes more sense for us, as game-designers, to maintain some control over how specialized or flexible a unit-type is.

Notes for the new guys:

* Every Unit has three classes: Primary, Secondary, and Tertiary

* Every class has three tiers of abilities: Tier 1, Tier 2, Tier 3.

* Which class 'slot' a particular class is in, on a unit, determines which tiers of abilities that unit has access to.

* If a class is that unit's Primary Class, they can learn abilities from ANY of the tiers.

* If a class is that unit's Secondary Class, they can learn abilities from the first two tiers.

* If a class is that unit's Tertiary Class, they can only learn abilities from the first tier.

This means that, if a class is your Secondary Class, you'll have access to all of the abilities of that class EXCEPT for the most 'powerful' abilities.

If a class is your tertiary class, you only have access to the least 'powerful' abilities in that class.

So, in terms of attributes -- like, programmatic attributes -- we need lists and numbers for how many slots from each class we have.

What's the best way, programatically, to assign things like CLASSES and ABILITIES to a unit? Right now, for our temporary mock-up, units just have a list of abilities. But how are we going to organize that for units in the long-term?

Units need slots for the Rules they're under the affect of. They can only be under the affect of two Ally Rules and two Enemy Rules at the same time. We're gonna really need to examine how that's gonna play out.



06/24/19

Today, I want to continue looking at how to architect the 'classes' and 'ability' systems. We can also look at fleshing out the other attributes that Units need, including their limited slots for new Rules.

Maybe the solution for Abilities will come to us if we review this idea of 'gacha' abilities, where there's some randomness applied to the Ability that you learn.

Let's see if I can find those notes.

I found our old notes regarding 'gatcha':

1.) Units are born with some seeds which determine the variant of Abilities they get.
2.) These seeds are balanced against each other so that a single unit doesn't have too many 'good' seeds -- or bad seeds -- so, they don't get too many godlike or trash ability variants.
3.) Abilities can vary in their 'severity' and 'effectiveness' and 'status change they inflict' and 'cure condition' and a bunch of other terms that I didn't really seem to understand at the time.

These notes are from a time before I personally (maybe even off-stream?) came up with an idea for the gacha element coming into play when BUYING abilities from a class.

The idea is that, when units complete battles, they're awarded some kind of currency that you can use to upgrade that unit in a variety of ways -- including learning new abilities from their classes. I had this idea where, when you buy an ability, you get a randomized variant of that ability -- and then you could buy it AGAIN to get a new, randomized variant of that ability.

And I sort of understood it as the unit being able to accrue a more-or-less indefinite number of the same ability which they could selectively choose to equip. Maybe they'd be limited to having only one variant of a particular ability at a time, or something.

But, re-reading these notes from my conversation with Dixx, I feel like that might not be the most elegant solution. In a monster-collecting JRPG, 'gacha' is always an element, and I sort of like the idea that you might want to re-capture a unit-type that you already have just to see what its variant abilities are. If you could just keep re-buying the same ability over and over again until you get one that you like, there really is no difference between two units of the same unit-type (aside from their bound equipment).

You could look at a sort of compromise between the two concepts: maybe the FIRST variant that you get when you buy an ability is based on that unit's seeds. And maybe RE-BUYING to get a different variant is very expensive. I kind of like that.

Okay, well. I wonder how expensive it would need to be -- but, in any case, I like that solution and I'm gonna roll with it, and we can work on balancing it later.

Now, we need to seriously look at what it means for abilities to have 'variants'. How much do these abilities vary. Do we hard-code all of the variants in? Maybe there's two 'levels' of variance, or two kinds of variance:

'Linear variance,' where we talk about abilities becoming strictly more or less powerful (varying things like their COSTS, their DAMAGE, how long their STATUS EFFECTS LAST, how hard they are to CURE, etc. Chance to crit.).

'Non-linear variance,' where we talk about abilities gaining different PROPERTIES. Inflicting different status changes.

The non-linear variance would need to be hard-coded in, probably including a different ability name. The linear variance might be more-or-less completely randomized within a set limit.

The linear variance would NEED to balanced, somehow, such as by having seeds be balanced against each other (???).

The non-linear variance could be completely random. Because variations that are non-linear aren't strictly 'better' or 'worse' than other variations, there's no need to balance them. You just get a random variation.

So, for instance, when a unit 'buys' Slap...

Its damage amount is somewhat randomized.

Its crit-chance is somewhat randomized? (Is that a thing we can do? I never considered that before. I'm not sure that our current mechanisms accommodate abilities having different crit-chances. We can fix this by making the crit-chance algorithm overridable).

Its MP cost is somewhat randomized.

It's AP cost could be somewhat randomized.

And if some of these have a high chance to go UP, then others consequently must have a high chance to go DOWN.

If attack power and / or crit chance is likely to go UP, then MP cost and / or AP cost are likely to go UP as well. But there would still be randomization even within these figures, so it's possible that you COULD get a very good variation, although it's less-likely because of how we're using these seeds against one another.

So, basically, you would need to mark certain attributes as 'favorable' and others as 'disfavorable'.

Does the object which 'spawns' random variances of an ability need to be the same object that's used in combat (the actual Ability)? It almost seems like this shouldn't be the case. Almost like it COULDN'T be the case, because the non-linear variants would need to each be their own class -- so we'd need some class which could represent the ability AS A WHOLE. And maybe THAT class spawns the variants.

We need another class for this. We need some kind of 'meta ability' or 'master ability' or something along those lines whose job it is to describe the ability in BASIC terms and spawn instances of randomized variants of that ability.

I feel like it's important, when talking about 'gacha abilities' and randomness, that I tighten up some of the verbage: I don't think that what units have could strictly be described as a 'seed'. Although it is randomly generated, it does not, itself, DETERMINE what ability that unit is going to get when it buys a new ability.

Instead, that 'seed' is then run against some degree of randomness. It's more like an augment or a factor or multiplier or whatever. It's a value that's used as the part of another random equation.

One thing about this design is that it allows us to disassociate 'abilities' and 'meta abilities' or 'master abilities' or 'class abilities' or whatever you wanna call it. It means that the 'UnitClass' object can contain these META ABILITIES, and the Unit doesn't really need to worry about these MetaAbilities at all.

Instead, the Unit can just have an essentially loose list of abilities. Maybe each Unit has three ability lists. They would actually need 6 ability lists:

'learned_primary_abilities'
'learned_secondary_abilities'
'learned_tertiary_abilities'
'equipped_primary_abilities'
'equipped_secondary_abilities'
'equipped_tertiary_abilities'

Then, they would also need a value representing the limit of how many abilities they can have equipped at a time:

'primary_ability_limit'
'secondary_ability_limit'
'tertiary_ability_limit'

Units also need a reference to their class for the purpose of when they want to buy new abilities and for when the player is checking their 'status' page:

'primary_class'
'secondary_class'
'tertiary_class'

Before we end the stream, I want to consider that, perhaps, we should make the 'abilities' aspect of a Unit a bit less flat. Maybe create some kind of 'personal_class' object which contains things like:

A reference to the master class.
The list of currently-known abilities for that class.
The list of currently-equipped abilities for that class.

That way, they're not all just floating around attached directly to the Unit.

I feel like that kind of solves an non-existant problem. How does that really serve me?

Having all of these loose attributes does look kind of sloppy. Maybe it would make sense to divide them up into their own objects.

So, let's look at the new classes that we're going to need to fully-implement our current vision for the Ability system:

MetaClass: contains all of the MetaAbilities associated with this class.

MetaAbilities: objects which represent the totality of a unit's ability as it belongs to their class. The primary purpose of this class is to DESCRIBE and to SPAWN abilities conforming to this design. It contains methods for generating the randomized variations of this meta-ability.

PersonalClass (name-in-progress): Would belong directly to a Unit and would contain a reference to the associated MetaClass. It contains all of the abilities that the owning Unit has learned from this class, and it contains the limitations of how many abilities can be currently equipped from this class -- and, of course, it has the equipped abilities. Lots of attributes, not a whole lot of methods. Really more of a data structure.

UnitAbility: The actual instance of an ability to be used by the unit in combat. Originally spawned from a MetaAbility and it belongs to a 'PersonalClass'. It has a lot of randomized attributes and belongs to a particular random 'non-linear variance' of a MetaAbility.

What's a better name for a sort of 'unit-class instance' than 'PersonalClass'? Maybe UnitClass. We have MetaAbilities and UnitAbilities. Maybe we have MetaClass and UnitClass.

So, on Wednesday, I feel like we need to put more work into hammering out this 'ability' system. We need to look at the architecture of MetaClasses as well as MetaAbilities. We need to create a working mock-up of a MetaAbility which can randomly spawn linear and non-linear variations into the ability list of UnitClasses.

The complicated part is going to be the MetaAbilities. In fact, I feel like the 'Meta Class' is pretty much just a data structure that organizes the MetaAbilities into tiers. The MetaAbility is going to be rich with attributes and methods for defining the spawning-behavior when a unit learns a randomized variation of that MetaAbility. So, we'll make a mock-up for 'Slap' which allows a unit to learn 'Slap' and get a slightly different slap every time.


06/26/19

Today, I want to start mocking up our game's Ability system, where UnitAbilities are organized into MetaAbilities, and MetaAbilities are organized into MetaClasses.

Before we get started with that, let's look at how much we've broken our Units.

HP, MP (and, in our case, LP) are interesting attributes in JRPGs, because they're resources that are meant to be continuously consumed and restored.

So, when you think about something like 'ATK', it basically has two associated values:

It's 'default' or 'base' value, which is what shows up on your character 'status' screen between fights. This value raises as your character levels up.

And it also has a 'current' or 'augmented' value, which is representative of how much ATK your unit has ON THIS TURN IN BATTLE, which may be different from its base ATK due to the results of some status changes -- buffs or nerfs.

But HP and MP aren't this same way. They do have BOTH of those attributes: a 'base' value and an 'augmented' value (such as some status change which temporary lowers a unit's max HP or maybe raises it), but they also have ANOTHER value, which is their CURRENT HP. So, the MAX value is a base value and THAT can be augmented, but there's also a CURRENT value which represents how 'full' the HP or MP is. ATK, DEF, etc., don't have that.

If I want to unify all of the unit attributes into some kind of class which has .base and .aug attributes, we need to look at CURRENT HP and CURRENT MP as their own, SEPARATE values. Because CURRENT HP can ALSO be augmented. So, really, what we're looking at are values which always have a BASE VALUE and an AUGMENTED value -- because, in a game with such an emphasis on 'status changes' (hence the 'Dynamic Rule System'), we're going to see attributes being augmented a lot. I think it's only natural to build this directly into our architecture.

I think we need another layer of classes? We talked about how Units should have ability names which reflect the THEMES of that unit, even if the actual affect of the ability doesn't change. For instance, what one class calls 'Slap' another class might call 'Punch' or 'Shoot' or whatever. Just to better fit the GRAPHICAL or NARRATIVE theme of that class. So, how are we gonna break this up?

Considering that only (?) the NAMES of the abilities and classes are changing, perhaps these could just be aliases that are built into the Unit class. Like, they take a MetaAbility and they rebind its name to something else.

But the downside of this would be that we really COULDN'T add unit-specific abilities even if we wanted to, and I kind of liked the idea that Panders brought up a long time ago of maybe having one or two unique abilities per unit. So it's almost like... we need a MetaClass to extend another MetaClass.

And then, when a MetaAbility is learned... it could intercept the newly born ability and change its name and description or whatever?

Okay, that works. So, we don't NEED a new type of object. We just need for the unit-specific MetaClasses to inherit from some base MetaClass.

Leaders don't need classes or anything. Although, it stands to reason that they should be able to learn new abilities and stuff? But let's not worry about that right now. We can worry about that mock-up or 8 or so. I think that mock-up is probably going to be focused on GROWTH. Unit growth. Once we have a feel for unit growth and such, we can start worrying about the Leader growth. That's really a secondary concern.

So, for now, let's say that Leaders DON'T need classes. They just have abilities and such that are INHERENT to them.

In a future episode, we need to examine how much like units we really want leaders to be. For now, let's just leave them as a very basic structure whose AP is consumed by their team. They're basically just representative of a 'party' and a shared AP pool.

I'm going to rewrite the code, right now, in advance, for determining critical-hit chance. We want for this to be more modular, so that different abilities can override the equation for critical-hit chance.

I think we broke something with the Dynamic Rule System, because Dynamic Events take a target and an attribute name. But now we've got layers to this shit. Now, the 'target' would be an attribute (like HP) and the attr_name would be 'base_val' or 'aug_val'.

That's super duper ugly. Is there any way we can fix this? Not to my knowledge, right away.

The thing that you COULD do is just to flatten out the Unit class and give them attributes like:

some_unit.base_hp

Rather than

some_unit.hp.base_val

Maybe that just makes more sense because of the way that the DynamicRuleSystem is engineered. I wanted to move to

some_unit.hp.base_val

as a way to communicate, ARCHITECTURALLY, the way that unit's attribute values change over the course of a battle. By flattening it out, we lose that sense of structure that's congruent with the way that battles actually play out.

But it could just be a sacrifice that's worth making to keep the DynamicRuleSystem simple (or RELATIVELY SIMPLE).

The thing is, we could update the DynamicRuleSystem to understand 'base_val' and 'aug_val', but there are attributes that are SUBJECT to the DRS which are not UNIT attributes. Like, when a Rule's triggered-counter updates. It doesn't need 'base_val' and 'aug_val', because it's not an attribute of a unit. So, because not all DRS-subject attributes belong to units, it doesn't really make any sense to impart this 'base_val' and 'aug_value' sub-attribute thing into it. So maybe we should just flatten it out.

But the thing -- there's an advantage to having this 'base_val' and 'aug_val' structure to our unit attributes, because we could see, at a glance, which unit attributes have been augmented, for instance.

On the other-other hand, unit attributes are FIXED. They're not going to be dynamically added and removed in battle -- that's what we hve 'tags' for -- so it's not like we're ever going to have more than HP, MP, LP, ATK, DEF, SKL, and PRY to deal with. So in that sense, it's very understandable to flatten things out.

It makes THE MOST SENSE, FOR NOW, TO FLATTEN OUT THE UNIT ATTRIBUTES. We can worry about adding more depth later if we really want to.

So, on Monday, let's work backwards: we want to get a working battle scenario FIRST, where Son of Dixxucker is Slapping Other Son of Dixxucker. Then, we can start looking at organizing 'Slap' into a MetaAbility, and then organize that MetaAbility into a MetaClass.

1.) Get Slap working again.
2.) Organize Slap into a MetaAbility.
3.) Organize the MetaAbility into a MetaClass.

Units still need 'Dynamic Rule' slots.



07/01/19

So, we ported Slap over to the new Unit mechanisms. But now we need to start asking some pretty interesting questions, because we're going to be trying to organize 'Slap,' the UnitAbility, into some kind of MetaAbility.

So, let's review what the purpose of the MetaAbilities really are:

MetaAbilities are integral to the process of LEARNING new abilities. That's what they really are. Once an Ability is LEARNED, the MetaAbility really has no importance.

So, what we're looking at is a mechanism where a unit wants to learn a new ability and the MetaAbility handles that transaction: it takes some kind of currency and gives the unit a UnitAbility.

Perhaps, then, the most integral method of a MetaAbility will be something like "learn" or "be learned by," or maybe the unit, itself, has a 'learn' method that takes a MetaAbility as an argument.

So, I think that Units should have a 'Learn' method which takes a MetaAbility as an argument. That being the case, the MetaClass -- well, no. I think it probably makes more sense, from an architectural standpoint, to have the MetaAbility have some kind of 'be_learned_by' method, because it's in that method that the MetaAbility sort of contains its logic for deciding which version of the Ability to give the unit as well as how to randomize that ability's attributes.

Let's just start coding and see what happens.

We have our meta-ability. Now let's talk about... what we call... 'linear variance'. In other words, we can get some Slaps that are better than other slaps.

So, for something like 'Slap,' we can play with the DAMAGE MULTIPLIER, we can play with the COSTS.

So, the MetaAbility handles the linear variance when the UnitAbility is spawned, right?

But why? That seems like an unnecessary extra step, because the UnitAbility, itself, knows its 'owner' upon instantiation. That being the case, shouldn't it be able to provide its own linear variance? Is there any reason it shouldn't?

I wanna say that there is NO REASON to rely on the MetaAbility to handle the LINEAR variation. So let's say that the responsibility of the MetaAbility is to handle the NON-LINEAR variation exclusively.

When you instantiate a UnitAbility, it can handle its own linear variation.

How do you get a random number between .5 and 2?

Ending our game-dev stream for today, we got our first MetaAbility working, and it seems to be behaving correctly. Now, the UnitAbilities, upon instantiation, handle their own 'linear variance,' which is to say that they examine their new owner and use the owner's attributes to decide, within some amount of randomness, what sorts of attributes they should have.

The MetaAbility, Slap, has a method, "get_unit_ability_for," which can return a UnitAbility based on the attributes of the UnitClass that its given as an argument. So, on Wednesday's stream, we should get some non-linear variance working for the Slap MetaAbility, which means that we can not only get different STRENGTHS of slaps, but also different TYPES of slaps. So, we can program in a slap which inflicts poison or a slap which has a chance to take a unit's turn or something like that.

After that, I'm surprisingly well-satisfied with where we're at insofar as architecting the Ability system of our game. I feel like it's where it needs to be in terms of sensibility and stability. It works. It's simple. It's dynamic. It's everything that I want it to be, right now.

So, on Wednesday, it's very likely that we'll start to look into designing these 'MetaClasses,' at which point we can pretty much start designing mock-up unit types and get a real test battle going.

Call me optimistic, but I think that, by the end of our Thursday stream, this week, we should have our first real test battle going -- except that we probably need some kind of mechanism to manage the turn-taking and stuff.

Let me dial it back: by the end of NEXT week, we will DEFINITELY have a fully-working and playable battle.


07/03/19

Today, we're going to start seriously looking at 'MetaClasses' and maybe even designing some mock-up unit-types that are more suited to a real test battle than our 'Dixxucker' unit-type, which has just been a placeholder.

So, first, let's design a real MetaClass for Dixxucker that we can use to at least demonstrate the architecture of these MetaClasses. I feel like these MetaClass objects are going to be very simple -- at least for now.

NOTE: I feel like there should be no cross-over in Abilities between classes.

We made some really awesome progress, today, in the internal architecture of the ability and class system. That means that, next time, on Thursday, we can really knuckle down and start creating some mock-up classes and units so that we can actually have a real, working test battle.

To make the design process easier during this mock-up phase, we've decided to use a battle loosely based on Pokemon: two leaders, Ash and Gary, square off using two teams of four Pokemon. So, we need to design a few classes for these Pokemon to use, each with some number of abilities.

I think... we should look at ABILITY TIERS after we have a fully-working battle. Once we've looked at ability tiers, we can start making even thinking about character growth -- but, really, the ability-tiers are the main issue. We'll incorporate a tier-check during UnitClass.learn_ability .

That'll be tomorrow!


07/04/19

I was thinking, today, in the shower, that it would make sense for us to create a new universal method for all UnitAbilities called "linear_variate," which would always be called upon instantiation and which would exclusively handle the assigning of attributes to that class which fall under the 'linear variation' of that ability.

In other words, when you buy an ability in our game, you get a randomized ability -- it's the game's 'gacha' element. First, during the randomization process, we go through the 'non-linear variation.' This refers to WHICH FAMILY OF ABILITY you end up with.

So, if you buy Slap, you might get a Heavy Slap (which has a chance to stun), or you might get a Sweaty Slap (which has a chance to poison). You might get a Cold Slap, which does 'cold' damage. Something like that. That's the non-linear variation of slap. It's non-linear because all of those slaps are considered equally 'good,' but they're just different.

After we decide WHICH slap you're going to get, that slap goes through a Linear Variation process, which randomized the attributes of that slap, which may make it better or worse. That's the 'linear' variation, because the attributes are just randomly going up and down.

Previously, we'd decided to handle the linear variation within the __init__ method, because that's pretty much what it's for. The whole point of __init__ is to set up the instance and assign attributes, and so it makes sense to include the algorithms for linear variation there.

The reason that I want to spin it off into its own method is because I want it to be clear to any developer looking through the code what these equations are really all about. I think that it makes sense to separate these from the standard __init__ fare because we're not JUST setting up the class; we're implementing an actual game mechanic whose entire purpose it is to randomize certain attributes -- BUT ONLY those certain attributes. So, if we spin off into a linear_variation method, the developer can quickly see which attributes are affected by linear variation on that ability.

We're getting to the point in our mock-up where it's becoming (but not entirely) important to think about actual equations for our game. Of course, this is still a VERY EARLY mock-up phase and these equations are subject to change entirely, but we need to start at least considering how things like damage-calculation are going to be handled.

We talked about how we want the DEFENSE ATTRIBUTE to have a greater effect on low-damage abilities.

Should this be something universal? I would argue... no.

In many ways, it definitely makes sense for the damage calculation between DAMAGE and DEF to be universal. Otherwise, you don't really know what having higher defense means.

On the other hand, if you put the damage calculation entirely into the hands of the individual abilities, you can do things like have certain attacks IGNORE defense. Or diminish the effectiveness of defense. Or maybe, if the attack is glancing, maybe it MULTIPLIES the effectiveness of defense.

That makes sense to me, but, again, if we don't have a universal equation for this sort of thing, what does the player really understand about 'defense.' What does it mean to have higher 'defense.' It just means, at that point, that you're likely to take less damage from most attacks.

In a game as dynamic and flexible as ours, there comes a time for a LOT of consideration when you're talking about balancing different classes, abilities, and units against each other. We've created an engine that I'm SUPER proud of, where we have a lot of freedom for how these abilities are conceived. We could create some really awesome, highly varied abilities -- highly tactical abilities -- with relative ease because of how we've designed things.

But with that much freedom comes a lot of responsibility insofar as designing these abilities and their affects. I think -- I think my mistake is that I'm jumping in too fast. I think that we were on the right track before with 'Slap.' We need a Slap because we need a sort of vanilla ability to act as a baseline for all other abilities.

We need a sense for what damage is 'average'. What damage calculation-type is 'average'. What critical-hit chance calculation-type is 'average'. Once we know how much damage an average attack ability does, and we know how much MP an average attack ability costs, we can start to look at how to balance other abilities against that. For instance, we could start talking about abilities that do more damage but cost more MP. We could start talking about abilities which do less damage but have a chance to afflict. We can talk about abilities which do NORMAL damage AND have a chance to afflict but which come at a higher cost.

So, yeah, this isn't as intimidating as it was starting to appear; what we need is a baseline to work from so that we have an understanding of where to go with future abilities.

So here's what I'm going to do. Pikachu's tertiary class is 'Normal'. Right now, we're designing his primary class, 'Electric.' Let's just make sure that Electric is functional with its placeholders, for now, and we'll go work on Normal and give IT Slap. Then we can start building from there.

I guess what I'm saying is that, in order for us to know what abilities and classes and units MAKE SENSE within the context of our game, we absolutely need to have a baseline to balance other things against.

So we're gonna need to have a baseline Ability. We're gonna need to have a baseline class. We're gonna need to have a baseline Unit. We're talking about a generic, vanilla, median, average baseline to work from.

For now, I'm stepping back from the idea of helper classes for marrying objects together. What classes do I currently have which NEED to be married?

Leaders <-> Units

Units <-> Abilities

Units <-> UnitClass

What we accomplished, today, was mostly to realize why we needed a Version 7 mock-up and we're transitioning into that direction.

We're making big changes to the way that we handle ability effectiveness and to how we're laying out our mock-up classes and abilities by spinning them off into their own directories and files.

The goal for the Version 7 mock-up is to create a fully-working example battle with some example units, leaders, classes, and abilities based on Pokemon. It's going to be the most creatively indepth design process so far. We're going to dedicate some real consideration to creating interesting and tactical abilities even though, almost certainly, none of these exact classes or units are going to make it into our final game. But, this is an important step so that we can see the weaknesses of our approach to designing the game -- which we already have, today.

The weakness that we came across, today, is that we desperately need to set some baselines so that we can make informed decisions about what kinds of abilities, classes, and units we're designing. So, our real goal, starting off in Version 7, is to create some baselines for us to use to develop the rest of the mock-up around. Once we have those baselines established, I expect that it'll be simpler to go back and create more abilities and more classes and more units. But we can't do that until we have this baseline set.


07/08/19

Let's start today by examining the architecture of our packages.

We have a 'classes' directory, and it contains directories for each class.

Each class's directory contains .py files which represent each ability of that class, including all of its permutations.

SIDE-NOTE: before we get any further and I forget to mention this, I was thinking about 'damage' equations, last night, and how they should factor in ATK vs DEF. I think what I want to do is to make it very simple:

A 'baseline' attack, in the game, should do base damage EQUAL TO that unit's ATK attribute. I want to think of 'ATK' as sort of representing BASE DAMAGE in the game.

Then, DEF would subtract directly from that damage. That's all it is. Very simple.

Here's how it would look:

If Attacker has 20 ATK power and Defender has 5 DEF, then a baseline attack would deal 15 damage.

What's cool about this is that we could have an attack like 'triple punch,' which would do HALF base damage but THREE TIMES. So, the base damage of triple-punch could be thought of as dealing 30 damage. HOWEVER.

If you subtract 5 DEF from each of those three attacks, the total damage is 15.

So, against an opponent who has 5 DEF, the damage of a SINGLE ATTACK which does 20 or a TRIPLE ATTACK which does 30, the final damage is the same.

On the other hand, let's say that the opponent has 7 DEF.

Now, BIG PUNCH (20 base damage) does 13 damage.

BUT, TRIPLE PUNCH (30 base damage) does 9 damage.

In our final example, let's say that Defender has 3 DEF.

BIG PUNCH now does 17 damage.

TRIPLE PUNCH now does 21 damage.

So, what I'm getting at is that this very simple equation for DEF can have very interesting results based on how much damage is being done in a single attack and how many attacks there are.

Higher defense will have a greater impact on multi-hit attacks than it will on single-hit attacks. Or, to put it another way -- if you're an attacker, it would make sense to use multi-hit attacks against opponents that have low DEF and single-hit attacks against opponents which have high DEF. That's kind of cool to me.

We've got a directory for classes which contains directories for each class, and each class directory contains a separate .py file for each ability.

Right now, we have one class, "normal", which has one metaability "slap".

I'm kind of frustrated that MetaAbilities can't have the same name as UnitAbilities. For instance, I like the idea of 'Slap' being a MetaAbility, because there can be several different kinds of slaps, but I would also like for the most basic slap to just be called 'Slap'.

I could implement this just by having the Python classname for the UnitAbility be something like,

"UnitSlap" (which sounds kind of saucy)

but have that class's ability_name attribute just be "Slap".

That fulfills the same purpose. Or, maybe we could just call the MetaAbility 'Slap' MetaSlap instead.

Before the stream, I was thinking about what sorts of non-linear variation we could possibly implement for abilities in the game. The idea has been to make the non-linear variation of abilities return a version of each MetaAbility which isn't strictly better-or-worse than other variations, but rather different.

The problem with this, abstractly speaking, is that I also kind of feel like UnitAbilities that fall under a single MetaAbility should be at least tactically SIMILAR. You should probably use the Ability more-or-less the same regardless of which version you get, which sort of limits what kinds of variation we can have within a single MetaAbility.

For instance, we were talking, before, about having a single MetaAbility with three UnitAbilities under its umbrella:

One which does 100% ATK power.

One which does 50% ATK and 50% status change.

One which does 20% ATK and 80% status change.

Those could be thought of as variations of a single ability, but what makes them distinct is how different they are to use, tactically. It's almost like they're three different abilities which would all belong to different classes.

One is for an attacker. One is for a mix of attacker and inflicter. And once is pretty much really meant for afflicters.

Of course, we just came up with that ability as a quick example of how to implement the MetaAbility system, but it got me thinking about what sorts of similarities and differences really make sense among UnitAbilities that are all shared under a single MetaAbility.

So, look at 'MetaSlap'. Right now, I have two different UnitAbilities underneath it: 'Slap' and 'Double Slap'. Both of these are simple damage-dealing abilities, but one lumps all of the damage into a single attack and the other splits the damage over two attacks -- so the former will be more effective against units with higher DEF and the latter will be more effective against units with LOWER DEF.

And yet, these are still both usable pretty much the same way in the same situations by the same character. It's just that there will be a slightly different result based on which type of Slap this particular got at random.

Okay, so that makes sense to me, but here's where I'm going with this proposal: considering that the ability that you get when you buy out of a MetaAbility is random to some extent, WOULD IT MAKE SENSE for there to be a rare chance that you just get an ability which could be considered somewhat SUPERIOR.

Because, up to this point, we've broken ability variation into two categories: LINEAR, which just randomly makes an ability slightly better or slightly worse, but with the same effect. And NON-LINEAR, which gives you an entirely different ability, with a similar use but perhaps a slightly different effect, but which would be considered to be approximately equally 'good'.

What if we included a rare chance to get a non-linear variation (an ability with a similar use but a slightly different effect) which was just BETTER. What if we included an attack called 'Dick Slap' which was just like a normal Slap except that it has a chance to inflict poison.

There's a problem with this right away, and that's that it sort of invalidates the tactical need for both Slap and Double Slap. Considering the gacha element of the game, a player might just keep buying Slap over and over until they get Dick Slap, and then they'd never have any need for Slap or Double Slap.

But is that necessarily a bad thing? Because buying abilities is going to cost some kind of currency (EXP or whatever) which could also be used to invest into other things. So, if the player really wants this rare but slightly superior version of an ability, they might need to invest a lot of points into getting it which they could otherwise just spend on something more productive. So, maybe it's fine to reward them for taking that chance -- or to reward the rare roll where a unit gets Dick Slap as their first MetaSlap.

I guess, for now, what I'm going to say is that we can consider RARENESS to be a COST of an ability when we're balancing that ability -- but we'd have to be careful. These rare, "superior" non-linear variations would need to be superior only by a small margin so that players can't just farm these rare gachas and create super-powered units.

Dick Slap is a good example of an ability which I think could be balanced effectively against its rareness. Because, maybe it does the same damage as Slap, which is very common, but it has a 10% chance of inflicting short-term poison. Yeah, that's the version you would PREFER. But is it really worth buying MetaSlap over and over to get it? Is a player who's using Slap at a significant disadvantage against a player who has Dick Slap. Not really. I feel like Dick Slap is only a little bit better than Slap. I don't think it's going to be a deciding factor in a match, but it's still maybe a fun reward and adds some interest to the gacha.

Dixx points out that this could be a barrier to new players in a competitive game. If we have players who have been grinding for a very long time, they would likely have access to superior abilities that may have been more rare. I think that this would be a small price to pay to add excitement to the gacha element as long as we maintain that these 'superior abilities' are only VERY, VERY SLIGHTLY SUPERIOR.

SIDE NOTE:

Should abilities print messages BEFORE or AFTER running update_w_rules?

I argue that it would be BEFORE. This is how you would expect a Pokemon to animate before we know whether its attack was actually effective or not.

So basically, as we write these messages to be printed, we shouldn't assume anything about the attack actually WORKING. Language-wise, as long as our game is text-based, we need to write these descriptor messages very agnostically insofar as the ability's actually effectiveness considering our game's Dynamic Rule System.

SIDE NOTE:

We've talked about this before, but I feel like the base AP for a leader unit should be 10, and I want for unit-swapping to cost 3. So, where does the leave the rest of our abilities, tactically-speaking?

With 10 AP, in a single turn, a leader can hypothetically swap units 3 times AND use an ability which costs 1 AP.

What's interesting about that is that it also means that a leader can use an ability which costs 1 AP ten times.

So, it's almost like... no ability in the game should cost 1AP?

I guess I don't see why 1AP abilities shouldn't exist? I mean, maybe it heals you just a tiny, itty-bitty bit? Maybe it does an itty-bitty bit of damage? Fine. But maybe they're kind of rare.

Tactically-speaking, let's return to the scenario that I often lean on when considering unit-swapping costs:

When a turn ends, whatever unit is in the ring will be the most vulnerable to damage. So, you have an incentive to swap in a unit right before the end of your turn.

That also means that when you get your NEXT turn, this unit that you swapped in is going to be the first unit whose abilities you have access to.

If you swap in a unit SOLELY for it to take damage, you would then hypothetically need to swap it OUT at the start of your next turn.

So, you would have 4 AP remaining to use abilities on that turn:

Swap out, use ability, swap in.

Because we don't strictly want to make it EASY for players to swap tanks in and out with no other tactical concerns, we have to believe that having this 4 AP for your turn is a pretty shitty amount to have.

Tell me if you agree with this, from a GAME DESIGN PERSPECTIVE: SLAP is the most basic of abilities because it does 1xATK damage.

From that baseline, we can consider different COSTS for moves that are BETTER, different costs for moves that are WORSE. We can subtract DAMAGE to get OTHER EFFECTS and consider them around the SAME effectiveness as Slap.

I think it stands to reason that, in a game about lowering your opponent's HP to zero, a simple move which just does basic damage based on your unit's attributes is probably a good baseline for 'normal' cost.

Kenny brings up MP, which gives me a chance to reiterate that NOT ALL MOVES COST MP. At least, the way that I imagined it, AP is a secondary cost meant for abilities which would be MORE effective than Slap (baseline ability).

If you're a wizard in an RPG, it's not unusual for you to have abilities that are MORE EFFECTIVE AT DOING DAMAGE (maybe even to a group) than, say, a Warrior. Both Warrior and Wizard are classes primarily focused on dealing direct HP damage, but Wizards are typically better at it, but the difference is that wizards consume MP, so they can't do it as consistently as warriors can. That's sort of how I imagine MP, in our game: some attacks consume it. When you're out of it, you can't use those attacks any more.

I guess here's what I'm asking:

Should 'Slap,' our most basic of abilities in the game, cost 2AP, 3AP, or 4AP. Or more.

Well let's consider a hypothetical scenario, which is probably going to be pretty common in our game: a turn starts and you already have the unit that you want in the ring. And you have no need to change that unit. So, you have 10 AP and you're gonna use it all with this single unit.

So, if Slap costs 2 AP, you can use it 5 times. We haven't really talked about HP vs ATK values on our base units. It also depends on, tactically, how long we want for a base unit to survive. In Pokemon, for instance, units typically die in or two turns.

What we're talking about, here, is really how much strategic flexibility we want to give a team in a single turn. This is kind of a deep subject.

We're talking about strategic flexibility within a single turn. When you swap units, you have access to entirely new abilities. When you swap units, you are protecting the last unit from damage and making a new unit vulnerable to damage.

We're talking about how much YOU, as a player, can GET DONE before your opponent can act.

Now, in Pokemon, you can always only ever get ONE thing done before your opponent can act, and that's very fair.

In our game, you can get more than one thing done before your opponent can even act. So, when we're considering fairness, we need to consider things like synergy and combinations within a single turn. Like, if you're going to make the case for a game where you can take multiple actions within a single turn, we're talking about SETTING THINGS UP and FOLLOWING THROUGH before an opponent can act. How much of that do we really want for a player to be able to do.

A party is 4 units big, and only one of those units is in the 'ring' or 'front row' at a time. Only units in the ring or front row can act and 90% of abilities will only target the unit in the ring / front row (although, unlike Pokemon, units in the back row may be subject to some small aggression).

Another game that I love where you can do tons of shit on a single turn is Disgaea. I grew up with Final Fantasy Tactics where each 'turn' is only one unit long. I was flabbergasted, at first, when I played Disgaea and found that, despite its core gameplay seeming very similar (tile-based tactics), you can take actions with ALL of your party members before your opponent can do anything -- but then, when it's their turn, they can do tons of shit before you can do anything.

And the difference between Disgaea and Final Fantasy Tactics, in that respect, is that there's a lot more TEAMWORK in Disgaea than in Final Fantasy Tactics. You use all of your units to accomplish a single goal.

So, in our game, you can do a few things before your opponent can do anything. What sorts of things are we talking about, here?

Well, you can: swap a healer in, get a heal, then swap the healer out.

Attack multiple times with an aggressive unit (but, maybe at the cost of not being able to swap in a tank -- risk reward).

Inflict a status change and then swap in a unit that can attack the opponent with an ability that capitalizes on that status change (cover opponent in oil, then swap in a unit which can attack with fire).

So, from these examples that I'm dreaming up, it seems like we're kind of hitting a pattern:

swap once, use two abilities
swap twice, use one ability
don't swap at all, use three abilities

You end your turn with an afflicter on the battlefield, and the opponent fails to kill that afflicter on their turn.

When it's your turn, you can afflict with oil, swap out, and then attack with fire all in a single turn.

That's your reward for the risk of leaving the afflicter in the ring between turns.

Alternatively, you could play it safer but over more turns (so you're taking more damage):

Swap out tank, afflict with oil, swap in tank.

Swap out tank, attack with fire, swap in tank.

In these examples, the tank never gets to act. He's just there to absord attacks for the afflicter and the fire-attacker.

So, in the case of slap -- it being our game's most basic ability. Supposing we have 10 AP each turn and swapping costs 3, slap should cost 3?

An ability that's not that expensive (it's not amazing) and it's not that cheap (it's fully effective)... could cost 3. Then you have 1AP remaining to either WASTE (as a punishment for swapping twice) or to spend on some super minor ability (a tiny heal or something, or tiny poke, or tiny buff).

If swapping costs 3, then you could look at abilities that cost '3' as a way to sort of PUNISH double-swapping, to DISCOURAGE double-swapping, to make it harder to play in such a way that you're always having one unit take damage and that's all that it does.

Because if you swap ONCE per turn, you can use two abilities that cost 3 or you can use one that costs 3 and one that costs 4.

If swapping costs '3,' then '3' is that magic number for cost that means you're probably gonna have to waste 1AP in the end, which sucks.

So, here's what we can probably say about AP costs:


'8' is a high-commitment ability because you can't swap at all and you could've used two 'normal' abilities, instead.
'6' is high-commitment. You can still swap, but you could have used two 'normal' abilities.
'5' would be an above-average ability. You can't use if you swap twice.
'3' is a unit swap
'3' or '4' is a normal, basic, but fully-fleshed-out ability
'2' is a soft or auxiliary ability
'1' is an ability that does practically nothing but better than wasting 1 at the end of your turn

Let's make a note about balancing AP costs: you can think about it in terms of "how many times can I swap and still use this ability?," but you also need to think in terms of, "how many abilities could I have used instead of using this ability for the same amount of AP?"

If Slap costs '3,' then a move that costs '6' would need to be more than twice as useful because it's not ONLY twice as expensive, but it's more of a COMMITMENT. It's less tactically flexible than using two abilities that cost 3. Because I can use one that costs 3 and then decide if I want to use another that costs 4, or two abilities that cost 1 and 2 -- breaking up your abilities gives you more flexibility. So an ability that costs 6 would need to be twice as useful or "good" as an ability that costs 3.

Next time, we need to finish implementing the 'costs' for Slap and we're going to create DoubleSlap and DickSlap.

07/10/19

New day, new design decisions to make. What are we gonna do about multi-hit moves that want to roll for crit more than once? I guess we could just call roll_for_effectiveness manually, right? I'm pretty sure that's a method of UnitAbility, so we would just call self.roll_for_effectiveness.

Comparing a move that hits once to a move that hits twice for the same cost, what should the raw damage calculation comparison be?

We've established that moves that hit ONCE are better against foes with HIGH DEF.

Moves that hit TWICE are better against foes with LOW def.

So, supposing that each type of attack has an advantage against different types of opponents, perhaps a 'double-slap' SHOULD do half as much damage per slap.

Let's run some example numbers:

Attacker's ATK is 20
Defender's DEF is 7.

Slap does 13 damage.

Double-slap does 6 damage.

That's less than half as much damage.

Defender's DEF is 3.

Slap does 17 damage.
Double-slap does 14 damage.

Slap still wins.

This is the fallacy. If double-slap does half as much damage per slap, the only way that it can do as much damage as Slap is if the opponent has 0 defense. So, we do need to find some magic-number to help us decide what the multiplier should be for multi-hit attacks to make them compare evenly with single-hit attacks.

I guess, in order to make this calculation, we need to decide on a 'baseline' comparison of ATK and DEF. One thing I've been discovering over the past week is that we need to decide on some 'baseline' values in order to effectively design skills, and this is no different. I don't know, yet, what the 'average' comparison would be between a given unit's ATK and DEF -- and, without knowing that, I can't really find that magic number for what attack multiplier would make multi-hits approximately even with single hits on a 'baseline' unit.

I'm gonna work out Steve's question, here:

Attacker has 20 ATK.
Defender has 7 DEF.

Double-slap does .75 * ATK per hit.

Slap does 13 damage.
Double-slap does 16 damage.

Defender has 3 DEF.

Slap does 17 damage.
Double-Slap does 24 damage.

I guess now is probably the time to start looking at baseline attribute values for a baseline Unit.

Units have what:
* HP
* LP
* MP
* ATK
* DEF
* SKL
* PRY

One thing we have to think about, when defining this baseline unit, is how many turns we want for them to be able to survive if they're on the front row and not being healed.

If you're under attack and you're NOT swapping the unit out and you're NOT healing them, then they shouldn't be able to survive for more than two turns.

We're talking about getting slapped. We're talking about a unit taking its own ATK power as raw damage 3 times in a turn.

If our baseline unit is going to die halfway through its second turn of being slapped, then its HP needs to follow this equation:

hp = (ATK - DEF) * 5
50 = (15  - 5)   * 5
100 = (30 - 10) * 5

Is DEF over-powered, mathematically, compared to ATK? Let's run some example numbers for Slap and Double-slap and see how their damage differs as we invest our points differently. My theory is that, if Defender invents an equal number of points into DEF as Attacker invests into ATK, Defender is getting the better deal.

Attacker has 30 ATK.
Defender has 10 DEF.

Slap does 20 damage.
Double-slap, with a multiplier of .66666~ per hit, does 20 damage.

Attacker has 35 ATK.
Defender has 15 DEF.

Slap does 20 damage.
Double-slap does 16 damage.

I'm not a mathematician, but this phenomena reflects any situation where you're comparing the SCALE of two values after adding the same AMOUNT to both.

2 is 200% as large as 1.
But as soon as you add 1 to both, you get 3 vs 2. 3 is only 150% as 2.

So, now that I've said it out loud, maybe here's a solution:

When you add the same amount to two different values, they always come closer in scale. So, if we want attack and defense to be balanced, perhaps the only thing to do is to have the baseline attack and defense values be exactly the same and re-examine our 'base damage' equation to account for this.

We seem to have two options: accept that DEF is over-powered and make it cost more, somehow. Or try to make DEF even with ATK, somehow.

Dixx points out that we could manually design 'soft caps' into our equations, which is a pretty popular way to solve problems like this. But I've always hated that approach in JRPGs. I feel like it just makes the equations overly complicated and unpredictable to the player unless they know, in advance, where the soft-caps are.

Jeefy points out that, if we want to BALANCE ATK against DEF, we could NERF DEF or BUFF ATK. I guess what I'm thinking, right away, is buffing ATK such that a 'baseline' ability has a multiplier greater than '1' when comparing ATK to DEF.

To be clear, the issue that we're talking about is that our current equation for damage -- our current understanding of how damage is calculated -- favors DEF when ATK and DEF are both given the same number of points on level-up.

SIDE-NOTE: aggressive attributes are ATK (used to calculate damage) and SKL (used to calculate which of the three effectiveness levels we get for our ability, "glancing", "normal", "critical").

Our equation for calculating raw damage, right now, for a baseline ability (like Slap), is this:

damage = ATK * 1 - DEF

So, in our current 'baseline' examples, a baseline unit has 30 ATK and 10 DEF.

So, slap does 20 damage.

The reason that we're using this simple equation (where we're just subtracting DEF from the raw damage in order to get the total damage) is so that multi-hits scale BETTER against opponents that have LOW DEF and WORSE against opponents that have high DEF. The goal is to have multi-hits have a separate tactical use compared to single-hits. Single-hits are more effective against units that have high def. Multi-hits are more-effective against units that have low def.

SIDE-NOTE: SKL and PRY are the analogues for a classic JRPG's "ACCURACY" vs "EVASION." Every JRPG has their own names for these values. In our game, it's "SKL" and "PRY". Skill is the aggressor's attribute to make their attacks more likely to land clean. PRY is the defender's attribute to make their opponent's attacks more likely to land 'off'.

Our problem is that, if our Attacker and Defender both invest all of their points into ATK and DEF respectively, and they level up the same number of times, there will come a point where the Attacker cannot harm the Defender -- where-as you might expect that, if they're both raising their attributes by the same amount, the defender would always be taking approximately the same damage.

The calculation between SKL and PRY has RNG in it. An aggressor with a set amount of SKL and a defender with a set amount of PRY will not always result in the same effectiveness when a given skill is used.

Dixx puts forward the idea of a 'tertiary stat' which augments how effective the DEF stat is -- a multiplier. And 'DEF' is just a value that's set in stone per unit. I don't know if that solves our problem.

In fact, when we decided to implement 'DEF,' that was sort of its idea: it's already a tertiary value.

So, my original idea was to have NO DEF in our game, similar to Final Fantasy Tactics, which I've always admired for the fact that it simplified its JRPG trappings by replacing DEF with 'more HP.' The question came up, in one of our early-on design streams, "what is the point of having DEF when you can just have more HP."

And I think it was Dixxucker who raised the idea that a DEF value could create an interesting sliding-scale when you're talking about how individual abilities 'overcome defense.'

And I liked that idea, and we settled on this notion that BIG, HEAVY, SINGLE-HIT ATTACKS would be better at getting 'over' DEF and smaller, multi-hit attacks would be more RAW damage but would have trouble conquering defense.

Therefore, if you observe that your opponent has lower-than-average defense, it would make more sense to use multi-hit attacks for their raw damage.

But if you observe that your opponent has higher-than-average defense, your multi-hits would have trouble cresting OVER that defense value, and so the best way to get damage for your money is to use an equal-costing single-hit attack.

So, basically, DEF is already sort of a tertiary or auxiliary attribute that augments your HP.

Dixx says, "Don't make 1 ATK = 1 DEF," and that's exactly what I'm talking about. I'm saying that one solution, which is the most attractive to me, right now, is to make the 'baseline ability,' Slap, deal some multiple of ATK greater than 1 on "normal" effectiveness.

So, right now, the baseline attack in the game -- which all other attacks are based around -- is Slap, and it does 1 * ATK for its raw damage, which means that, as dixx puts it, ATK = DEF.

So what if, for our most basic attack -- and all attacks that behave similarly -- we raise the mutliplier for how effective 'ATK' is at creating raw damage.

Let's just suppose -- and run some numbers, because I'm lazy and don't want to try to figure out, in an abstract sense, what the result would be without experimentation -- that a 'normal' effectiveness Slap calculates it damage with 1.5 * ATK. Let's see how that changes things. By extension, I guess Double Slap would do *1 damage.

Attacker has 30 ATK.
Defender has 10 DEF.

Slap now does 35 damage.
Double-slap now does 40 damage.

Attacker has 40 ATK.
Defender has 20 DEF.

Slap does 40 damage.
Double-slap does 40 damage.

To repeat: any time you have two different values and you add the same amount to them, the lower value is going to come closer to the higher value in terms of their respective scale.

So, because DEF is lower than ATK, if you add the same amount to both, DEF is going to always be getting closer to ATK in scale.

It seems to me that we need to make the default ATK and DEF the same value and then create an equation around that which would have our unit die in 5 slaps. We need to adjust the damage of slap and the amount of HP the unit has.

So let's re-examine our equation.

Our old equation was this:

hp = (ATK - DEF) * 5

hp = (damage) * 5

Where damage is some value that we can get from ATK and DEF being exactly the same. In our old equation, if a unit has the same value for ATK and DEF, he cannot damage himself with Slap; he takes 0 damage. Our goal, with this new equation, is to change that. Now, he has the same value for ATK and DEF, and, when he slaps himself, he dies in 5 slaps.

We're trying to design the stats for a 'basic' unit which we can base all other units off of. Other units might favor defense over offense. Other units might favor high HP over both. But, in order for us to decide what 'pros' and 'cons' each unit brings to the table, we need to define what a 'baseline, normal, run-of-the-mill, no exceptional advantages-or-disadvantages' unit looks like.

So, I'm theorizing that it would be for the best for an 'average' 'normal' unit to die in 5 'average' or 'normal' attacks. That means that they would die in a turn-and-a-half of being vulnerable. Meaning that, strategically, if you want for a unit to survive for more than a turn, you probably need to heal them or swap them out before a turn-and-a-half. That's where the number '5' comes from.

So, by my estimation, a 'basic' unit would need enough HP to survive 5 hits of our basic damage calculation.

Our attacker and defender are, at level 1, the same unit. We could talk about a unit 'slapping themselves.' So, our old equation was:

HP = (ATK - DEF) * 5

DEFENDER_HP = (AGGRESSOR_ATK - DEFENDER_DEF) * 5

Our game is going to have lots of different types of units with lots of different advantages and disadvantages.

In order to keep things balance, whenever a unit has a particular advantage in one area it would need to have a disadvantage in another area.

This is true of Abilities and Classes as well: whenever you GIVE SOMETHING to a unit / class / ability, you need to take something away.

Until we establish a 'baseline' for these sorts of ideas, we don't know what qualifies as an advantage or a disadvantage. We need some kind of generic object to represent a unit / class / ability which has no particular advantages or disadvantages so that we can design around these.

To answer Dixx's question about opponent generation in single-player, I figure that we'll be using a similar approach to Pokemon: opponent type at level 1, all their stats multiplied to whatever level they're supposed to be at. Supposing that they continued to invest their points in equal proportion to whatever respective scales they started with.

The idea is to figure out how much damage Slap should do. In order to understand how much damage slap should do, we need to understand how much HP a hypothetical opponent has. And in order to figure that out, we need to figure out how fast we want them to die (5 slaps) and how their def factors into this.

That's what we're stuck on.

I don't think we're going to be scaling anything about the opponents, in singleplayer, based on the player's attributes. That would be Elderscrolls-esque -- scaling opponents based on player. In our case, I always imagined it being more traditional: enemies in a certain area are a certain level, and their attributes are based on their 'base' attributes (but scaled up to their level), and the player has to be strong enough to survive in that area or go get stronger.

Tomorrow, in this timeslot, we need to examine in greater detail the equation for calculating raw damage in consideration of 'ATK' and 'DEF'. What is the most basic way to use those attributes of the attacker and defender respectively to calculate damage in such a way that it scales neatly to different levels and we get our expected behavior for the difference between 'mutli-hit' and 'single-hit' attacks.

Single-hits are supposed to do more damage to an opponent who has above-average DEF than a mutli-hit would.

Multi-hits are supposed to do more damage to an opponent who has below-average DEF than a single-hit would.

Therefore, an opponent who has exactly average defense should take the same damage from an attack that does a single-hit versus an attack that does a multi-hit.

Defender DEF+: single-hit more effective, multi-hit less effective
Defender DEF-: single-hit less effective, mutli-hit more effective
Defender DEF=: single-hits and multi-hits do the same damage

Considering this future equation, I believe that we need to have ATK and DEF be equivalent in value if we want for them to cost the same amount to level-up. If they aren't equivalent, we're going to see a problem of scale.

07/11/19

Last night, I was thinking about different equations that we could use for calculating damage to get the effect that we want and I didn't have a whole lot of luck. I feel like this is the sort of thing that's going to require quite a bit of thought -- but I did have one idea that I want to step through, here.

I had this idea where the ATK vs DEF calculation is the factor deciding 'bonus damage.' My gut says that this isn't going to be a fun way to calculate damage, but, based on my early estimations, it seems like it might be more effective than it first appears.

Let's say that a baseline unit has 25 HP and that Slap and Double Slap are supposed to do 5 damage supposing that the attacker and defender have the same value for their attack and defense.

So what if we did something like this:

final_damage = damage_constant_of_ability + (ATK - DEF)

In this example, 'Slap' would have a damage-constant of 5.

I can already see a problem, here, but let's follow-through with what I was thinking, anyway.

If the attacker has 1 more ATK than the defender has DEF, Slap now does 6 damage. If the Defender has 1 more DEF than the attacker has ATK, then Slap does 4 damage.

On the one hand, I feel like this is a pretty good incentive for players to raise their units' ATK and DEF. Because it makes both very strong. Equally strong, even.

The problem is that we start to see a situation where the BONUS DAMAGE dramatically outscales the DAMAGE CONSTANT. If a unit continuously pumps their ATK value at every level-up, they might have a damage bonus of 20 or whatever. At that point, the difference between Slap (5 damage constant) and poke (1 damage constant) is relatively little, but Poke only costs 1 AP, so it becomes a much more attractive option.

That's the problem with this 'bonus damage' idea.

My gut tells me that, whatever we do, it's going to need to rely on some MULTIPLIER. Hang on. I'm getting a Jimmy Neutron brain-blast.

Maybe the difference between ATK and DEF can create some kind of bonus as a multiplier -- not as a sum. I wonder if that would give us better Double-Slap against lower-defense opponents, like we want, but let's test it.

Let's say that Attacker has 15 ATK and Defender has 12 DEF.

So, we would need to find out, mathematically, what percentage higher 15 is over 12.

15 is 125% as big as 12. So, we could say that the 'damage constant' of Slap (5) gets a 25% increase.

Slap does 6.25 damage.

Double-slap does 2.5 base damage. So, double-slap does 6.25 damage.

So, I like this equation. It seems fair, it seems sensible. The problem with it is that it doesn't scale Slap differently to Double Slap depending on whether the opponent has 'low' or 'high' or 'average' DEF.

What I don't like about this is that, with no 'bonus damage' calculation -- no 'subtraction' -- we end up in situations where you would need to have insanely high ATK in order to, for instance, get double-damage on an opponent with moderately high DEF. But maybe that's for the best.

It seems weird to me that, an attacker with 20 ATK hitting a defender with 10 DEF would do 10 damage with Slap.

But, also, an attacker with 100 ATK hitting a defender with 50 DEF would also only do 10 damage with Slap.

I'm not sure that's a bad thing. You could argue that it just helps us keep our HP values in check. I mean, yeah, we could give units 300 HP instead of 25, but the effect is the same, right? If you pump twice as much points into ATK as your opponent put into defense, you're gonna do twice as much damage.

If we want for multi-hits to do more damage against low-defense opponents, we're GONNA NEED some kind of subtraction in our algorithm. Some kind of linear SOMETHING. Or, we could factor in some kind of multiplier for 'number of hits'.

Like, DEF has to create some kind of 'barrier' that an attack has to OVERCOME, you know what I mean? In order for HEAVIER ATTACKS to scale better over high defense than LIGHTER ATTACKS. We have to create some kind of threshold.

Like, we need one more layer. We get our RAW DAMAGE from the ability's damage-constant multiplied by the percentage difference between ATK and DEF. After we get our RAW DAMAGE, we need some sort of threshold layer for that damage to go up against. The threshold layer would also need to be based on the percentage difference between ATK and DEF, I feel like, but it's linear: it involves subtraction.

The threshold, I feel like, would almost certainly need to factor in the ability's damage constant...? To get a sense of scale...? Well, no, that hardly makes sense because the idea is that heavier-hitting attacks would be better at crossing the threshold.

If you have 100 ATK and I have 50 DEF, my DEF is 50% as big as your ATK. How can I make that into a sensible threshold that would allow heavier-hitting attacks to cross the threshold sooner than lighter-hitting attacks?

We could consider Dixx's suggestion of a 'tertiary attribute' that would help with these calculations? Like, what if it was based on Max HP. Like, there's some kind of additional bonus damage (this doesn't really help) based on what percentage of my total HP your raw damage would subtract. That would definitely favor heavier-hitting attacks -- but the problem is that we want to reward multi-hits against opponents that have low DEF. Reward them more than single hits.

Using 'Max HP' as a multiplier for damage taken sort of reminds me of Steamband, which is a game that we're already taking inspiration from insofar as the 'LP' system. But Steamband had these values called 'WP,' or 'Wound Points,' which worked fairly similarly to SaGa's LP or 'life points,' except that, when you took a hit, there was always a chance that you could lose WP, and the percentage of your max HP that was subtracted from that hit was multiplied by .5 to get the percentage chance of losing WP.

So, if you took half of your health in a single hit of damage, you would have, like, a 25% chance of losing WP. So, heavier hits were rewarded with a much higher chance to lose WP.

So maybe we could create some kind of 'bonus damage' system based on what percentage of your health you lost from a single hit. Multi-hits would have a higher damage-constant OVER-ALL (considering the number of hits), but no single hit would do as much of your HP as a heavy attack would, so the heavy attack would get a more substantial bonus?

But the problem with this, at least the way that I'm conceiving it, is that, as long as there is no linear threshold, the bonus damage from the multi-hits would necessary eventually add up to the bonus of the single-hit. I'm no mathematician, but I'm pretty sure that's how multiplication works.

Let's just say that attacks get bonus damage of their damage-constant times the percentage HP they removed from the opponent.

Our example equation is this, for total damage:

raw_damage = damage_constant * (ATK / DEF)
bonus_damage = raw_damage * (raw_damage / max_hp)
total_damage = raw_damage + bonus_damage 

So, let's look at an attacker with 10 ATK and a defender with 10 DEF and 25 HP.

raw_damage = 5 * (10 / 10)
total_damage = 5 + 5 * (5 / 25)

total_damage = 6

Now, let's use double-slap:

raw_damage = 2.5 * (10 / 10)
bonus_damage = 2.5 * (2.5 / 25)
total_damage = 2.5 + .25

multi-hit = 2.75 * 2 = 5.5

It penalized double-slap. The only problem is that, at even ATK and DEF, we want for Double Slap to do the same damage as Slap. But what was a success was that our harder-hitting attack ended up doing more damage than our multi-hit because of the bonus it got for doing heavy damage.

So, what we've created here, successfully, is an equation that rewards heavier hits. Could we just solve this problem, now, by giving multi-hits a greater damage-constant to compensate? Right away, I would argue not, because I still think that, if the opponent has LOWER DEFENSE, multi-hits and single-hits are always going to scale the same in this equation... maybe.

Dixx is raising some questions about our old equations, so let's compare them:

Our old way of doing things was for abilities to have a DAMAGE MULTIPLIER which would influence damage directly based on the attack's ATK.

So, if attacker has 10 ATK and Slap has a 'damage multiplier' of 1, then Slap does 10 damage. And then we would subtract the defender's DEF to get the real damage.

In our new system, abilities don't have 'damage multipliers' but rather 'damage constants.' I think that's the core difference. So, now, we say that Slap has a damage constant of 5 -- it does 5 damage supposing that the attacker and defender have the same amount in their respective stats. And then we use the difference between attack and defense to figure out how much to add to or reduce from that value. This way, atk and def always have the same value to the player.

Something we considered, today, was creating a hybrid: the old, linear, subtraction-based system using damage-constants instead of damage-multipliers, and it didn't work. It would've looked like this:

total_damage = damage_constant + (ATK - DEF)

That way, if ATK and DEF are the same, slap does 5 damage (its damage constant). The problem with that is that, the damage constant is quickly made obsolete by the difference between ATK and DEF. If an attacker pumps ATK heavily for every level-up, they might have 20 more ATK than the defender has DEF.

At that point, Slap does 25 damage. The argument could be made that it was the defender's responsibility to raise DEF as much as attacker raised ATK, but the real problem with this is not that the attacker is being rewarded with damage 5x what Slap would have otherwise done; the problem is that the attacker can now use Poke (1 damage-constant) for 1 AP and it'll do 21 damage. That makes it extremely to Slap for that player, but at a much cheaper cost. Also, it means that, while Slap goes from 5 to 25 damage (5x damage), Poke goes from 1 to 21 damage (21x damage).

So, it doesn't work.

And the reason that the original equation of:

total_damage = damage_multiplier * ATK - DEF

doesn't work is because, as both ATK and DEF are raised evenly, the benefit of raising ATK gets much lower compared to the benefit of raising DEF.

total_damage = 1 * 10 - 5

5 damage

total_damage = 1 * 20 - 15

5 damage

This is apparently working fine, but it doesn't serve us correctly for rewarding multi-hits on opponents that have 'lower than average DEF.'

GOOD: w/ 10 atk & 5 def
    slap
    total_damage = 1 * 10 - 5 = 5

    double slap
    total_damage = (.75 * 10 - 5) * 2 = 5

GOOD: w/ 10 atk & 3 def
    slap
    total_damage= 1 * 10 - 3 = 7

    double slap
    total_damage = (.75 * 10 - 3) * 2 = 9 

BAD: w/ 20 atk & 13 def
    slap
    total_damage = 1 * 20 - 13 = 7

    double slap
    total_damage = (.75 * 20 - 13) * 2 = 4






STRICTLY LINEAR ATK-DEF SCALING, ABILITIES HAVE DAMAGE MULTIPLIERS:
    total_damage = damage_multiplier * ATK - DEF

    + As long as the difference between ATK and DEF is the same, Slap does
      the same damage.
    + As DEF falls lower and ATK stays the same, multi-hits are rewarded
      more.
    - Even if the difference between ATK and DEF is the same, Double Slap
      loses damage. This is because DEF gets closer to ATK in scale. When
      you raise two values evenly, the lower value gets closer to the
      higher value in scale.

    GOOD: w/ 10 atk & 5 def
        slap
        total_damage = 1 * 10 - 5 = 5

        double slap
        total_damage = (.75 * 10 - 5) * 2 = 5

    GOOD: w/ 10 atk & 3 def
        slap
        total_damage= 1 * 10 - 3 = 7

        double slap
        total_damage = (.75 * 10 - 3) * 2 = 9 

    BAD: w/ 20 atk & 13 def
        slap
        total_damage = 1 * 20 - 13 = 7

        double slap
        total_damage = (.75 * 20 - 13) * 2 = 4


LINEAR ATK-DEF SCALING, ABILITIES HAVE DAMAGE-CONSTANTS
    total_damage = damage_constant + ATK - DEF

    + If ATK and DEF are the same, then total_damage is equal to damage-
      constant.
    + If ATK and DEF are raised evenly, then this is always true.
    + Which means that ATK and DEF have equal value to the player.
    - As ATK raises over DEF, the damage-constant is quickly outclassed by
      the bonus damage.
    - This means that, for stronger characters, the difference between Slap
      (5 AP cost for 5 base-damage) and Poke (1 AP cost for 1 base-damage)
      is significantly less, making Poke extremely overpowered.
    - The opposite is also true. If DEF outclasses ATK by the damage
      constant (a very small number), that attack is completely nullified.
    - In other words, pretty quickly, most of the damage you're getting is
      from the bonus damage. The damage constant stops mattering.

    GOOD: 10 ATK & 10 DEF
        slap
        total_damage = 5 + 10 - 10 = 5

        double slap
        total_damage = (2.5 + 10 - 10) * 2 = 5

    KIND OF GOOD: 15 ATK & 10 DEF
        slap
        total_damage = 5 + 15 - 10 = 10

        double slap
        total_damage = (2.5 + 15 - 10) * 2 = 15

    KIND OF GOOD: 10 ATK & 13 DEF
        slap
        total_damage = 5 + 10 - 13 = 2

        double_slap
        total_damage = (2.5 + 10 - 13) * 2 = 0

    BAD: 30 ATK & 10 DEF
        slap
        total_damage = 5 + 30 - 10 = 25

        double_slap
        total_damage = (2.5 + 30 - 10) * 2 = 45

BONUS-DAMAGE CALCULATED BY THE PERCENTAGE DIFFERENCE BETWEEN ATK & DEF
    total_damage = damage_constant + damage_constant * (ATK / DEF)

    + When ATK and DEF are the same, Slap and Double Slap do the same
      damage, regardless of how high ATK and DEF are.
    + When ATK is twice DEF, Slap and Double Slap do double damage.
      Compared to previous equations, this is much more respectful of
      scale.
    - It doesn't provide any difference in damage for single or multi-hits
      based on whether DEF is higher than ATK or vice-versa.

    GOOD: 10 ATK & 10 DEF:
        slap
        total_damage = 5 + 5 * (10 / 10) = 10

        double slap
        total_damage = (2.5 + 2.5 * (10 / 10)) * 2 = 10

    KINDA GOOD: 15 ATK & 10 DEF
        slap
        total_damage = 5 + 5 * (15 / 10) = 12.5

    BAD: 15 ATK & 10 DEF
        double slap
        total_damage = (2.5 + 2.5 * (15 / 10)) * 2 =  12.5

THE ABOVE BUT WITH DAMAGE BONUS BASED ON SINGLE-HIT DAMAGE
    raw_damage = damage_constant + damage_constant * (ATK / DEF - 1)
    bonus_damage = raw_damage * (raw_damage / max_hp)
    total_damage = raw_damage + bonus_damage

    + Rewards heavier hits with more bonus damage.
    - It doesn't reward heavier hits less when DEF is higher than ATK.
    - So, there's still no advantage to multi-hits.
    - WHENEVER you do MORE DAMAGE with a SINGLE HIT, you get a GREATER
      BONUS. How can we write an equation that uses this to our advantage?
    ? But what if the damage-constant for multi-hits was higher?

    KINDA GOOD: ATK 10 & DEF 10 & HP 25
        slap
        raw_damage = 5 + 5 * (10 / 10 - 1) = 5
        bonus_damage = 5 * (5 / 25) = 1
        total_damage = 5 + 1 = 6

        double slap
        raw_damage = 2.5 + 2.5 * (10 / 10 - 1) = 2.5
        bonus_damage = 2.5 * (2.5 / 25) = .25
        total_damage = (2.5 + .25) * 2 = 5.5

    BAD: ATK 12 & DEF 10 & HP 25
        slap
        raw_damage = 5 + 5 * (12 / 10 - 1) = 6
        bonus_damage = 6 * (6 / 25) = 1.44
        total_damage = 6 + 1.44 = 7.44

        double slap
        raw_damage = 2.5 + 2.5 * (12 / 10 - 1) = 3
        bonus_damage = 3 * (3 / 25) = .36
        total_damage = (3 + .36) * 2 = 6.72

For next time: what we've been struggling with is creating a damage-calculating equation that satisfies all of these needs:

1.) When DEF and ATK are even, attacks do their 'base' damage.
2.) When DEF and ATK are even, single-hit attacks and their sibling multi-
    hit attacks do equal damage.
3.) When ATK is greater than DEF, multi-hit attacks do more damage than
    their single-hit siblings.
4.) When DEF is greater than ATK, single-hit attacks do more damage than
    their multi-hit siblings.

Many of our equations, tonight, have satisfied many of these requirements -- but none have satisfied all of them.



07/15/19

After our last stream, Panders came up with an equation that he thinks should meet all of the criteria that I was putting forward during our stream. Afterward, Kenny created a spreadsheet to demonstrate that equation and found it to be very satisfactory.

Let's have a look at it, here.

DMG FORMULA:  ((ATK / DEF) * (Slap Base Damage + (ATK - DEF) / 2)) * NUM_OF_HITS

Let's break this down, theoretically:

So, just like in some of my previous example equations, we're using the 'percentage scale' of ATK over DEFENSE as a multiplier against the base damage.

I think, for the most part, this equation looks like something we've already done:

total_damage = base_damage * (ATK / DEF)

In Pander's equation, the base damage, BEFORE THE MULTIPLIER, is being altered.

total_damage = (base_damage + (ATK - DEF) / 2) * (ATK / DEF)

I think that the profound thing about this equation is that the BASE DAMAGE gets a buff. I think that's what I was missing in my own equations, but let's look a bit deeper.

You could break up the equation like this:
bonus_damage = (ATK - DEF) / 2
offense_multiplier = ATK / DEF
total_damage = (base_damage + bonus_damage) * offense_multiplier

It seems to me that the shortcoming of this equation is in the same vein as the last equation I tried which used linear bonus damage. Will there come a time -- maybe even very quickly -- where the BONUS DAMAGE outweighs the BASE DAMAGE such that WEAKER ABILITIES become more efficient than STRONGER ABILITIES.

To test this, we need to look at another ability: 'Poke'. Poke has a base damage of 1.

There's something wrong with DEF in this equation. It seems like raising DEF is extremely strong.

At 20 ATK vs 10 DEF, the damage of Slap triples and the damage of double-slap quadruples.

At 10 ATK vs 20 DEF, the damage of Slap is reduced 75% and the damage of double-slap is reduced 100%.

This seems to be something to do with the 'bonus damage' going into the negative and quickly overwhelming the base damage. So, the problem I predicted.

We can probably also demonstrate this with 'Poke'.

With 20 ATK, 10 DEF, and an attack with a base-damage of '10,' we get 30 damage.

With a base-damage of '1,' we get 12 damage.

But I still think I can prove my point.

Once you get to 100 ATK vs 50 DEF, going from Slap (5 base damage) to Poke (1 base damage) results in a damage loss of ~30%. Where-as you might expect a damage loss of ~80%.

The difference seems much more extreme when DEF is higher.

How can I examine this issue better?

With +20% ATK over DEF, single-hits do +32% damage and multi-hits do +44% damage. Seems legit.

With +20% DEF over ATK, single-hits do -25% damage and multi-hits do -33% damage.

with +50% ATK over DEF, single-hits do +87% damage and multi-hits do +22% damage.

With +50% DEF over ATK, single-hits do -50% damage and multi-hits do -66% damage.

I guess I feel like, when you have twice as much ATK as they have DEF, Slap should do twice as much damage -- and when you have half as much ATK as they have DEF, Slap should do half damage -- but I don't think that's reasonable because of how we're calculating a 'defensive threshold.' I think that idea is maybe incompatible with the idea of a defensive threshold.

Slap is getting a bonus for every point over ATK that it is.

We're augmenting the base damage based on the DIFFERENCE between ATK and DEF. And then we're multiplying that by the percentage difference if ATK and DEF.

By augmenting the base damage by the DIFFERENCE between ATK and DEF, we're giving a bonus to... any attack when ATK is higher than DEF.

But, compared to the base damage, that bonus is more significant when base_damage is lower.

If we get 2 bonus damage and add that to slap, we get 12 base damage. An increase of 20%.

If we get 2 bonus damage and add that to double-slap, we get 7 base damage. An increase of nearly 50%.

The bonus damage rewards weaker hits more.

The bonus damage scales better for weaker hits.

Does this mean that weaker, and cheaper, abilities become more cost-effective against foes that have lower defense than stronger, more-expensive abilities? It would seem 'yeah,' but maybe that's not necessarily a bad thing. Maybe that's exactly what you expect. When you pay more for heavier-hitting abilities, you're not just paying for the raw damage -- you're paying for the ability to penetrate defense. So as long as you have high ATK, you can get more mileage out of weaker abilities and not need to worry as much about more expensive, harder-hitting abilities.

The thing about the bonus damage is that it ignores scale entirely. And that's by design -- that's exactly what we've been talking about for weeks. That's what it's supposed to do. The higher your ATK is over their DEF, the more damage you get, right? So if I have 100 ATK and you have 50 DEF, my ATK may only be double your defense, but I'm also 50 fucking points higher than you in DEF.

Is that how I want to look at this? Get bonus damage for every point over your DEF I have in ATK?

I'm starting to formulate an idea based on Panders' equation, here. I think the real profundity of Panders' equation is that he augments the BASE DAMAGE as the way to get bonus damage.

But I think my idea won't work -- because, again, it relies on SCALE more than LINEAR ADVANTAGE. I think we NEED an element of linear-advantage in order for us to have this 'defense threshold' idea.

But my idea would be like this:

total_damage = (ATK / DEF) * (base_damage + base_damage * (ATK / DEF))

That would award bonus damage to scale with the base damage and the scale difference between ATK and DEF.

But, whenever I try to do things this way, it seems like Slap and Double-slap always end up doing the same damage.

Let's break it up:

damage_multiplier = (ATK / DEF)
bonus_damage = base_damage * damage_multiplier
total_damage = (base_damage + bonus_damage ) * damage_multiplier

10 ATK, 10 DEF
Slap = 10
Double Slap = 5

Slap damage = 20
Double slap damage = 20

20 ATK, 10 DEF

Slap damage = 60
Double Slap damage = 60

I think this works, but the scale is out of whack. We need to downscale the bonus damage a lot. We need to make the bonus_damage more in-scale with the base damage.

What if bonus_damage = base_damage * damage_multiplier - base_damage

I wonder if the second damage-multiplication is necessary. Maybe yeah.

Equation change:

bonus_damage = base_damage * damage_multiplier - base_damage

This effectively scales bonus damage better for attacks that are weaker.

My problem, cognitively, is that I want everything to scale 'neatly,' but that's contrary to the very notion of what I'm trying to accomplish: the effect of some kind of linear threshold.

The equation has to have some kind of linear factor in order for me to have some kind of linear result. But I'm scared of introducing a linear element because that introduces scale problems.

We're working on a JRPG. In any JRPG, you have damage-calculations based on ATK vs DEF, including some other factors (in our case, simply an ability's base-damage).

We have ATK. We have defense. We have some abilities which are meant to have higher 'base-damage' than others.

What we're trying to accomplish is to have WEAKER ABILITIES SCALE BETTER than STRONGER ABILITIES in the case that the attacker has more ATK than the defender has DEF.

The idea being that, if your opponent has more DEF than you have ATK, weaker abilities will scale MORE POORLY where-as stronger abilities will scale MORE FAVORABLY.

And the opposite is true.

So, when choosing which ability you want to use, you have to consider the difference between your ATK and the enemy's DEF. If you have more ATK than them, it's likely more effecient to hit them with 'weaker' abilities, because they scale better when ATK is greater than DEF.

If the enemy has more DEF than you have ATK, it's more likely that you should use abilities that are 'stronger' to overcome that difference. Because the more DEF the opponent has over your ATK, the shittier your weaker-abilities will scale.

My thing is that, any time we just use a MULTIPLIER for damage, weaker attacks and stronger attacks are going to scale the same way. I feel like we need to introduce a linear element -- in other words, at some point, something's gotta get added or subtracted. We can't just keep multiplying everything.

We're talking about a defensive threshold.

We're talking, in the abstract, about a JRPG system where "stronger attacks are better at 'breaking through defense', but weaker attacks are better at 'doing damage' when you don't need to break through defense."

Both Max and Vex put forth the idea that there's no way to do this without running an 'if' on whether ATK is higher than DEF.

Here's why you don't need to do it with an if:

Let's look at what Max said:

If ATK is greater than DEF, then multiply by > 1. If ATK is lower than DEF, then multiply by < 1.

Here's our requirements, as I understand them, and they may very well be conceptually flawed such that it's not possible:

ATK = Aggressor's offensive power.
DEF = Defender's defensive power.
base_damage = the essential 'damage' inherent to the ability

We have two hypothetical abilites: Slap and Double Slap.

Slap has base_damage = 10.
Double Slap has base_damage = 5
Double Slap hits twice.

REQUIREMENTS:

1.) If ATK and DEF are equal, then Slap and Double Slap do the same damage.

2.) If ATK > DEF, then Double Slap does more damage than Slap.

3.) If DEF > ATK, then Slap does more damage than Double-Slap.

PANDERS GODLIKE EQUATION:

damage_multiplier = ATK / DEF
bonus_damage = (ATK - DEF) / scale_factor
total_damage = (base_damage + bonus_damage) * damage_multiplier / scale_factor

The reason Panders' equation works is that it gives (and takes away) bonus damage based on the linear difference between ATK and DEF.

You get fixed bonus (or penalty) damage based on the linear difference between ATK and DEF.

The reason it works is because it has this linear bonus / penalty applied directly to the base_damage but also scales ALL of the damage based on a multiplier.

It scales ALL damage based on this multiplier, but it also provides this linear boost to base_damage.

The bonus 4th requirement for our equation is that "bonus damage" never becomes so high that it trivializes the base damage.

PANDERS EQUATION:
damage_multiplier = (ATK / DEF)
base_damage = some_constant
bonus_damage = (ATK - DEF) / scale_factor
pre_multiplied_damage = base_damage + bonus_damage
total_damage = pre_multiplied_damage * damage_multiplier


SPACE_BUTTS UNTESTED EQUATION:
(base_damage * 0.5) + (base_damage * (ATK / DEF) * 0.5)


Quentin's equation
ATK ** DMG_SCALE / max(ATK, DEF)

I like, in Pander's equation, that, in the end, the damage is multiplied by (ATK / DEF). And because he applies the bonus / penalty as a linear value to base_damage, we see that bonus or penalty be scaled by ATK / DEF.

Do we need a penalty? Can we just bottom-out ATK - DEF at 0? I think we need SOME kind of penalty, right?

If DEF is higher than ATK, you suffer a penalty to your base damage. Why does this impact multi-hits more?

Because the bonus / penalty is a linear value added directly to the base_damage, it always scales more dramatically with lower base_damage.

You guys are talking about making the base_damage of Double Slap a constant, where-as before it was slap_base_damage / number_of_hits.

VEXOS EQUATION

slap_base_dmg = (DEF / ATK + 1) + 8
double_slap_base_dmg = (ATK / DEF + 1) + 3

Panders calculates bonus damage linearly from the difference between ATK and DEF. He adds that bonus damage directly to the base_damage.

Then the whole thing gets multiplied by the damage-multiplier.

Panders is talking about a way to ADD DAMAGE at the very end, after the multiplier.

bonus_damage = (ATK / DEF) / 2
damage_multiplier = ATK / DEF
total_damage (base_damage + bonus_damage) * damage_multiplier

In Panders new equation, at even ATK & DEF, Slap does 12. Double-slap does 14.

BACK TO THE PANDERS RIDDLE

I think the reason that panders' first equation works so well is because it augments the base damage by a linear value that's the result of a comparison between attack and defense.

It adds a value to the base_damage and then multiplies the whole thing by the damage multiplier.

I think, to make it work right, we need to examine that value that is being added to the base_damage.

Panders says that, by adding base damage to the entire damage at the end, higher-damage moves are affected by high defense less. That's totally true.

I'm trying to think of where this breaks down, because I don't think that adding damage at the end is our solution.

Here's a reason that I consider the original panders equation to be broken:

If the defender invests TEN MORE POINTS into DEF than the aggressor has invested into ATK, double-slap does no damage.

This becomes the case once you get into the range of 50 vs 60.

I always keep saying this, and mabye the reason that I can't solve this problem is because I'm trying to marry two ideas that are just not compatible.

I'm trying to combine a LINEAR scale and a scaled-scale. I'm talking about how I want both of these things which maybe can't be had together:

If ATK and DEF are equal, it stands to reason that the ability should do approximately its base damage.

If ATK is double DEF, it stands to reason that the ability should do approximately twice as much damage.

If DEF is double ATk, it stands to reason that the ability should do approximately half as much damage.

BUT.

There needs to be SOME accounting for 'penetration.' The problem is, how do you have penetration make sense while still showing SOME respect for the scale I mention above.

I always keep saying this, and it's a trap that my mentality -- my limited understanding of math -- keeps putting me into. I keep saying, "we need to scale this penetration, as well." That seems to be the only way for '200% ATK does approximately twice as much as 100% ATK' to be married with 'but there is a bonus for the actual difference between ATK and DEF'.

What if we took THE DIFFERENCE between atk and defense and SCALED THAT by the scale of ATK to DEF.

I think I'm onto something, but I always think that.

Panders has this 'scale factor' in his original equation, which is .5. He told me, originally, that we could change this scale-factor to make the the difference more-or-less dramatic.

ATK Advantage is calculated as (ATK - DEF) / DEF
Double Advantage is calculated as Double - Slap / Slap


ATK 15
DEF 10

ATK +50% advantage

Slap: 26.25
Double: 37.5

Double +43% advantage


ATK 30
DEF 20
ATK +50% advantage

Slap: 37.5
Double: 60

Double +60% advantage

So far, this actually seems to be working. We are keeping more-or-less in-scale with ATK vs DEF, but with a relatively (?) slight bonus being added for the LINEAR DIFFERENCE between ATK and DEF.

In the first test, ATK was only 50% greater than DEF. And it was 5 linear points away. Double-Slap did 43% more damage than Slap.

So, at 50% more ATK than DEF and 5 points of advantage, Double-Slap did 43% more damage than Slap.


In the second test, ATK was only 50% greater than DEF. And it was 10 linear points away. Double-Slap did 60% more damage than Slap.

So, at 50% more ATK than DEF and 10 points of advantage, Double-Slap did 60% more damage than Slap.

What I'm getting at is that, although we are getting a JUICY BIT OF BONUS DAMAGE for the LINEAR difference IN POINTS between ATK and DEF, it's still highly appreciative of the SCALE DIFFERENCE between ATK and DEF (50% advantage for ATK)

What I'm getting at is that, although we are getting a JUICY BIT OF BONUS DAMAGE for the LINEAR difference IN POINTS between ATK and DEF, it's still highly appreciative of the SCALE DIFFERENCE between ATK and DEF (50% advantage for ATK).

All other things being equal, when the POINTS ADVANTAGE between ATK and DEF went from 5 to 10, Double-Slap's advantage over Slap went from 48% to 60%.

I want to point out that we can very simply scale how dramatic we want for the effect of 1 point of advantage to be.

So now, let's do the opposite.

ATK: 10
DEF: 15

DEF ADVANTAGE 50%

Slap: 4.44
Double: 2.22

SLAP ADVANTAGE 100%

ATK: 20
DEF: 30

DEF ADVANTAGE 50%

Slap: 2.22
Double: -1.11111 twice

In Pander's equation, there's a FIXED SCALE FACTOR.

In my adaptation, the SCALE FACTOR is ATK / DEF.

Dixx is inquiring about what impact, exactly, does having more hits do to the equation.

And the answer is (or should be) this:

The weaker an attack gets, the better it scales when ATK is greater than DEF.

So, although stronger attacks won't scale as well when ATK is greater than DEF, the fact that they do MORE BASE DAMAGE will often make them a more attractive option, anyway.

But for moves that hit MORE THAN ONCE, that weaker damage is multiplied by the number of hits. Obviously. As in, Double slap hits twice. Triple Slap hits 3 times.

So, because they're doing the damage MORE THAN ONCE, that BONUS that they get for their superior scaling gets applied more than once.

So, in other words, if Double Slap is half the base_damage of Slap, and Triple slap is 1/3rd the damage of Slap, then, if ATK is higher than DEF:

Double Slap does more than Slap.
Triple Slap does more than Double Slap.

Because, in terms of scale, Double Slap is not weaker than Slap, and Triple Slap is not weaker than either Double Slap or Slap. Their base damage is perfectly scaled.

Therefore, because each HIT does less damage, those individual hits scale BETTER when ATK is greater than DEF, so the more hits they do, the more total damage they get.

First of all, we have to look at the percentage advantage between ATK and DEF.

And you can look at the difference. Now wait a minute. Do we even need the traditional 'damage multiplier,' then?

What if we just looked at the difference between ATK and DEF and we used that value to scale something. The problem with that is that the numbers get very extreme, very quickly. 10 points of difference means the same scaling at 100 points and 10 points, which isn't kosher.

It's almost like the difference between and atk and def should, itself, scale. Am I literally just re-inventing atk / def?

If ATK is higher than DEF, the weaker an attack is, the better its damage scales.

So we need to take the difference between ATK and DEF and do what with it?

What if we looked at this a totally different way and included a constant representing 'average damage' which would allow us to get a sense for how 'strong' or 'weak' an ability is. Then we could use that to see how it's supposed to scale. I think that's the wrong direction because we need to fixate on the actual impact of 

Everybody looks at RPGs differently. We've all been playing them for our whole lives, and we've all been seeing the numbers cascade down whenever we hit somebody. But we all have our own understanding of how those numbers are calculated.

Here's how I'm looking at it:
Remember, this game has no equipment. There's no swords.

Abilities have a per-hit 'base damage' that they're "supposed to do, all other things being equal".

When I talk about a 'total_damage_multiplier,' I'm talking about the filter that the damage goes through because of the comparison between the Attacker's ATK and Defenders' DEF.

In other words, I'm talking about, "How much does this damage get reduced as the result of the interaction between ATK and DEF?" And I call it a 'multiplier' because I've been doing it with a very simple, "ATK / DEF", which means that, if I have twice your DEF in ATK, I get double base-damage. To me, that seems like a very elegant way to go about it, because the actual points-difference between ATK and DEF doesn't matter -- rather, the scale matters. So, when you're at the start of the game, getting 1 extra point in ATK might nearly double your damage. Later in the game, you need to invest more to have those same extreme.

To answer Steve's question, 'base_damage' is a value inherent to each individual ability, and, in our case, for the purpose of our testing, we have essentially one base_damage of 10 (Slap) and we have multi-hit variants of Slap whose base damage is just Slap's base_damage divided by the number of hits.

So, Slap has 10 base damage.

Double-Slap has 5 base damage.

Triple-Slap has 3.33 base damage, and so-on.

When an enemy has very high DEF, harder-hitting abilities scale better against them. So, if you use an ability with 5 base-damage it will do less than half of an ability with 10 base-damage, because the 5 is being scaled harder by the enemy's defense.

On the other hand, against an opponent who has low defense (lower defense than we have attack), lower-damage abilities scale BETTER.

DEF > ATK: better scaling for hard-hitting, single-hits.
DEF < ATK: better scaling for soft-hitting, multi-hits.

We have TWO WAYS to compare ATK and DEF.

We can compare them in terms of their SCALE to one another:
ATK / DEF

We can compare them linearly in terms of how many points about they are:
ATK - DEF.

How does this work:

base_damage + base_damage * damage_multiplier

I don't think that scales different for weaker attacks?

base_damage + base_damage * (damage_multiplier - 1)

base_damage = 5
damage_multiplier = 1.5
total_damage = 5 + 5 * .5 = 7.5

base_damage * damage_multiplier

What if we took a different approach? Get a basic equation working and then factor in penetration.

IGNORING PENETRATION.

If I have equal offense to your defense, my attack does its base damage.

If I have twice as much offense as you do defense, my attack does double damage.

In Dixx's words, "So, it isn't total ATK and total DEF that matter, but ATK:DEF?"

The answer is that the goal is to have BOTH be significant.

When you compare ATK - DEF, you're comparing how FAR apart they are, right?

Pander's new equation:

raw_damage = (base_damage + ATK) / hits

total_damage = (raw_damage / 2) * damage_multiplier + atk - def

BASE DAMAGE IS A VALUE INHERENT TO THE ABILITY. EVERY ABILITY HAS DIFFERENT BASE_DAMAGE, THAT'S WHAT DETERMINES HOW STRONG IT IS.

BONUS_DAMAGE IS DAMAGE ADDED DIRECTLY TO BASE_DAMAGE.

BONUS_TOTAL_DAMAGE IS DAMAGED ADDED DIRECTLY TO THE FINAL, TOTAL DAMAGE VALUE.

DAMAGE_MULTIPLIER IS A VALUE THAT SCALES DAMAGE. IT'S ON A PERCENTAGE SCALE.

So, in our most essential of equations:

((base_damage + bonus_damage) * damage_multiplier + bonus_total_damage) * number_of_hits

All night we've been fucking around with ways to tamper with bonus_damage and bonus_total_damage and maybe even the damage_multiplier to try to get the results that we're after.

Unlike our most essential equations, panders divides the damage by the number of hits before it hits the damage_multiplier.

ATK: 10
DEF: 10

ATK ADVANTAGE +0%

Slap: 10
Double: 10

DOUBLE ADVANTAGE: +0%

When I say that, when defense is greater than attack, lower-base-damage abilities should scale WORSE than higher-base-damage abilities, one thing that definitely needs to happen is that, if base-damage is cut in half, total-damage should be less than half.

In Balls' example, the lower-base-damage ability actually scales BETTER.

Let's talk about game-design. The whole reason we've been stuck for nearly 8 hours now is that we're trying to add a strategic layer to which abilities the player chooses to do their damage in battle depending on the foe they're facing.

You guys all play JRPGs, right?

Consider two moves which have the same exact cost (MP, etc).

Slap: base_damage of 10, hits once
Double Slap: base_damage of 5, hits twice

The consideration that we want for the player to make is whether they want to use Slap or Double Slap. Seemingly, they're the same.

The thing is, when the enemy has 'high defense' (higher DEF than you have ATK), damage scales differently. It scales such that it favors LARGE, SINGLE HITS.

Likewise, when the enemy has 'low defense' (lower DEF than you have ATK), damage scales such that it favors WEAK, MULTI-HITS.

In the abstract sense, we're talking about 'penetration'. If you have an enemy who has high defense, a move that hits multi-times for less damage each time will have trouble 'penetrating.' On the other hand, when the enemy has 'low defense,' you don't need to worry about penetration, and so you get more total damage from hitting multiple times.

Let's get back to testing Pander's equation.

ATK 10
DEF 10
ATK ADVANTAGE 0%

SLAP: 15
DOUBLE: 15
DOUBLE ADVANTAGE 0%



ATK 15
DEF 10
ATK ADVANTAGE 50%

Slap: 33.125
Double: 48.125

Slap and Double Slap are TWO DIFFERENT ABILITIES THAT THE PLAYER CAN CHOOSE FROM.

Both abilities have the same exact cost to the player.

Double Slap hits twice, each time at half the 'base damage' of Slap.

Triple Slap has the same cost as both Slap and Double Slap, but has 1/3rd the 'base damage' of Slap and hits 3 times.

In an RPG, ATK, DEF, and the base_damage of abilities is very dynamic -- and the resultant damage calculations are just as dynamic, based on those values.

In Chimera's example, a wide variety of 'ATK' and 'DEF' values will result in the same exact damage.



PANDERS EQUATION
ATK 10
DEF 10
ATK ADVANTAGE 0%

SLAP: 10
DOUBLE: 10
DOUBLE ADVANTAGE 0%


ATK 15
DEF 10
ATK ADVANTAGE 50%

SLAP 23.75
DOUBLE 28.75
DOUBLE ADVANTAGE 21%



ATK 30
DEF 20
ATK ADVANTAGE 50%

SLAP 40
DOUBLE 50
DOUBLE ADVANTAGE 25%




ATK 60
def 40
ATK ADVANTAGE 50%

SLAP 72.5
DOUBLE 92.5
DOUBLE ADVANTAGE 27.5%

You could almost say that when ATK has a 50% advantage over DEF, Double Slap has between 20-30% advantage over Slap.


In panders equation, scaling factor is disabled when def is higher than offense?

ATK 10
DEF 15
DEF ADVANTAGE 50%

SLAP 8.33
DOUBLE 3.33
SLAP ADVANTAGE (8.33 - 3.33) / 3.33
SLAP ADVANTAGE 150%

ATK 20
DEF 30
DEF ADVANTAGE 50%

SLAP 10
DOUBLE 0
SLAP ADVANTAGE ????



GAME DESIGN:
* Slap and Double Slap have the same cost to the player to use.
* Slap has 10 base damage. Double Slap has 5 base damage and hits twice.
* When aggressor ATK == defender DEF, both do their total base damage (10). 

What we want to accomplish is that, as ATK becomes relatively larger than DEF, Double Slap should become increasingly more cost-effective than Slap in terms of damage.

Likewise, as ATK becomes relatively less than DEF, Slap should become increasingly more cost-effective than Double Slap in terms of damage.

Here's our variables:

base_damage : a value inherent to every attack ability representing the damage it'll do if aggressor ATK is equal to defender DEF.

ATK: aggressor's ATK value

DEF: defender's DEF value

Let's assume that, during damage calculation, we don't know how many hits are lumped into the single ability.

Chimera points out that what we're going for, in terms of player decision-making, is that we want for the player to have to compare their ATK to their opponent's DEF, as well as the costs of HIGHER DAMAGE abilities and LOWER DAMAGE ABILITIES, because, if the enemy's DEF is 'low,' then it is likely more cost-effective to use 'weaker' abilities at a lower cost -- because, at the same cost, weaker abilities become more effective in that situation.

In other words, when enemies have higher DEF than you have ATK, you need to hit for more base damage to sort of 'penetrate' or 'overcome' that defense. As such, if you have an attack, like Double Slap, which hits twice at half base_damage each time, for the same cost, it wouldn't be as effective as Slap because each individual hit would be scaled more harshly because of their relatively low base_damage.

On the other hand, if your character has more ATK than the opponent has DEF, it makes more sense to use Double Slap because each attack is scaled better.

Let me point out why penetration cannot scale by number of hits.

In our game, you can use more than one ability per turn.

So, from now on, let's look at two abilities:

Intead of Slap and Double Slap, let's look at Strong Slap and Weak Slap.

Strong Slap has 10 base_damage and costs 10 AP.

Weak Slap has 5 base_damage and costs 5 AP.

When ATK == DEF, using Weak Slap twice should do the same damage as using Strong Slap once for the same cost.






Strong Slap
Weak Slap




Strong Slap has 10 base_damage and costs 10 AP.
Weak slap has 5 base_damage and costs 5 AP.

The player can choose to use Strong Slap once or Weak Slap twice for the same AP cost.

If the player is going to spend 10 AP, they can use Strong Slap once or Weak Slap twice.

If aggressor ATK == defender DEF, then using Strong Slap once will do the same damage as using Weak Slap twice (for the same cost).

Chimera points out that what we're essentially talking about is rewarding the player with bonus damage based on making the correct choice for which ability to use. The issue is that we're trying to figure out how to deliver that bonus damage in a way that scales correctly.

Whenever we talk about "high defense" or "low defense," we're talking about it being compared to the aggressor's ATK.

The bigger the advantage of ATK over DEF, the more bonus damage Weak Slap gets.

The bigger the advantage of DEF over ATk, the better Strong 

The bonus damage is scaling.

Let's revisit our ESSENTIAL EQUATION.

CONSTANTS
    ATK = offender attacker
    DEF = defender defense
    base_damage = base_damage of the ability in question

VARIABLES (we've been playing with these, and beyond)
    damage_multiplier = ATK / DEF
                        Scales the overall damage being done based on the
                        scale of ATK to DEF.
    bonus_damage = an amount of damage added directly to base_damage
    total_bonus_damage = an amount of damage added directly to the total
                         damage inflicted.

total_damage = base_damage * damage_multiplier

The problem with this equation, as elegant as it is, is that Strong Slap and Weak Slap are always both equally efficient. Any time that you attack with Weak Slap, it's going to do half the damage you would've done with Strong Slap.

total_damage = base_damage ^ damage_multiplier

In Chimera's example below, we assume that the player has made the 'correct' decision regarding which ability is more cost-effective.

total_damage = base_damage + (ATK - DEF) * .2

ATK 100
DEF 10

Slap goes from 10 to 28 damage.

ATK 50
DEF 10

Slap goes from 10 to 18.

To break it down using the language we've been using tonight, it's really like this:

bonus_damage = (ATK - DEF) * scale_factor
total_damage = base_damage + bonus_damage

This requires for the game, itself, to know which is the "right" decision based on cost-effectiveness (AP per base_damage). Which sort of requires us to have a threshold for what qualifies as a "weaker ability" vs a "stronger ability," which isn't the end of the world, either.

Let me propose what I think this solution's "weakness" would be, which relates to something that I'm not sure I communicated since Chimera showed up.

In Chimera's equation, he's using the ATK and DEF values solely to calculate bonus_damage, which isn't a bad thing at all. It's just ~a~ way to go about it.

Let me try to communicate the way that I've been conceptualizing the relationship between ATK and DEF and the value of those attributes to the player:

The SCALE between the two is significant. Hence our "essential equation," which fails most of the other tests that we've been trying to accomplish.

total_damage = base_damage * (ATK / DEF)

This equation makes it such that ANY attack will do twice as much damage if the aggressor has twice as much ATK as the opponent has DEF. Likewise, any attack will do half as much damage when the opponent has twice as much DEF.

Obviously, the problem with this is that Weak Slap and Strong Slap will always be equally effective, because they scale identically. Chimera solves this problem by not using the scale of ATK and DEF for anything.

The way that we've been trying to solve this problem, tonight, is by adding some kind of augment to this 'essential equation' which will factor in the difference between ATK and DEF. So, this 'scale' is still a significant factor -- but it's no longer the ONLY factor.

I like Chimera's equation a lot because I feel like it effectively captures this idea of getting more bonus damage based on the difference between ATK and DEF. There are a few things that I wonder:

First of all, can we have this linear bonus that Chimera is applying also act as a penalty for the 'wrong decision' in such a way, mathematically, that we don't need an 'if' statement to see if the player made the supposed 'correct' decision.

Let me try to describe some equations we had working EARLIER which were almost exactly what we needed but which had shortcomings that we just couldn't overcome.

The way that these equations usually end up is that ATK and DEF are compared to calculate some amount of bonus damage, and then that entire resultant damage (base + bonus) is multiplied by ATK / DEF and then, of course, by the number of hits.

When you add the same bonus damage to a stronger, single hit, the scale of bonus:base damage favors the base damage. What I mean by that is this:

If base_damage 10 gets bonus_damage 2, we've made that attack 20% more effective.

If base_damage 5 gets bonus_damage 2, Weak Slap has received more of a boost, relatively speaking, compared to Strong Slap.

So it's seemed to me that there is a way to reward weaker, multi-hits more, in terms of cost-effectiveness, while devising some way to calculate bonus damage that looks at ATK and DEF the same.

Another idea I want to point out is that Chimera's equation, with lovely simplicity, looks at this whole problem in terms of rewarding the player with bonus damage when they make the right decision.

But the way that I've been conceptualizing it is that, for instance, when an opponent has HIGH defense (higher than your ATK), it isn't that you get bonus damage for attacker with a stronger, single hit (for the same cost) -- but, rather, you get penalized less. You don't GET bonus damage --it's just that, as your base_damage gets lower, your hits get penalized more and more. So, RELATIVELY SPEAKING, higher base_damage hits get penalized less.

It seems to me that there must be a way to compare ATK and DEF and come up with some kind of multiplier and / or bonus|penalty value that would reward lower-base_damage attacks relatively MORE than higher-base_damage attacks when ATK - DEF is positive or ATK / DEF is > 1 -- and which penalizes higher-base_damage attacks ~relatively~ less when ATK - DEF is negative or ATK / DEF is < 1.

It just seems like, when you have these values which can be positive or negative (bonus or a penalty) and you have these multipliers which can be greater than 100% or less than 100% -- and you have these base_damage values where, the lower the value is, the more it's (relatively) impacted by smaller changes, there should be an equation that satisfies all of our requirements without needing to have this god's eye view of "number of hits" or whether or not the player made the "right" decision based on cost-effectiveness. I feel like that's something that could be worked into the equation.

STEVE EQUATION
damage_multiplier = ATK / DEF
scaled_damage = base_damage * damage_multiplier
bonus_total_damage = (steve_constant / base_damage) * damage_multiplier
total_damage = (scaled_damage + bonus_total_damage) / scale_factor

For Steve's equation to work, he needs to have a number higher than our highest best damage.

STEVE_CONSTANT 11
SCALE_FACTOR 0.9

ATK 10
DEF 10
ATK ADVANTAGE 0%

STRONG 9.99
WEAK 6.48
WEAK ADVANTAGE 30%

BALLS EQUATION
total_damage =  (left_factor * (DEF / ATK) * base_damage ^ (right_factor * (ATK / DEF)) * hits


If I had to theorize based on what we've been through, tonight, I would say that the ideal equation exists somewhere in here:

damage_multiplier = ATK / DEF
bonus_scale_factor = 1
scaled_damage = base_damage * damage_multiplier
total_bonus_damage = 1 - damage_multiplier
total_damage = scaled_damage + total_bonus_damage

What do we know about 'total_bonus_damage'?
1.) It needs to be 0 when ATK and DEF are the same.
2.) It needs to be relatively lower as base_damage gets higher.

In Kenny's equation, we're not seeing a cost-effectiveness bonus when using weaker abilities. It's kinda backwards: it seems like, lower-base-damage abilities are more cost-effectiveness against high DEF. And it seems like that amount is almost always the same, so we might want to play with the scale_factor.

If this has one shortcoming (and I'm not even really sure it does), it's that, when DEF is higher than ATK, it scales damage pretty hard.

This is a problem that all of Panders' equations had, and he was trying to come up with a bunch of ways to get around that, but I bet the solution is pretty simple.

It's almost like we need to halve the 'bonus' when it's actually a penalty, which we could do with a MAX() I would think, or something like it.

So, for next time: it seems that we just need to solve the problem of the damage PENALTY seeming to be twice as harsh as the damage BONUS is rewarding. Seems very easy to solve in a variety of ways.

FINAL EQUATION:

damage_multiplier = ATK / DEF
scaled_damage = base_damage * damage_multiplier
total_damage = scaled_damage + (damage_multiplier - 1) * scale_factor

07/24/19

Finally back from DTN and getting back to game-dev. I'm re-examining this equation -- and, while I don't doubt that it works as well as I remember, I can't help but notice that the 'penetration damage' is a value totally independent of the ability's base damage.

The 'penetration damage' is (damage_multiplier - 1) * scale_factor

So, it's based entirely on three values: attacker ATK, defender DEF, and the scale_factor constant.

So, the actual damage of the ability has absolutely no bearing on the penetration damage being factored in.

Is that okay? You could argue that it's like a "bonus for penetration" that rewards the attacker for having more ATK than the defender has DEF, and it penalizes the attacker for having less ATK than the defender has DEF.

So, this idea works okay as long as we consider that a 'baseline' move like 'Slap' has 'baseline' damage which is considered 'normal' or 'average,' and then we apply a scale factor based on that. Because, basically, stronger attacks won't have more penetration and weaker attacks won't have weaker penetration. So this 'average' amount of penetration is going to be uniform to all attacks.

Mathematically speaking, this means that multi-hits are affected much more by penetration than single-hits. And weaker hits are affected much more, RELATIVELY SPEAKING, than stronger hits.

Let's carry on with creating this spreadsheet and examine our options for dealing with or better-undering this 'problem'.

Because of the math for the 'scaled damage,' an attack with half the base damage is always going to do half the scaled damage. So there are two ways that multi-hits differ from single-hits:

1.) Each hit is weaker, and, therefore, the penetration damage is of greater significance to the total damage of that hit.
2.) This penetration damage is added PER HIT.

Hypothetically speaking, if you had a move that did 10 hits for 1/10th the base_damage per hit, it would be massively more powerful because it'd get the penetration_bonus ten times. But this is what we want. The whole idea of this equation was to reward multi-hits when ATK was higher than DEF -- and to punish them more when ATK is lower than DEF. After all, this 'penetration_bonus' can also be a penalty, and it's also applied for EVERY hit.

I'm starting to think that this problem with the penetration 'penalty' seeming more drastic than the penetration 'bonus' is actually not the issue. I think the issue is a matter of scale and perspective when it comes to imagining how our units' attributes might compare to one another.

An ideal that we've had for the past few streams has been that, very simply, if the attacker has twice as much ATK as the defender has DEF, then the attacker's ability should do twice as much damage. 

Seems simple. Seems sensible.

But if we're talking about small scales where, let's say, hypothetically, an attacker would have 5 ATK and the defender would have 5 DEF -- and if we're dreaming, hypothetically, that a unit can grow a stat by 1 each time they 'level up,' then we're talking about being able to double your ATK pretty quick. And maybe that's the problem that I'm perceiving.

If I'm right, there are two main ways to solve this problem.

1.) Very simple decide, as a family unit, here, what kind of scale we want for unit attributes. Do we start the game with 50 ATK? Or 5? We've been using '10' as our baseline, but that's totally arbitrary; we can make it whatever we want. If it would solve this problem in some way, maybe that's what we need to do: decide on a scale for our unit attributes.

2.) Maybe we need to address the multiplier not necessary by 'number of points put in' (as Kenny put in) but just in general -- like, make it less dramatic. It would be something like: damage_multiplier = (ATK / DEF) * multiplier_scale . In other words, we could make it so that having twice as much ATK as the opponent has DEF doesn't get you twice as much damage. Maybe it gets you 150% as much damage, or something.

We pointed out, today, that the PENETRATION DAMAGE is not affected AT ALL by the base_damage. And base_damage represents the amount of damage done when ATK and DEF are equal. So, if we were to MAGNIFY BASE_DAMAGE, it WOULD NECESSARILY outscale penetration damage. At some point, it would make penetration_damage entirely obsolete.

So, any time we scale BASE_DAMAGE we must also play with the PENETRATION_SCALE to compensate so that penetration isn't completely nullified.

But, THEORETICALLY, we don't need to mess with EITHER base_damage or penetration_scale. Because those values are totally arbitrary. Because we don't have a scale for HP.

As long as the base_damage of our baseline_ability is in scale with the universal penetration_scale, we're good.

Well, let's consider how often a defender will have 50% more DEF than the attacker has DEF.

I think I'm starting to understand the problem with 'scale' here.

Doing 100% more damage means that you're doing double damage.

But doing 100% LESS DAMAGE DOESN'T MEAN THAT YOU'RE DOING HALF DAMAGE.

It's a simple mathematically falacy that I've been falling into.

Our scale factor is literally a straight-up percentage. If I want for double ATK to do double damage and double DEF to do half damage, we can't just use a linear percentage --

because double ATK WILL DO DOUBLE DAMAGE (100% more damage), but DOUBLE DEF WILL COMPLETELY NEUTRALIZE DAMAGE (100% less damage).

So we need for double-ATK to do 100% MORE DAMAGE and double-DEF to do 50% less damage.

Right now we're doing base_damage * (ATK / DEF).

Kulahan says that we can solve our issue by doing base_damage / DEF * ATK.

I think they're the same thing so, no, that doesn't solve our problem; that's the cause of our current problem.

I'm wrong. Kulahan's right.

In any case, our current equation works fine as far as damage multiplication goes. The issue is with the scale of the penetration penalty to the multiplied damage.

If we have twice as much DEF as we do ATK, with a penetration scale of 5, two things happen:

1.) Our base_damage is scaled from 10 to 5.
2.) We take a penetration penalty of -2.5

These two things combined result in a very extreme penalty. It's a matter of penetration penalty to POST-DAMAGE-SCALING damage.

In other words, at a penalty of -2.5, we've just lost HALF of our scaled damage to the penetration.

Compare that to when you get a penetration BONUS. If we have twice as much ATK as we do DEF, with a penetration scale of 5, two things happen:

1.) Our base_damage is caled from 10 to 20.
2.) We get a penetration bonus of 5.

So, we get a penetration bonus equal to 1/4 of our scaled damage.

In the same situation, reversed, we take a penalty equal to 1/2 of our scaled damage.

So the reason that it seems like we take more of a PENALTY from penetration than we get a BONUS is because, necessarily, as our scaled_damage goes DOWN, the effect of penetration is RELATIVELY MORE DRAMATIC. The ratio between scaled_damage and penetration bonus / penalty goes UP as scaled_damage goes down. The lower the scaled_damage, the greater the relative impact of penetration. The higher the scaled_damage, the lower the relative impact of penetration.

We could probably come up with a VERY SIMPLE WAY to scale penetration based on scaled_damage so that this issue of scaling is lessened.

I want to point out that the impact of penetration is basically limited to one main value: the relationship between BASE_DAMAGE and PENETRATION_SCALE.

Right now, we have a penetration_scale of 1/2 base_damage.

I'm gonna repeat myself:

Our problem is that, as our scaled_damage goes down our penetration_bonus also goes way down. They go down together. And, because of that, the penetration penalty takes on much, much greater significance as the scaled_damage gets nearer to zero.

In other words, as scaled_damage goes UP toward infinity, penetration becomes less significant. As scaled_damage goes down toward zero, penetration becomes more significant.

I have two gut feelings right away:

1.) Scale the penetration by some factor based on scaled_damage.
2.) Idea #1 is stupid and is going to result in the same problem with scaling that we always have: the result will be that penetration is uniformed away so that multi-hits do the same damage as single-hits.

Kenny asks to review what the equation for penetration damage, and it's this:

(ATK / DEF - 1) * penetration_scale

So, one thing we've been grappling with, today, is that base_damage has no impact on penetration damage.

What is a proposed equation for scaling the penetration penalty / bonus based on scaled_damage. Is that something that we can do or is it a fallacy to even think that we want to do that.

I'm talking about somehow scaling the penetration bonus to be proportional, somehow, to the scaled_damage. But just saying that makes it clear that my second instinct (above) is true: that I'd be making the damage uniform for both single and multi-hits. You don't WANT to scale the stinking penetration damage to the scaled_damage. That defeats the whole point. But how can we avoid this issue of the penetration penalty becoming so extreme as we lose scaled_damage. Penalty goes up, scaled_damage goes down, so we get this double-whammy of damage reduction. It's more than a 'double-whammy': it's like some kind of exponential damage reduction.

One thing that we could do is literally just use an 'if' fork to change our equation very slightly when DEF is higher than ATK, right?

We could just say, if DEF > ATK, then cut the penetration penalty in half.

You could run the same equation, but the 'if' statement would change the value of 'penetration_scale' before running the equation.

if atk > def:
    penetration_scale = 5
else:
    penetration_scale = 2.5

That's all that you would need to do to curb the ratio between scaled_damage and penalty. Basically, what we're talking about is curbing the ratio between scaled_damage and penalty. You want for the penalty to be less harsh when you're already losing so much damage to the damage scaling.

The idea is that, when DEF is higher, you're LESS INCLINED TO USE MULTI-HITS. When DEF is twice that of ATK, single-hit does 3.75 and double-hit does 2.5. That's a pretty dramatic reduction (but, on the other hand, having twice as much ATK as DEF is pretty dramatic).

Maybe we should try some less-dramatic values and see how halving the penetration_scale for penalties really looks.

Kenny's proposing that we change penetration_scale from being a constant to being the product of some equation involving our multiplier.

What Kenny's really proposing is changing the equation for penetration_bonus to:

(ATK / DEF - 1) * (1 / (DEF / ATK) + 1)

KENNY VARIANT:
15, 10 -> 16.25, 17.5

10, 15 -> 6.111, 5.555

I think the Kenny Variant is genius and what we're probably going to settle on -- but, just like the old equation, we need to set a scale between base_damage and penetration_scale. It seems that 1/10th might be too extreme.

Theoretical note: the point of penetration is NOT to reward the player for having high ATK. That's what scaled_damage already does. Obviously, when you factor in this damage_multiplier, you're getting a huge benefit for having higher ATK than your opponent has DEF. The point of penetration is to reward or penalize multi-hits.

When I say that I want to make this penetration 'softer,' I'm talking about ONE of two things:

1.) Reduce the OVERALL SCALE OF PENETRATION TO TOTAL DAMAGE.
2.) Reduce the scale of penetration PENALTY to penetration BONUS.

We have to create some language to differentiate between these two concepts.

I feel like we absolutely need to have a PENETRATION_SCALE constant which we can simply play with to INCREASE and REDUCE the relative impact of PENETRATION DAMAGE to SCALED DAMAGE. That it is to say, how much does penetration really matter in our game.

In the pre-Kenny variant, that's exactly what PENETRATION_SCALE did: it made the penetration bonus and penalty (which, at the time, were pretty much even) more or less of a factor in our damage calculation.

I think we still need that. I think what Kenny has introduced -- this new constant is really, maybe, more like a factor which reduces the impact of a PENALTY compared to a BONUS. Maybe we need to call this PENALTY_SOFTENER or something.

Kenny points out that what he did is make our PENETRATION_SCALE not a flat number -- but I disagree with that. What Kenny really did is essentially scale the scale and add a constant -- and that constant is really what's significant, because it's a new value that we have control over.

BUT it doesn't change the fact that we still need a constant to DIRECTLY scale the impact of penetration damage compared to base damage.

I want to prove that the new 'Kenny constant' is what softens penalty compared to bonus. That's our end-game: soften penalty compared to bonus.

That's our goal for tomorrow. We need to record some observations and see how the Kenny constant affects some kind of relative-softening of penalties compared to bonuses.


07/25

With the Kenny constant at 0, we see that, as ATK goes higher over DEF, the scale of our penetration also goes up. That's not really what we want. We pretty much only want this 'rescaling' of penetration to happen as ATK goes BELOW DEF.

I don't mind that it's scaling upward as ATK gets higher -- it's just that my fear is that it's going to scale UP just as much as it scales DOWN, which defeats the purpose.

But let's test this.

The whole idea is to soften the penalty as compared to the bonus. If the penalty is being softened by the same amount that the bonus is being enhanced, then we've gotten nowhere.

With a Kenny Constant of 0, for every hit we add at 100% ATK advantage, our damage advantage goes up by 20%. Why? It's because our penetration value is '2', which is 20% of our original damage, '10'. So, for every hit we land, we're gaining another 20% advantage over that value of '10'.

In other words, you could say that, damage advantage is (penetration / original_damage) * hits, basically.

I'm gonna lock in our equation for damage. It looks like this:

damage_scale = (ATK / DEF)
scaled_damage = base_damage * damage_scale
base_penetration = (ATK / DEF - 1)
penetration_scale = (1 / (DEF / ATK) + kenny_constant)
scaled_penetration = base_penetration * penetration_scale
total_damage = scaled_damage + scaled_penetration

Before we can advance into the more fun aspects of our game-design, we have one more equation to figure out. As a family unit. After this, I really believe that we're done fucking around with the core algorithms of our game.

We need to come up with an equation which determines chance-to-crit, basically.

For those (if anybody) who are joining the stream since we last talked about how our game handles 'crits,' let's briefly discuss how it works.

In our game, there is no chance to 'miss,' there's no chance to traditionally 'crit', and there is no random damage variation. So, damage is pretty strict. You can't miss, you can't crit, and there is no random variation in damage.

HOWEVER.

Every ability in the game, when used, can have a different affect based on a randomly chosen EFFECTIVENESS from 3 different possible effecitvenessesesseseses.

So, every ability in the game is coded at three levels of effectiveness:
"Glancing"
"Normal"
"Critical"

So, although attacks can't MISS, they can activate at 'Glancing Effectiveness,' which means that their affect is nerfed.

And although attacks can't traditionally CRIT (gain double damage), they can activate at 'Critical Effectiveness,' which means that their affect is enhanced.

So, instead of having 'chance to miss' and 'chance to crit' based on a variety of character attributes such as agility, accuracy, dexterity, luck, etc., we sort of lumped all of these ideas together into a chance to land attacks at certain levels of effectiveness based on two character attributes: SKL and PRY.

So, when the attacker's SKL and the defender's PRY are equal, we need to hit some sort of baseline percentage chance to glance or crit.

As the attacker's SKL grows over the defender's PRY, we need for chance-to-crit to grow and MAYBE for chance-to-glance to diminish. But I think that maybe it would be more fun if chance-to-crit GREW but chance-to-glance stayed at baseline.

Likewise, when the defender's PRY grows over the attacker's SKL, we need for chance-to-glance to grow while chance-to-crit either shrinks or stays the same (and I'm leaning toward having it stay as baseline).

So, if we look at the 'baseline' values for chance-to-crit and chance-to-glance as being their MINIMUM VALUES, that means that, as SKL and PRY get advantage over one another, we're losing chance-to-normal.

So you could say that, when SKL == PRY, chance-to-normal is at its maximum value and chance-to-crit and chance-to-glance are at their minimum values.

How about we also say that chance-to-normal can never fall below the minimum chance-to-crit / chance-to-glance. If chance-to-normal falls TOO LOW, we start lowering the other one so that they can stay equivalent.

So, perhaps a good baseline value would be something like this:

Chance-to-glance: 15%
Chance-to-normal: 70%
Chance-to-crit: 15%

And we could say that, when SKL becomes twice as much as PRY, maybe we double our chance to crit:

Chance-to-glance: 15%
Chance-to-normal: 55%
Chance-to-crit: 30%

Maybe it makes more sense to say that, when SKL becomes twice as high as PRY, we have a 50% chance to crit:

Chance-to-glance: 15%
Chance-to-normal: 35%
Chance-to-crit: 50%

What if we looked at '15% chance' as a sort of minimum for any effectiveness, and we looked at having twice-as-much parry / skill as our sort of ceiling at 70% chance.

So, if I had twice as much SKL as you have PRY, my chance to crit would be 70%:

Chance-to-glance: 15%
Chance-to-normal: 15%
Chance-to-crit: 70%

The opposite would be true as well. If I have twice as much PRY as you have SKL, your chance to Glance would be 70% against me:

Chance-to-glance: 70%
Chance-to-normal: 15%
Chance-crit: 15%

I like this idea, because it seems very tidy: As either your defensive or offense attribute doubles that of your opponent, you have turned your chance to crit or their chance to glance to what USED to be the chance to normal. That seems real cute to me.

That seems like it'd be pretty easy to figure out, mathematically. We have these minimum and maximum values that these chances can have, and they have a certain amount of leeway to vary.

They can vary within a 55% range, between 15% and 70%.

I think this idea is something that makes more sense to express as Python rather than as an equation, so let's get back to Python and see if I can express this.

In our game, when we're passing a value for 'targets' whenever we want to use an ability -- and it's a list, because we're imagining that abilities are going to be able to take multiple targets; that stands to reason. But then it sort of makes you wonder how we really want to handle crit calculation.

Because, in our game, 'crit' isn't just an amount of damage you do. It changes a lot of things about how the ability is expressed. It seems that, when an ability is FIRST CALLED, we figure out the Effectiveness and we run the appropriate method to use that ability based on that Effectiveness.

But what if we're hitting 3 opponents at the same time and we want to hit them each at a different level of effectiveness? That makes sense to me. Or maybe not. I feel like it would vary based on the ability.

Some abilities that target a group might want to either CRIT THEM ALL AT ONCE or NOT based on a single roll.

Other abilities might want to calculate the crit on a unit-by-unit basis.

Do we have accommodations for both, with the way that our game is currently running?

We sort of have a problem where we haven't dedicated a lot of thought to how abilities that target groups are going to work. So far, all of our mock-up abilities have targeted a single unit. When you start talking about abilities that target a group, I guess there's more going on regarding Effectiveness than we first realized.

It's almost like we can't really roll for effectiveness until the ability is running -- like, so that it can handle its own targets to decide who it wants to crit.

But there are problems with that, too. For instance, we have some Rules which trigger whenever an ability crits. So what happens when an ability hits more than one target and it crits on a couple of them and doesn't on others? Doesn't seem right. Doesn't seem sensible.

Can we say that, if an ability targets a group, it has to either crit them all or not crit any of them? Or is that overly restrictive to how creative we can be with our abilities?

Let's be honest: for one thing, abilities that target groups are going to be an exception in our game. The whole idea of our game's DESIGN is that you're going to be targeting the enemy unit in 'the ring' 99% of the time. Having an affect on units 'outside of the ring' or 'in the back row' is something that we're open to and which I think is exciting but which isn't a core element of how battle is going to be playing out on a turn-by-turn basis.

It strikes me that it might be totally superfluous to allow the player to pick multiple targets. Let me make my case.

Tactically speaking, in our game, it's important that the vast majority of abilities target a single unit -- usually the unit that's in the Ring across from you, Pokemon-style.

Our game's core combat is loosely based on Pokemon, but our teams have even fewer units (Pokemon has 6 in a team, we have 4). Once you start allowing a unit to target monsters in the 'back row', you sort of lose the tactical significance of having those monsters in the back row. They're supposed to be safe back there, and the unit that the team leader has chosen to put into the ring is supposed to be tanking damage. The whole idea -- the core riddle of this 'Pokemon style' of gameplay is that you want to use the abilities of some monster, but, in doing so, that monster is vulnerable.

I do think that it's important, for our game -- even if not in Pokemon -- that units in the back row be subject to some sorts of 'side effects.' Like, maybe we have some huge ability which has a huge cost and which does major damage to the enemy unit in the ring and some minor splash damage to the units in the back row. That's fine.

But what I'm getting at is that the VAST MAJORITY OF ABILITIES WHICH HIT OR AFFECT MORE THAN ONE ENEMY UNIT are going to either affect the ENTIRE BACK ROW or some number of RANDOM UNITS from the back row.

We only have 4 units on a team. So, why is it important that we allow the player the possibility, for some abilities which we haven't even designed yet, to selectively pick more than one target? Like, as soon you've picked two units, you've already picked half of the entire enemy team.

Maybe you should just be able to pick only ONE unit. Most of the time, that'll be the enemy in the ring. Sometimes, it'll be your own unit currently in the ring. Sometimes, you'll be targeting a single ally for a buff or a heal. Sometimes -- rarely -- you might even be targeting a single unit from the enemy back row.

But why would you need to specifically target more than one unit at a time. If your ability is going to AFFECT more than one unit at a time, it's almost certainly going to be an entire TEAM or units picked at RANDOM, or units picked based on them being subject to some RULE or picked based on some CRITERIA. I don't think that we need to allow the player, under any circumstance, to specificially pick two units or more to be the targets of an ability.

I can think of one situation where it might make sense to target more than on unit. Like, what if you have an ability where you have some class that can 'marry' two units together. Like, "If this unit dies, they both die." But, in that case, we wouldn't be critting them individually.

So, maybe we need to maintain the POSSIBILITY to individually target more than one unit. But maybe it's fine to have the crit-chance be calculated in a fixed way for these situations. I feel like, in general, normal, attack abilities are not going to be targeting more than one unit. I think that's going to be extremely rare -- and, in the rare case that it DOES come up, it's probably fine to just calculate crit-chance based on, like, they're average PRY value or whatever.

Before we move on, we also need to talk about how we're going to calculate crit chance for BUFFS or other BENEFICIAL ABILITIES. Like, it stands to reason that your 'PRY' value should be a chance to minimize NEGATIVE EFFECTS. You WANT to have higher PRY.

But if someone is trying to HEAL YOU, how do we calculate the chance to crit?

That's a question for Monday. So, on Monday, we need to address a few different things:

1.) We need to figure out how we're going to calculate chance to crit when both units want for the ability to crit (beneficial abilities).

2.) We need to decide how we want to handle chance-to-crit when an ability is targeting more than one unit (we can probably just average out the PRY of all targets).

3.) We need to implement whatever we decide on into battlelib.UnitAbility.roll_for_effectiveness .


07/29/19:

I think that, in situations where both units want for an ability to crit, the average PRY of the entire enemy party should be used as the 'PRY'. For instance, if you're trying to heal an ally unit, the entire enemy PRY would be working against you in terms of getting a crit.

So, let's start implementing chance-to-crit.

We have a philosophical problem -- or a design problem. The problem is that, in our game, we don't really know for sure which attacks are beneficial and which ones are negative. We could flag abilities as such -- or we could just rely on each ability to contain its own 'chance-to-crit' code.

Some abilities are going to need their own chance-to-crit code ANYWAY because they'll have special conditions to crit. Some abilities might have a higher chance to crit than others. Some might always crit under certain circumstances. So, it stands to reason that, for at least SOME abilities, roll_for_effectiveness is going to need to be overridden.

That being the case, I don't think that we should flag abilities as requiring a particular method for calculatin chance-to-crit. I think we'll just have the default value for roll_for_effectiveness be the one that assumes you're attacking an enemy. And then, if you want to do some beneficial ones, you can just implement your own roll_for_effectiveness -- or we could code them both in, by default, and the coder could pick between them.

So, chance-to-crit equation:

crit_delta = SKL / PRY
if crit_delta > 1:
    glance_chance = 15
    crit_multiplier = min(crit_delta - 1, 1)
    crit_chance = 55 * crit_multiplier + 15
else:
    crit_chance = 15
    glance_multiplier = min(1 / crit_delta - 1, 1)
    glance_chance = 55 * glance_multiplier + 15
normal_chance = 100 - crit_chance - glance_chance

SIDE QUEST

I'm looking at our total_damage equation from last week and seeing that some of Kenny's equations are a bit long-winded and can be simplified to directly reference the damage_multiplier.

He references ATK / DEF quite a few times. Later, he references 1 / (DEF / ATK), which is just ATK / DEF. So, you can rewrite our old code:

damage_scale = (ATK / DEF)
scaled_damage = base_damage * damage_scale
base_penetration = (ATK / DEF - 1)
penetration_scale = (1 / (DEF / ATK) + kenny_constant)
scaled_penetration = base_penetration * penetration_scale
total_damage = scaled_damage + scaled_penetration

AS:

damage_scale = ATK / DEF
scaled_damage = base_damage * damage_scale
base_penetration = damage_scale - 1
penetration_scale = damage_scale + kenny_constant
scaled_penetration = base_penetration * penetration_scale
total_damage = scaled_damage + scaled_penetration

Because the Kenny Constant we decided on was '1,' it strikes me that scaled_penetration is:

scaled_penetration = (damage_scale - 1) * (damage_scale + 1)

Seems strangely symmetrical.

On Wednesday, we need to reexamine this Kenny damage equation and figure out exactly what the -1 and the +1 are for. How do they impact the resulting damage values? We need to theoretically examine this equation and break it down. It's very easy to understand until we look at the scaled_penetration damage. We could even break it down right now:

damage_scale = ATK / DEF
    * A multiplier which doubles base_damage when ATK is double DEF and
      halves base_damage when ATK is half of DEF.

scaled_damage = base_damage * damage_scale
    * The resultant, scaled damage as described above.

base_penetration = damage_scale - 1
    * ???????

penetration_scale = damage_scale + kenny_constant
    * ????????

scaled_penetration = base_penetration * penetration_scale
    * ????????

total_damage = scaled_damage + penetration_damage
    * By adding 'penetration damage' to our scaled_damage, we get either a
      bonus or a penalty which will favor multi-hits when ATK is greater
      than DEF and single-hits when DEF is greater than ATK.
    * The additional 'penetration' is the secret sauce in making this
      mechanic work.
    * No idea, theoretical, how 'penetration' is really working.

07/31/19

Let's talk about penetration.

Base penetration is damage_scale - 1. So, if ATK is twice DEF, then damage_scale is 2. Subtract 1 and we have BONUS DAMAGE of 1 point.

If DEF is twice ATK, then damage_scale is .5. Subtract 1 and we have a DAMAGE PENALTY of .5 points.

This is the backbone of our penetration equation. It's the fact that we have this '-1' that gives us our PENALTY when DEF is greater than ATK. Because our 'scale' will never go into negatives. No matter how much higher DEF is than ATK, 'scale' will never go into negatives. But, when DEF is higher than ATK, 'scale' becomes a fractional number, and so subtracting 1 will put it into the negatives, giving us a damage penalty when DEF is greater than ATK.

Therefore, we can say that -1 isn't really a constant that we should want to play with. It's really just there to give us a penalty -- to put into negatives -- considering that, when DEF is greater than ATK, scale is less than 1 (not less than zero).

But, of course, this 'base penetration' isn't applied FLATLY to our total damage. It's scaled by some value. So let's look at that.

So, we scale our base_penetration BY THE DAMAGE_SCALE and then we add some number, called the 'kenny_constant,' which we've settled on as being '1'.

What makes me uncomfortable is that we basically take the damage_scale and multiply it by the damage_scale. That seems weird.

Why +1? Why the Kenny Constant? What does this value really do?

Well, it definitely prevents our base_penetration from being scaled DOWN when DEF is higher than ATK.

When DEF is higher than ATK, our damage_scale falls into values that are less than one. Therefore, if you multiplied base_penetration by these values, you'd end up with a shrunken value -- or a value that's closer to zero. By adding 1-or-greater, we guarantee that our scale is a number GREATER THAN 1, which means that we're always scaling the value UP (or further from zero, since negative values will become even more negative).

So, why is it important that these base_penetration values always get scaled FURTHER FROM ZERO. Also, why do we even use the damage_scale as a sort of basis for this penetration_scale?

We should answer the first question first. It's probably important that we always scale further from zero for the same reason that, for base_penetration, we subtract 1 to make sure that values can go negative.

So -- by adding '1' or any other Kenny Constant to our penetration_scale, we create a situation where, as ATK gets higher over DEF, we grow our scale -- but even when DEF is greater than ATK, our scale is still growing. So it's almost like, as ATK goes up, our penetration_scale goes up?

total_penetration = (damage_scale - 1) * (damage_scale + 1)

'Damage Scale' is a number between 0 and infinity and it represents how our base_damage is being scaled based on the percentage difference between ATK and DEF.

In base_penetration, we have this -1 so that we can get a DAMAGE PENALTY when DEF is greater than ATK. If DEF is twice ATK, then damage_scale is .5. By subtracting 1, we fall into negatives (-.5) whenever DEF is greater than ATK. So, the -1 is just there so that numbers that would normally be LESS THAN 1 become LESS THAN ZERO. It's what allows us to get a penalty whenever DEF is greater than ATK.

What puzzles me is how this whole value ends up being multiplied by the damage_scale (again) plus one.

I kind of understand base_penetration (as described above) although it seems weird that the LOWEST IT CAN GO is -1 and the highest it can go is infinity - 1.

damage_scale is aggressor_atk / defender_def . As such, it can never reach zero. Unless aggressor_atk is zero -- then it can reach zero. But in general, as long as the aggressor has any positive number for ATK (which is always the case), this number can never completely reach zero, let alone go negative.

We've experimented with a number of different 'kenny_constant's, and have found it to be pretty arbitrary. It just seems to affect the SCALE of the penetration damage. But I do want to point out that, by having this value be GREATER THAN 1 AT ALL TIMES, we ensure that the base_penetration is always scaled further from zero rather than nearer to zero. So, +1 guarantees that.

By adding 1 to our penetration_scale, we see that, when ATK is equal to DEF, penetration_scale = 2. So, that seems kind of weird. Does that mean that, when ATK is equal to DEF, we end up with extra damage from the penetration value?

Let's look, again, now that Kenny's here, at how I've changed his equation.

damage_scale = (ATK / DEF)
scaled_damage = base_damage * damage_scale
base_penetration = (ATK / DEF - 1)
penetration_scale = (1 / (DEF / ATK) + kenny_constant)
scaled_penetration = base_penetration * penetration_scale
total_damage = scaled_damage + scaled_penetration

AS:

damage_scale = ATK / DEF
scaled_damage = base_damage * damage_scale
base_penetration = damage_scale - 1
penetration_scale = damage_scale + kenny_constant
scaled_penetration = base_penetration * penetration_scale
total_damage = scaled_damage + scaled_penetration

The new equation for penetration = (damage_scale - 1) * (damage_scale + 1)

So, when ATK is equal to DEF, our base_penetration = 0, but penetration_scale = 2.

So, we have 0 * 2.

I mentioned, above, that by adding at least 1 as the kenny_constant, we ensure that the penetration_scale is always greater than 1. Otherwise, whenever DEF was greater than ATK, our penetration_scale would become values between 0 and 1, which means that our base_penetration is scaled closer to zero. So, by adding at least 1, as the kenny_constant, we ensure that our values are always scaled away from zero.

So, if we remove the kenny_constant, I would think that would cause our penetration damage to go haywire? Because it would start being scaled toward zero in certain circumstances?

My hypothesis was incorrect. Entirely removing the Kenny Constant doesn't cause anything to go haywire. Even though we now have situations where the 'scale' can be values less than 1, everything still behaves as it should.

So, for the sake of simplifying our equation -- because the 'kenny_constant' is completely arbitrary -- we're going to remove the kenny_constant, for now, (and bring it back, later, to have more fine-grained control over scaling) and examine our penetration equation as such:

(damage_scale - 1) * damage_scale

So, in that respect, damage_scale and penetration_scale are exactly the same. We're scaling base_penetration by the same value that we're scaling base_damage.

base_damage * damage_scale + base_penetration * damage_scale
=
(base_damage + base_penetration) * damage_scale

So we basically have a universal damage_scale and the kenny_constant is just there as an additional measure to give us more fine-grained control of how penetration scales -- makes it more or less dramatic.

(damage_scale - 1) * damage_scale
=
damage_scale * damage_scale - 1 * damage_scale
=
(atk * atk) / (def * def) - (atk / def)

You know, I never considered the fact that, because penetration_damage = base_penetration * penetration_scale , that, maybe, I conceptually had the values labeled backwards?

Because, since they're multiplied by each other, the base_penetration could be thought of as scaling the penetration_scale to get our total value.

In other words, maybe it makes more sense to think of:

damage_scale + kenny_constant

as being our base_penetration.

And maybe it makes more sense to think of:

damage_scale - 1

as our penetration_scale. I mean, that makes more sense, right? That's why we have that -1 to send values, where DEF is higher than ATK, into the negatives. It's a multiplier that creates this penalty?

If we reversed the labels so that I can re-conceptualize this equation, we end up with this:

base_penetration = damage_scale
penetration_scale = damage_scale - 1

If we look at the equation this way, then we could say that our base penetration damage is always positive, and it's a value between 0 and infinity. The higher our DEF is over our ATK, the less base penetration damage we get -- but it never falls into the negatives.

From this perspective, you could look at base_penetration as bonus damage.

We scale it by a value between -1 and infinity - 1. So, when ATK is below DEF, the multiplier is negative, and thus we get a damage penalty.

I don't think that works for me. I think that it still makes more sense to look at the values as:

base_penetration = damage_scale - 1
penetration_scale = damage_scale

I talked before about how we can unify this as:

total_damage = (base_damage + base_penetration) * damage_scale

Then I think I understand. base_penetration is a value between -1 and infinity - 1 which goes up when ATK is greater than DEF and goes down when DEF is greater than ATK. As such, we have this bonus / penalty applied to our damage which reflects how overwhelmed our ATK is or isn't by DEF.

So, I have one final question: is it a problem that our base_penetration bottoms out HARD at -1 but has no apparent ceiling?

If that's a problem, can we solve that problem?

Kenny mentioned earlier that values can go 'haywire' when ATK is more than twice DEF, and I can see why that'd be the case: it gives us a BONUS TO DAMAGE that's greater than we could ever be PENALIZED TO DAMAGE.

One solution would be to CAP PENETRATION? So that base_penetration is always between 1 and -1.

My theory is that the '-1' in 'damage_scale - 1' is so that damage_scale can reflect a PENALTY to damage.

damage_scale is always between zero and infinity. Therefore, it can never be negative. However, when DEF is greater than ATK, damage_scale is always less than 1.

Therefore, by subtracting 1, we make it so that, whenever DEF is greater than ATK, we have a value that's between zero and -1. So, we get a damage penalty whenever DEF is greater than ATK.

What strikes me about this is that, if ATK is twice DEF, then base_penetration = 1. But if ATK is 3x DEF, then base_penetration = 2 -- and so-on.

So, we can reach base_penetration damage of much higher than 1 but we can't quite get a damage_penalty of -1.

Our entire damage equation is this:

For one thing, we have no weapons or armor in our game. Creatures / units / monsters or whatever you want to call them have ATK and DEF values, and their abilities each have a base_damage value associated with them. So, some abilities that can be chosen in battle inherently do more damage than others. If it makes you more comfortable, you could think of these abilities as being individual weapons that a unit can use on any given turn. But, basically, you pick an ability to use on that turn and that ability has some base amount of damage that it would be expected to do when the aggressor's ATK is equivalent to the defender's DEF.

So, we have this basic equation for our damage:

total_damage = base_damage * (aggressors_atk / defenders_def)

Using this equation, when the aggressor's atk is equal to the defenders_def, then the ability does its base_damage.

If the aggressor's ATK is twice the defender's DEF, then the ability does twice its normal damage.

If the defender's DEF is twice the attacker's ATK, then the ability does one half of its normal damage.

We're talking about a secondary aspect of our game's damage calculation which is meant to add tactical depth to ability choice. In our game, there are two main types of attacks, we'll say:

abilities that lump all of their damage into a single 'hit' and abilities which divide their damage up over multiple 'hits'.

So, imagine an ability, 'Slap,' which deals a base damage of 10 over a single hit.

Now, imagine an ability, 'Double Slap,' which has the same costs to the player (MP, AP, cost to purchase, whatever), but it dives this base damage of '10' over two hits, each with base damage of 5.

The purpose of our game's 'penetration_damage' calculation is to make these two abilities tactically distinct. In our game, with our current equation (which is working; I'm just trying to figure out, before we settle on it, if there are any issues with it), a single hit for 10 base_damage and a multi-hit for 10 base_damage only do the same total_damage when ATK == DEF.

The idea is that, when ATK > DEF, the player is rewarded for splitting up their base_damage over multiple hits.

When DEF > ATK, the player is penalized for splitting up their base_damage over multiple hits.

base_damage = constant defined by the ability
damage_scale = atk / def
scaled_damage = base_damage * damage_scale

base_penetration = atk / def - 1

total_damage = (base_damage + base_penetration) * damage_scale

Look at it like this: as our ATK climbs over our DEF, we get damage added to our base_damage. And when ATK is less than DEF, our base_damage gets penalized.

The reason that multi-hits are penalized MORE is because this atk / def - 1 value its relatively larger -- it makes up a greater percentage of our total basis -- when base_damage is lower.

In other words, if base_damage is 10 and we add 1 penetration, we're adding 10% of our damage.

But, if base_damage is 1 and we add 1 penetration, we're adding 100% of our damage.

So, basically, the LOWER BASE_DAMAGE IS, the more of an impact on the total damage penetration has.

As such, when we take this damage equation and we run it MULTIPLE TIMES -- ONCE FOR EACH 'HIT' -- we get a situation where the TOTAL, SUMMED DAMAGE is affected by how many times penetration is applied.

For Thursday: is it a problem that our greatest PENALTY for penetration is near-but-not-quite -1. And our greatest bonus is hypothetically much higher than 1.

If it's a problem, how can we fix it? Kenny is sort of at the same place I am: it's almost like we need a multiplier for penetration rather than a linear subtraction? But, again, I'm having a lot of trouble keeping all of these disparate concepts in my head at once. We need to run some practical examples to demonstrate this issue, if there is one. I figure that, if the problem's gonna arise, it's gonna arise when we look at HOW MUCH PENALTY WE GET TO DAMAGE WHEN DEF IS 4X ATK compared to how much BONUS we get when ATK IS 4X DEF. It seems to me, theoretically, that our bonuses would be waaaaay more extreme than our penalties. But maybe I'm wrong.

08/01/19:

Our issue is this: theoretically speaking, the scale of attack penetration (bonus) is much less limited, APPARENTLY, than def penetration (penalty).

Here's our equation for calculated total penetration damage:

total_penetration = (ATK / DEF - 1) * ATK / DEF

My question is this: what is the significance of the '-1'.

My theory is that its MAIN PURPOSE is to give us a damage penalty whenever DEF is higher than ATK. And when ATK is higher than DEF, we get a damage bonus.

ATK / DEF gives us a number > 1 whenever ATK is higher than DEF. When DEF is higher than ATK, we get a fractional number -- a number between 1 and 0.

But neither of those scenarios gives us a NEGATIVE NUMBER -- or a damage penalty.

By subtracting ONE from ATK / DEF, we ensure that, whenever DEF is greater than ATK, we fall into negative numbers. Normally, if DEF was higher than ATK, we'd get a number between 1 and 0. By subtracting 1, we get a number between 0 and -1 whenever DEF is greater than ATK.

As someone that sucks at math, I want to make a note, here, that we don't need our penalty to be -- scratch that. Basically, what I'm trying to say, is that as a BONUS scales up indefinitely toward infinity, in terms of SCALE (3x our DEF value, 4x our DEF value, 10x our DEF value), our PENALTY scales down toward ZERO. That's only natural, although it seems counter-intuitive to me (.5x our ATK value, .33x our ATK value, .1x our ATK value). In terms of SCALE, that's sensible.

My question is, when you take this SCALE: ATK / DEF. And you try to turn it into a flat number to use as a bonus or a penalty... do you need to do more than just subtract 1 from it to make that work.

ATK / DEF is a scale. It compares their scale to each other. If we're talking about transforming that scale into a linear bonus or penalty, it seems to me like you can't just subtract 1 from it.

But, a problem with my theory is that, in practice, based on the limited testing we've done, it seems to work fine. It seems to work great. I have no complaints with how it's been working, in practice. So, I guess we need to analyze this equation and come up with a scenario to PROVE that it's not working.

Let's examine how the equation is working so far:

When ATK and DEF are equal, our summed damage of all of our hits is always equal to the sum of our base_damage. That's what we want, so it's working great. This is because, when ATK and DEF are equal, ATK / DEF = 1. And then we subtract 1 from that, which gives us 0 penetration damage. So, our total damage is always just our base_damage added up.

That was a part of our goal when coming up with our equation, so that's great. Works fine.

When ATK is higher than DEF, we see that we get a positive penetration bonus and that, as we gain hits, we gain total damage. In other words, the more hits we split our base_damage over, the more total damage we get. That's what we wanted.

When DEF is greater than ATK, we get a penetration PENALTY that's linearly less severe than the equivalent BONUS that we get when ATK is equally higher than DEF -- but having it be linearly less severe not only makes sense but was one of our goals, because as DEF goes up and 'scaled damage' goes DOWN, the penalty becomes relatively MORE of the total damage.

When ATK is greater than DEF, we're ALREADY DOING MORE DAMAGE. We're doing 20 instead of 10. So, if we get a penetration BONUS of 2, then we're adding another 10% on top to give us 22 damage. That seems fair.

But when DEF is greater than ATK, we're ALREADY DOING LESS DAMAGE. We're doing 5 instead of 10. What's interesting about that is that, if we subtract 2 damage by applying a penalty penalty that's equal to the bonus we would've gotten on the opposite end of the scale, we're subtracting almost 50% of our damage by reducing 5 to 3.

So, if we have an equal penalty as we would have a bonus at the opposite end of the scale, it blows the damage way out of proportion.

What I'm getting at is that it's a good thing, it's a necessary thing that our penetration PENALTY would be a fraction of what our bonus would be at the other end of the scale.

First of all, maybe we should answer this question: WHY does this equation work, right now.

For one thing, when you have double ATK over DEF, our base bonus is 1.

And when you have double DEF over ATK, our base bonus is -.5 .

This is represenative of what we were just talking about: our penalty is nowhere near as severe as our bonus would be on the other end of the scale. Furthermore, this bonus / penalty is scaled by ATK / DEF. So, when ATK is greater than DEF, the bonus is scaled upward toward infinity.

When DEF is higher than ATK, our penalty is scaled down toward zero.

So, actually, our total penetration for when ATK is double DEF is 2. We get the base bonus of 1 (2 - 1) and then we multiply that value by ATK / DEF, which is 2. 1 * 2 = 2.

Our total penetration when DEF is double ATK is -.25 . Our base penalty is -.5 (.5 - 1), and then that's multiplied by ATK / DEF, which is .5. So, we cut -.5 in half.

So, double ATK earns you a bonus of 2 damage per hit.

Double DEF earns you a penalty of -.25 damage per hit.

In order to figure out whether or not things are working, I think that we need to understand these values that I've been calculating for this very purpose: 'damage advantage'. Although my stupid ass hasn't come up with a way to actually utilize these values, I knew that they'd be important.

So, basically, I've been calculating the percentage advantage that ATK has over DEF. And I've been calculating how much of an advantage our DAMAGE has over base_damage. The purpose of these two numbers is to compare them to each other -- compare the ATK ADV over the DAMAGE ADV -- and see exactly how large the impact is of penetration. Because, in a world without penetration, these values would be exactly the same: your advantage of ATK over DEF would directly reflect your advantage in damage over base_damage.

Before we can really start to analyze these 'ATK ADV' numbers, I need to understand the relationship between DEF ADV and ATK ADV.

When ATK is 12 and DEF is 10, we have an attack advantage of 20%. That makes sense.

When DEF is 12 and ATK is 10, we have a defense advantage of 20%. That makes sense.

What I'm not prepared to understand, right away, is that, when DEF is 12 and ATK is 10, we don't have a 'atk adv' of -20% -- 20% less ATK than DEF -- instead we have -16.6666 advantage.

The way that I conceptualize our total damage equation is like this:

total_damage = ((base_damage + ATK / DEF - 1) * ATK / DEF) * hits

The reason that ATK advantage isn't -20% when DEF is 20% than ATK is that we are comparing the scale from ATK to DEF. So, if ATK is 10 and DEF is 12. Yeah, DEF is 20% than ATK, but ATK is WHAT PERCENTAGE OF DEF. 10 is 83.333333% of 12. And so we have this negative adv of the difference. -16.6666666% advantage.

Our problem is that our attacks, in our game, get a penetration bonus / penalty of:

(ATK / DEF - 1) * (ATK / DEF)

I'm trying to figure out what the '- 1' is for and whether or not it's going to cause issues at some point.

If ATK / DEF = .25, that means that ATK is 1 and DEF is 4. Def is 4x ATK.

If ATK / DEF = .75, that means that ATK is 3 and DEF is 4. Def is 25% than ATK.

IDEALLY, IN A PERFECT WORLD, OUR DAMAGE PENALTY WHEN DEF IS GREATER THAN ATK SHOULD BE PROPORTIONALLY EQUIVALENT TO OUR DAMAGE BONUS WHEN ATK IS GREATER THAN DEF BY THE SAME AMOUNT.

So, when ATK is 20 and DEF is 10. Let's say that our penetration bonus yields us 2 damage. Let's say that our base_damage is 10. So, we're getting double damage because ATK is twice DEF. We're getting 20 scaled_damage. We're getting a penetration bonus of 2. Our total damage is 22 and our penetration bonus is 10%. We are added 10% of our scaled damage to total_damage.

My question is this: can we say that, in a perfect world, with our ideal equation, this is true:

if DEF is 20 and ATK is 10, and we have a base_damage of 10. Our scaled_damage is 5. So shouldn't. Our. Penetration penalty. Be 10% of 5. So we lose .5 damage. Our total damage is 4.5.

If that's true, there's not going to be any difference for multi-hits.

If you look at it the way that it's described above, you would want to have AS MUCH OF A PENALTY AS YOU HAVE A BONUS ON THE OTHER END OF THE SCALE.

If 2x ATK gets you a 10% bonus, then 2x DEF should get you a 10% penalty. But again, the problem with that is that it doesn't work right for multi-hits. You don't get rewarded or penalized for multi-hits.

If you wanted penetration damage to become linear, you would exclude it from damage_multiplier / damage_scale. And I don't see how that would be a problem? I mean, for the longest time, we didn't even really understand that it WAS being scaled the same as scaled_damage.

So, it would like this...?

total_damage = base_damage * (ATK / DEF) + ATK / DEF

Kenny points out that we could theoretically accomplish this with two equations that would look like this:

if atk > def:
    total_damage = base_damage * (atk / def) + atk / def
else:
    total_damage = base_damage * (atk / def) - def / atk

NOTE: KENNY POINTS OUT THAT PENETRATION DOESN'T SCALE AT ALL WITH BASE_DAMAGE OR SCALED_DAMAGE OR ANY KIND OF DAMAGE. IT'S JUST A LINEAR VALUE BASED ON ATK / DEF AND SO IT REWARDS LOWER BASE_DAMAGE MORE AND HIGHER BASE_DAMAGE LESS.

Our current equations:

if atk > def:
    total_damage = base_damage * (atk / def) + atk / def
else:
    total_damage = base_damage * (atk / def) + (atk / def) * -1

Is it fair to say that the whole point of penetration is that lower base-damage moves get more of a bonus / penalty compared to higher base-damage moves?

The fact that higher base-damage moves get relatively less of a bonus is why you use lower base-damage moves that hit multiple times.

The fact that higher base-damage moves take relatively less of a penalty is why you use them instead of lower base-damage moves.

Kenny's argument is that, as base_damage gets higher, penetration becomes more neglibible. I think that's the point?

When the player is going to be taking a penetration PENALTY, we want for them to choose an attack, like slap, which has a base_damage of 10.

When the player is going to be getting a bonus, we want for them to choose an attack like double-slap, which has a base_damage of 5, and use it twice.

Kenny's right that, as our base_damage and scaled_damage go up, our penetration does not. Seems weird. Is it weird, or is that what we want?

What Kenny's saying is that, if we have a hypothetical move that does 1000 base_damage. And we get a penetration bonus of 1. We are getting virtually no bonus.

If we double-slap that for two hits of 500, we're still getting virtually no bonus. So, tactically speaking, it becomes less important whether you single-hit or multi-hit when we get to extremely high numbers.

Dixx points out that, obviously, this issue isn't as apparent when we just all agree to limit our base_damage to some range. My concern is that, if the equation were actually behaving as it hypothetically 'should,' we shouldn't have to do that. I feel like applying that sort of cap or limit is like a band-aid to cover up a problem that we could probably solve in a relatively simple way if we were smarter.

There are a few ideas that we hit upon, today, that I think profoundly reflect what we're trying to accomplish, maybe. I want to decode them a bit:

I think that the PENALTY that we take from having DEF be 4x ATK should be proportionally equivalent to the BONUS that we get when ATK is 4x DEF. So, if we get a 20% bonus to our damage for having 2x ATK over DEF, we should take a 20% penalty to our damage for having 2x DEF over ATK.

The problem with that is that it doesn't account for multi-hits in any meaningful way.

We also clarified that higher base-damage abilities take relatively LESS OF A BONUS and LESS OF A PENALTY than lower base-damage abilities. Never really thought of it that way, before. So, the more base_damage you have, the more stable your total damage, kind of? In both a good way and a bad way. You WANT more of a bonus, so you WANT lower-base-damage abilities (at proportional cost). But you also want LESS of a penalty, so you want higher-base-damage abilities.

So, it's like, higher base-damage proportional to cost makes your damage more stable or less susceptible to penetration, one way or the other.

But the problem with that is that it doesn't take into account the SCALE of the abilities' base_damage. So, if we have a game where 'slap' does 10 base_damage and 'hyper slap' does 10000 damage, penetration really becomes much less interesting at 10000 damage.

But that's probably fine because we've not only been thinking of 'slap' as being '10 base damage' arbitrarily; we decided early on that slap, and its 10 base_damage, is our 'base-line' or 'average' ability. So, I think it makes sense to set the scale of penetration to that base-line ability. We can get as low, then, as 1 damage and as high, essentially, as 100 damage. I didn't really understand that, by talking about a 'baseline, average ability,' we were effectively setting caps.

Next time, on Monday, let's continue to examine the 'DEF > ATK' and 'ATK > DEF' variants as described above and see if we're getting behavior in line with what we want. My thinking is that, yes, this is pretty much where we want to be and all that we need, unless we can come up with a way to mathematically break these ideas down into one equation, so that, whenever ATK / DEF is less than one, we're multiplying it by -1, and when ATK / DEF is greater than one, we're multiplying it by 1.


08/05/19

So, over the weekend, Kenny and I briefly discussed what we're looking for with this 'ideal equation,' and let's review our criteria:

1.) Do we want for the penetration damage to scale, in some capacity, with the over-all damage? Does an attack which does _______ amount of damage deserve to have more penetration damage than an attack which does _______ amount of damage. Kenny pointed out, last time, that if we have some hypothetical attack which does 5000 base damage, doesn't it seem weird that it should get the same amount of penetration damage as an attack with 10 base damage. I theorized that this is a non-issue because of the fact that we're balancing our attacks around a 'baseline' base damage, but I'm not convinced that this entirely resolves this issue.

2.) I wish that we could combine our DEF > ATK formula for penetration with our ATK > DEF formula. I theorized that we could almost certainly do this with some very simple math that we just hadn't thought of, and I was hoping that we could examine that, today, and try to figure out what that very simple equation would be.

And I think that Kenny found that very equation. I knew it would be simple, and I think that he figured it out.

First of all, let's examine what our CURRENT equations are:

Whether ATK is greater than DEF or not, we always use the same, simple calculation for 'scaled damage':

scaled_damage = base_damage * (ATK / DEF)

But, for penetration, we use a different formula depending on whether we want an damage BONUS or a PENALTY:

ATK > DEF:
penetration = (ATK / DEF)
total_damage = scaled_damage + penetration

DEF > ATK:
penetration = -(ATK / DEF)
total_damage = scaled_damage + penetration

The problem was that, as far as I could tell, we didn't have a mathematical solution for making penetration NEGATIVE when DEF is greater than ATK and POSITIVE when ATK is greater than DEF.

Well, Kenny solved this in the most obvious way possible: just subtract DEF from ATK and use that as your penetration value.

scaled_damage = base_damage * (ATK / DEF)
penetration = (ATK - DEF) * penetration_scale_factor
total_damage = scaled_damage + penetration

This solves one of our problems: it unifies our equations in a way that makes sense (although I feel like this has the problem where the penalty is much harsher than the bonus). But it doesn't solve our question of whether or not higher-damage abilities should get more penetration.

So, first of all. Can we solve this problem where penalties are much harsher than bonuses.

One way, I think, would be Kenny's second recommendation: scale the penalty by ATK / DEF.

The upside of this is that, on top of giving us a positive value when ATK is over DEF, we also INCREASE that bonus because ATK / DEF is greater than one.

Also, when DEF is greater than ATK, we get a negative value, yes, but that value is brought closer to 0 because ATK / DEF is between 1 and 0. So, the penalty is being downscaled.

So, Kenny's second recommendation looks kind of like this:

penetration = (ATK - DEF) * penetration_scale_factor * (ATK / DEF)
or
total_damage = (base_damage + ATK - DEF) * (ATK / DEF)

We did some testing, and this equation appears ideal -- unless we decide that we want for penetration to scale with scaled_damage (so, the more damage you would've done BEFORE penetration, the greater penetration bonus you get). But, even just writing that, I'm not sure that's possible; I'm not sure that's what we want.

But, in any case, by calculation penetration as:

penetration = (ATK - DEF) * penetration_scale_factor  * (ATK / DEF)

we end up with some very pretty penetration values. For instance, if 10 ATK / 20 DEF results in a -5% penetration penalty, then 20 ATK / 10 DEF results in a +5% penetration bonus. That's godlike. That's what we want.

The thing is, the whole point of penetration is to reward a player for using an ability with relatively HALF base_damage and relatively HALF cost when attacking an opponent with lower DEF than you have ATK.

So, we can balance our values around our 'baseline' base_damage of 10. When I say 'baseline,' I mean that our whole game is balanced around the idea of doing 10 base damage for some reasonable cost. So, when you have an attack that does 5 base damage, it's either going to be roughly half the cost or it's going to have some other perks.

That all  being the case, if we set our penetration_scale_factor around this most basic of abilities, then it'll probably behave 'well' for any ability in the game. And maybe that's what we want. Maybe that's the only way that it could be and still make sense.

But here's my problem hypothetical.

If we then create an ability which does 20 base_damage for twice the cost of Slap (10 base damage).

The REWARD for using Slap as opposed to this Hyper Slap when ATK > DEF is relatively LESS REWARD than when we go from Slap to Double Slap.

Likewise, the PENALTY for using Slap as opposed to this Hyper Slap when DEF > ATK is relatively LESS PENALTY than when we go from Slap to Double Slap.

I'm kind of glad that we introduced this 'Hyper Slap,' because it makes more clear that we have this sense of scale that can go indefinitely high or indefinitely low. Is there a way to ensure that the REWARD or PENALTY for choosing the wrong or right ability at any scale stays PROPORTIONAL.

Well, maybe the key word is 'proportional'. Maybe this penalty or bonus is scaled based on the base_damage's relative value compared to 10...? That seems like it would be a problem. That would break our current mechanism where 'Double Slap' has 5 base damage, and so its penalty is changed proportionally, so the whole ATK - DEF * whatever thing doesn't really work, any more.

Let's establish a situation:

ATK is 15
DEF is 10

We want for the BONUS that the player gets for choosing Slap instead of Hyper Slap to be PROPORTIONALLY REWARDING compared to if they chose Double Slap over Slap.

Or do we? Do we need it to be proportional. Because, if Hyper Slap costs double that of Slap (which it does), then are they not making the exact same decision as they would if they chose between Hyper Slap and using Double Slap four times. So, does it make sense to think of this 'penetration bonus' as having to be proportional -- like, lemme re-word this. Lemme re-conceive this.

Maybe what I'm saying is tying back to 'more base_damage should get more of a penetration bonus / penalty / whatever'. Because

if you can choose to use Double Slap 4 times
Or Slap 2 times
Or Hyper Slap 1 time

I guess what I'm asking is this:

Is it more rewarding to go from using Slap to Double Slap when ATK is 15 and DEF is 10 than it is to go from Hyper Slap to Slap.

My thinking, flawed as it may or may not be, is that the penetration bonus that you get from going from Slap to Double Slap makes up a higher percentage of the total damage than if you go from Hyper Slap to Slap.

Because, with Hyper Slap, you're working on a larger scale, so any reward or penalty would seem to be less relative to your non-bonus'd/penalized damage.

But maybe that thinking falls apart when you consider that you could also go from Hyper Slap to Double Slap. Now, you're Double Slap'ing 4 times, so that bonus adds up even more.

If you compare going from Slap to Double Slap : to going from Hyper Slap to Double Slap, you are definitely getting TWICE the penetration bonus. Because you're using Double Slap TWICE as many times.

So, I think, conceptually, that solves our problem. I think that, conceptually, you're not INTENDED to get as much reward, proportionally, for going from Hyper Slap to Slap as you are going from Slap to Double Slap. That's the fallacy. The fallacy is that you should get proportionally as much reward in that situation.

Because we aren't rewarding the player as much for going from Hyper Slap as we are rewarding them from going from Slap to Double Slap.

We're rewarding the player PROPORTIONALLY for going from Hyper Slap to DOUBLE SLAP as we are rewarding them for going from Slap to Double Slap.

We're not rewarding the player for choosing 'Slap' in that situation. If they have 15 ATK and the enemy has 10 DEF, and they have three abilities available to them, they SHOULDN'T be using Hyper Slap, BUT THEY ALSO SHOULDN'T BE USING SLAP.

You want to reward them for having the best cost to base_damage ratio, where base_damage is the lowest. That's the whole point of our system. So they should obviously be using DOUBLE SLAP.

And yeah, because Hyper Slap costs twice as much as Slap, the player gets TWICE AS MUCH PENETRATION BONUS for using Double Slap as they would've gotten for using Double Slap instead of Slap.

If you can Slap and you choose to Double Slap, you get a certain amount of penetration bonus.

If you can Hyper Slap and you choose to Double Slap, you get DOUBLE that penetration bonus.

Because Hyper Slap costs twice as much as Slap.

So, it IS proportional, in that sense. That's what we want. In that respect, going from Hyper Slap to Slap SHOULDN'T be as proportionally rewarding as going from Slap to Double Slap. The proportional equivalence comes in when going from Hyper Slap to Double Slap. Not from Hyper Slap to Slap.

That's core to our idea that lower-base-damage moves with proportionally equivalent costs are rewarded more when ATK is greater than DEF. Because Slap does more damage than Double Slap, it shouldn't be as proportionally rewarding.

So, the only practical thing to do is dial in penetration_scale to any arbitrary value that we feel makes the most sense around the damage of our most baseline ability.

So, on Wednesday, I want to get back to defining our most base-line of units and designing our most baseline of abilities around that -- or vice-versa. We could even start that, now, for ten minutes.

So, let's talk about what our baseline unit should look like, mathematically:

It's ATK should be equal to its DEF.
Its PRY should be equal to its SKL.

It needs enough HP to survive as long as we think that a basic, average unit should be able to survive.

And, the baseline-damage of our most basic attack needs to kill our baseline unit as fast as we want it killed.

From that, we need to decide how much resources that baseline unit has insofar as MP. To use this ability to kill another unit in some amount of time which seems fair.

LP... I don't even really know how to think about that, yet.

So:

baseline attack:
    arbitrary amount of base_damage
    arbitrary cost

baseline unit:
    HP: enough to survive the baseline attack for a fair (to be determined)
        amount of time.
    LP: ????? Determines how many times the unit can be revived.
    MP: enough to afford extra-powerful abilities to kill another baseline
        unit faster than they could with the baseline attack.
    ATK: arbitrary number equal to DEF.
    DEF: arbitrary number equal to ATK.
    SKL: arbitrary number equal to PRY.
    PRY: arbitrary number equal to SKL.

baseline leader:
    AP: enough to afford the baseline attack enough times that an enemy
        baseline unit could survive the number of TURNS that we want them
        to survive

So, first of all, we need to think about how long we want for our baseline units to survive. Once we know that, we can define their HP and MP and the leader's AP.



08/07/19

Today, our goal is to design a baseline unit as far as character attributes are concerned.

So, let's not waste any time. In review of the attributes we need:

HP
LP
MP
ATK
DEF
SKL
PRY

AP

When determining these attributes, what we need to think of is an example strategy in our game -- we gotta imagine how a typical turn will play on.

We know that, on a single turn, a leader has 10 AP.

And we decided that swapping a unit costs 3 AP.

As I recall, we decided that a 'baseline ability,' or an 'average ability,' will cost 3 to 4 AP to use.

So, what does this mean?

It means that, on a single turn, a player can swap twice and use a single ability.

It means that a player can use two abilities and swap once.

It means that a player can use three abilities and not swap.

It means that a player can swap once and use a powerful ability.

It means that a player can't use a powerful ability if they swap twice.

Knowing all of this, how much HP should a unit have? How vulnerable do we want to allow a single unit to be?

I think that 10 'base damage' is good for our baseline, 3-AP-costing ability, because that gives us plenty of room to do less damage as we dip into 2AP and 1AP costs. 10 seems like a pretty good number to establish as a basis.

We also know that the enemy cannot swap out their unit during OUR turn. So, I think that it's safe to say that the opponent needs to have MORE than 30 HP. Because we don't want to be able to KO the opponent in a single turn just by using all of our AP on our most baseline ability.

So, let's say that, as AP cost goes up, damage goes up NON-PROPORTIONALLY. Because you're making more of a commitment by using a higher-AP ability than you would be using a lower-AP ability, so the damage should scale up to reflect that higher commitment.

That being said, if there was a hypothetical ability that would cost 10AP, it would do much more than 30 damage. Much more. But it would cost an entire turn.

I feel like our baseline unit shouldn't be able to afford MUCH MORE than ONE WHOLE TURN OF VULNERABILITY. If they could survive just being left on the field for three whole turns (without ever being swapped out), then there'd be very little urgency to move units in and out of the ring. On the other hand, I don't think that it should be trivial to kill a unit in a single turn of vulnerability. So, maybe we should say that a unit should be able to survive almost two turns of vulnerability.

If Slap (10 base damage, 3 AP cost) is an 'average damage, average cost, average commitment' ability, then we can probably assume that an average, aggressive unit could, if used on a turn without character swapping, be expected to do ~50-60 damage. But that's with a relatively high commitment, because we're talking about them using all of their AP for direct damage and not swapping at all.

So it seems to me that a baseline unit should have somewhere between 70 and 80 HP.

If we give our baseline unit 75 HP, they could probably just BARELY be killed IN A SINGLE TURN by a unit with very high ATK and especially devastating abilities, if that aggressive is ALREADY IN THE RING WHEN THE TURN STARTS and never leaves the ring for that turn. That's very high commitment, that's not going to happen unless the player makes some very risky moves, and I'd say, then, that it's reasonable that the opposing unit would be killed or nearly killed in a single turn.

Maybe it makes more sense to lower the baseline HP to between 60 and 70.

Because, if you slap three times, with average ATK, you're doing 30 damage. So 60 already seems pretty high -- that's two whole turns of being slapped. And if you use ALL 10 OF YOUR AP on attacks, you're looking at around 40 damage unless you invest in abilities which are extra-high-cost in which case you could probably get as high as 60 or barely above -- but that's base_damage. So, if you also have extra high ATK, you could probably get to 70 or 80.

I feel like, then, '70' is high HP, and '60' is sort of average'ish to low? So maybe 65 is a good midpoint where there's urgency but you're unlikely to be one-shotted. Maybe '60' is a nice, rounder number where we can be comfortable knowing that a unit is in very little risk of being one-shotted.

Way less risk, for instance, compared to Pokemon, where one-shots happen constantly. I mean, keep in mind that we're sort of punishing the opponent for leaving this unit vulnerable, in the ring, at the end of the turn. And, if I want to do anything OTHER than attack (inflict status, heal or buff, etc.), then I can't even really be expected to do 40 damage -- with an aggressive, high ATK unit.

So, let's work with 60 for now. That seems urgent, it seems tense, it seems fair. An average, all-attack turn would deal between 30 and 40 damage. So I feel like 60 is pretty durable.

I mentioned, above, that the values for ATK, DEF, SKL, and PRY are all ARBITRARY, because ATK and DEF get their value in RELATION TO EACH OTHER. Likewise, SKL and PRY get their value IN RELATION TO EACH OTHER. So, their exact values are not as important as the fact that, for a baseline unit, they're equal.

That being said, we haven't talked a whole lot about character growth in our game, but here's some things we need to understand about setting a baseline value for these attributes:

1.) Units vary in their attributes. So we need to have a HIGH ENOUGH BASELINE that some units can have 'high ATK,' and some can have 'low DEF,' right. Just like we chose 10 base_damage for slap because I feel like it's just high enough for us to have a lot of variance BELOW the baseline, maybe 10 is a good baseline for ATK, DEF, SKL, PRY, because it's still high enough that we have 9 degrees of variation BELOW the baseline.

But that might cause an issue with this second consideration:

2.) Character growth. If we set a baseline value that's TOO LOW, we need to be careful about how the unit can grow their attributes. For instance, if we set a baseline of 10 for all of our attributes, that means that, if we give a player '1' to their stats whenever they 'level up,' and if they level up somewhat often, we're talking about them doubling their stats pretty quickly or otherwise outclassing their opponent's attributes pretty quickly.

But, in that respect, maybe 10 is still a nice number compared to something like 5.

Let's consider, briefly, the typical 'arms race' of a JRPG -- as your heroes are leveling up and the opponents are leveling up, this 'baseline' should be expected to raise. It's a matter of keeping up with the Joneses.

Let's also consider 'nerf' and 'buff' abilities. If we have '10' baseline ATK, that means that the LOWEST % WE COULD BUFF ATK would be 10%. But maybe that's fine. Maybe that's a good and decent and god-fearing percentage for a minimum ATK buff from an ability. And then you could say that an 'average' buff would be +2, and a 'good' buff would be +3.

10's a good baseline.

So, what do we know so far?

Baseline Ability, "Slap":
10 base damage
3 AP cost

Baseline Unit, "Bobbo":
HP: 60
LP: ???
MP: ???
ATK: 10
DEF: 10
SKL: 10
PRY: 10

Let's look at HP again.

I've repeatedly pointed out that, with Slap, we can deal 30 base_damage to another baseline unit in a single turn.

But I do want to stress that we can only do that 30 damage IF OUR UNIT IS ALREADY IN THE RING WHEN OUR TURN STARTS AND WE'RE COMFORTABLE LEAVING THAT UNIT IN THE RING WHEN THE TURN ENDS AND WE WANT TO SPEND ALL OF OUR AP SIMPLY ON DEALING HP DAMAGE.

So, that 30 damage is a PRETTY HUGE AND UNUSUAL COMMITMENT.

Now, another thing I've mentioned is that, if you know that you want to spend all of your AP in a single turn on doing HP damage, you could almost certainly get more than 30 because you would trade the flexibility of attacking 3 times for the raw damage of spending all of your AP on a single ATK.

So, I'm thinking 50 damage from a single, fully-committed, aggressive turn from another baseline unit.

That's a huge commitment. Is 60 HP too much HP. Do we want for this baseline unit to die in a single turn if the opponent is willing to hit this hard.

Maybe not. Maybe 60 is what we want.

I'm happy with this. But now we need to think about MP and LP. Let's review what these attributes represent:

MP is a per-unit currency for using abilities. Because this currency is consumed over the course of a battle, we can expect that abilities which require an MP cost (not all will) on top of their AP cost will be above-average in terms of their effectiveness.

Now, we have a problem when it comes to deciding on a baseline MP value, and that's that we don't have any abilities, yet, established as a baseline, which have an MP cost.

In fact, it stands to reason that we should consider this MP cost as we continually examine this base HP value. Because, we theorized that, on a single, hyper-aggressive turn, a baseline unit COULD deal 50 damage to the opponent. And, therefore, with 60 base HP, a unit COULD one-shot a baseline unit if the aggressive unit was especially geared toward ATK.

But there's more to this to consider. How much damage are we REALLY doing on a single turn when you consider that we can also burn MP to do it. And, by extension, how much MP do we want for a single, baseline unit to have.

Well, let's consider that we want for a single unit to be able to survive a turn and a half of vulnerability against a hyper-aggressive opponent.

Each team has 4 units.

And some units are going to be especially balanced toward a high MP value for using special attacks which will become exhausted.

So, in the course of a single fight, a baseline unit should be able to use HOW MANY baseline, MP-burned abilities. First of all, how many turns is an 'average' fight going to last?

4-unit teams, each unit lasts 1 and 1/2 turns against a hyper-aggressive unit.

Therefore, if all units are hyper-aggressive then we get about 6 back-and-forth turns?

But all units are not going to be hyper-aggressive, so we're looking at longer battles. Now, whenever you swap once, you're cutting your aggressive potential by 33% approximately. We're expecting the player to swap units, on average, probably once a turn.

I would say that we're looking at fights that are AT LEAST 10 back-and-forth turns? Probably between 10 and 20 back-and-forth turns?

If we have, let's say 15 back-and-forth turns. How many of those turns do we expect a unit to MP burn? When do we want for them to run out of MP? This is where you balance MP cost and max MP.

Let's think about a mage, first. They've sacrificed other attributes to have above-average MP -- and even then, if they use a lot of MP every turn, we obviously want for them to run dry. That's the whole point of MP: the running dry part. We would want for them to use no more than 2 MP burns on a single turn, across, what, like 6 turns? That seems really generous -- those are small MP burns.

Also keep in mind that moves which cost MP also cost AP -- every ability in the game, pretty much, costs AP. So we don't need to balance MP cost around per-turn usage -- that's what AP is for.

So, if we have MP burns which start at 1MP, that would be a very minor MP burn. But even then, you wouldn't want for a baseline unit to do that for every action on every turn -- that defies the point of MP. So, that's almost where we want to start balancing this baseline. So, it's almost like '1MP' is, like, the average, normal MP cost for things. And once you get to 2MP, you're talking about a pretty serious boost -- and at 3 and 4 and 5, you're talking about stuff that's exclusive to 'mages'.

So, it seems to me, then, that 5MP would make sense for a baseline value. An average, baseline unit can MP-burn 5 times in a fight for a little boost to their effectiveness. And they could use a greater boost a couple times. And they could use mage-exclusive abilities ONCE per battle, supposing they're not a mage.

But, this falls into our danger-zone for character growth. Like, they could double their MP and get access to higher MP-cost abilities MUCH MORE OFTEN by simply raising their MP by 1 point 5 times.

Because, you know, MP cost for abilities isn't going to scale up as the game goes on. So, actually, it seems like we'd want for it to be either VERY EXPENSIVE to raise MP by one point or to set the baseline MUCH HIGHER so that, in order to be able to use abilities more often, you need to raise your MP by quite a large amount.

I'm attracted, sexually, to the idea of having a baseline 'cost' for growing any given attribute. Whether it be HP or ATK or DEF or WHATEVER (probably with the exclusion of LP, which might not be raisable at all). That being said, MP seems especially powerful BECAUSE, unlike every other attribute in the game which becomes a matter of 'keeping up with the joneses' or an 'arms race,' with MP you're only competing with the FIXED COSTS OF YOUR ABILITIES. Those costs are FIXED, so you do want to have a higher baseline so that, by the end of the single-player game, you don't have unlimited use of your best, highest-costing abilities.

So, let's compare MP to HP -- both are a consumable resource. What if we gave the baseline unit 50 MP instead of 5.

Then, the most basic MP burn goes from 1 to 10. Now, you gotta put ten points into MP in order to get one more of those MP burns.

And if a mage ability costs, say, 30 MP, then you could give a mage 90MP. Then, they can use a really powerful mage ability twice and still meter-burn a couple times.

I think that it makes sense, then, to put the basic max MP value at 50. That gives flexibility for ability costs and has a nice, wide scale for units that have lower-than-average MP and higher-than-average MP, as well as a nice scale for units which have DRAMATICALLY HIGHER-THAN-AVERAGE MP to put certain abilities outside of the reach of units which have average MP.

And then, in order to gain another usage of a baseline, mp-burn ability, you have to invest quite a number of points.

Review of our baseline unit:

HP: 60
LP: ????
MP: 50
ATK: 10
DEF: 10
SKL: 10
PRY: 10

Maybe, before we start 3rd strike, we should examine LP quickly. LP is a value which represents how many times a unit can be knocked out before the player has to rest to revitalize them.

This is actually too broad of a subject to cover in 5 or 10 minutes, so we'll leave that for tomorrow.

Tomorrow, Thursday, we'll examine LP in depth and come up with a fitting baseline value for our baseline unit.


08/08/19:

Today, we're going to be focused on 'LP' and thinking about what it really means for our game. This is a topic that we've covered quite a few times during our game-dev discussions in the past, but it couldn't hurt to review it now that we're working on developing our baseline unit. We've gotta decide how MUCH LP is appropriate and, in order to do that, we really need to examine the purpose of LP in our game.

So, without getting all abstract, let's just cut right to a couple examples of how LP has been used in games, in the past, where I've enjoyed it a lot:

The first game that I played with a mechanic like this was 'SaGa Frontier'. In those games, 'LP' is a currency that your units have to represent their health, similar to 'HP.' The difference is that LP could be thought of as a more dire version of 'HP'. A unit might have 200 HP but only 4 LP.

Whenever a unit is KO'd, they lose 1 LP. And once a unit has no LP left, they cannot be revived. In SaGa Frontier, this means that they can't be revived until the player rests at an inn.

Other ways to lose LP might be from taking a critical hit (very frustrating), or being struck while you're down. In SaGa Frontier, when you're knocked out, your unconscious body is lying on the field until you're revived -- and any hit that your body takes while knocked down costs 1 LP.

So, it's a mechanic to give the player one more resource to manage which represents long-term exhaustion over the course of many fights or something that must be desperately protected as one's own life. I feel like it adds a sense of urgency to defending yourself, more-so than you get in most JRPGs.

Another game I've played which has a very similar mechanic that I've enjoyed is Steamband. In Steamband, on top of having HP, your player character has 'WP' or 'wound points'. And it works very similar to LP except that, in Steamband, once you go unconscious, it's game over -- but, just like in SaGa Frontier, when you take certain critical hits or certain special attacks, you'll lose WP -- and, once your WP hits zero, it's game over, even if you still have HP remaining.

So, I want to take this idea into our monster-collecting JRPG. I want for each of our units to have an 'LP' value which represents their ability to be revived, and I want for it to deplete whenever they get knocked out or from certain, rare, special attacks which may come at great cost to the user but have a chance of depleting LP directly.

We've also toyed around with the idea of having units lose LP when they're attacked while on the ground (ala SaGa Frontier), but what I really want to examine, tonight, is the CONSEQUENCES of losing all of your LP.

So, we need to answer some questions about LP:

1.) How do you restore LP that's been consumed in combat?
2.) What is the consequence, exactly, for losing all of your LP?

That second question is one that we've been waffling on since we began developing our gameplay ideas. In the beginning, we sort of understood that once LP was depleted to 0, that was more-or-less it for that unit; it was dead on a semi-permanent basis. And by 'semi-permanent,' I mean that the player would need to wait some extended amount of time or accomplish some Herculean task in order to bring that unit back from the dead. This way, no unit is permanently dead, which can be extremely frustrating, but that unit is effectively LOST.

That was our original idea for LP. A semi-permanent loss of the unit from the team.

Since then, I've sort of softened, but the question is how soft should we go with this mechanic? How dire should it be? How forgiving should it be? A lot of that ties into how often we expect the player to run out of LP and what sorts of abilities are going to attack LP; we're talking about the sorts of decisions that we expect for the player to make based on LP. Game design.

One thing that I want to re-examine as a part of this puzzle is the idea of the 'deck'. The unit deck.

When a player is at their 'hub' or their 'inn' or their 'rest point' -- wherever they're safe and refreshing their units -- the player can define a 'deck' of ten units to bring with them on their adventure. And from that deck of ten, at any time BETWEEN BATTLES, they can swap units into their 4 man battle team.

So, in battle, you can only use 4 units. One in the ring at a time, but 4 total available in that battle. But, between fights, you can swap units into and out of that 4-man team from a deck of 10 that you've brought with you.

So, at any point in the game, the player might have collected a HUNDRED different units. But they can only bring ten of those units with them into a dungeon. And, of those ten, they can only bring 4 into battle at any given time.

The reason that I think this idea is closely tied to the idea of 'LP,' is that, when a unit is getting low on LP, they can be swapped out of the battle team and replaced with any of the remaining units from the deck.

Another reason that a unit might be swapped out of the battle team is that they're high on 'exhaustion,' which is a mechanic that we've talked about implementing to punish units for taking part in too many battles. Basically, after every battle, a unit's max attributes temporarily go down, until the next time that player 'rests'. So, the more battles you take part in, the weaker your unit is going to become.

The final (?) reason that you'd swap a unit out of your battle team is that you want to approach an encounter with a different strategy that requires another unit.

I'm struck.

If the main two reasons to swap a unit out of the battle team with another unit from the deck is that they're A.) low on LP, or B.) high on exhaustion, we're talking about a situation where the deck may be composed as such:

Battle Team: Unit A, Unit B, Unit C, Unit D
Remaining Deck: Clones of Unit A, B, C, and D, and then a couple spares of the most vital of those units.

That seems sub-ideal. We want for the player to employ a variety of strategies based on the opponent that they're fighting, and I wonder if having these layered mechanics representing exhaustion doesn't only serve to incentivize bringing 'back up units'.

So, I also want to point out that, the player picks their battle team from the deck BEFORE EACH ENCOUNTER. Not 'between encounters,'  but rather during a special phase that takes place directly before an encounter. And, based on which team gets 'initiative,' a player might be able to see what team the enemy has selected before they choose their units.

So, that's one way that we can encourage players to bring a flexible deck with them into a dungeon: if they know what units they're about to fight, they can pick and choose units from their team that are especially apt at fighting those units.

But, the point stands: looking at these mechanisms, maybe we're doing TOO MUCH to discourage the player from using certain units in particular. Like, if you're swapping units just because they're high on exhaustion or low on MP, again, you're really being driven toward this idea of bringing 'spares'.

But that was never really the idea. The idea behind 'exhaustion' and 'LP' was to encourage the player to think carefully about their deck so that they could mix-and-match units from those 10 in a variety of ways. We wanted to disrupt the idea of the deck mostly just containing 'two teams and change,' but that's almost like what we're DRIVING THE PLAYER TOWARD.

How can we solve this problem?

One way would be to actively disallow clones in the team; maybe a limit of one unit-type per deck. But that seems a little heavy-handed, although sensible.

I mean, in Pokemon, who would bring an entire team of Pikachus?

But, in Pokemon, you wouldn't bring an entire team of Pikachus because you want to have some tactical coverage.

So, maybe that's reason enough to have a diverse deck. Maybe we just need to think about the variety of enemies we have in our dungeon.

But even then, if the player can't see what they're about to fight before the actual encounter, they can't make an intelligent decision on what units to bring into that fight if the dungeon has a high variety of enemy types.

In Pokemon, you typically know what sorts of enemies you're going to be fighting in a particular dungeon before you get there. They're all going to conform to two or three different 'types'. So, when you're creating your team, you can choose carefully.

But the difference is that, in Pokemon, you use your entire team in every battle. No matter who you're fighting, you always have access to your entire 'deck'. That being the case, the parallel would be, in our game, if you could always know what your opponent's team is going to be before you pick your units.

And maybe you should, in single-player.

So, what we're really talking about when we're talking about encouraging deck variety is 'counter-picking'. We're talking about counter-picking.

We want for counter-picking to be strong in our game because we don't want for the same strategies to work against every team. We want for the player to have to constantly change up their strategies; think on their toes. Plan in-the-moment. We don't want for them to just create a team that can follow a flow-chart and steamroll a bunch of different opponents.

That's where 'exhaustion' and 'LP' came in, originally: as one more measure to discourage the player from over-relying on a single team. But, yeah, where does that leave the possibility that the player might just stock 'spares' into their deck to account for exhaustion and LP.

One option, which may very well be as or more sensible than limiting the player to 'one of each unit-type per deck' would be to literally only allow the player to CAPTURE one of each unit-type. Maybe capturing additional monsters of that type will power-up your current monster of that type or maybe you just can't catch another one.

Again, in Pokemon, how interesting is it really to farm multiples of the same monster? I've never done it, although I know that some do it for trading purposes or breeding purposes. In general, I feel like you only really WANT one of each type of monster. You don't need to be able to capture multiples.

And, that being the case -- and considering that, in our game, you can easily, when resting / between battles (haven't decided yet) swap out that unit's abilities. Units EQUIP their abilities and they can learn a ton of them and easily equip and unequip them. So, a single unit could effectively be a good fit for multiple different strategies; you don't need to capture two of the same unit to give them slightly different 'builds'.

Although we have discussed this idea of having one piece of 'equipment' which is permanently or semi-permanently bound to the unit, and which may affect character growth.

Just to follow-through, even if you can't capture two of the same unit type, you could still theoretically create a team of 'spares' by finding other units with very similar abilities. That being said, they certainly wouldn't have the same mix of abilities and Unit Dynamics, which would make them much less effective, you would HOPE, at high-level team building. And again, at that point, you're working pretty hard to game the system so that you can bring spares into a dungeon -- and, as long as the dungeon has an effective mix of enemy types, maybe you'd only be shooting yourself in the foot by doing that.

So, let's rule out the possibility that a player might just bring 'spare' units to accommodate the LP and Exhaustion systems.

But here's a second question: do LP and Exhaustion fit the same purpose -- and, if so, do we need them both? Is it interesting to have both? Could we just use 'LP'?

So, for EVERY FIGHT that a unit takes part in, in a single dungeon, they become more 'exhausted,' which means that their overall stats are getting lower.

This is meant to encourage the player to swap units out of their battle team: so that they don't become too exhausted when they end up being necessary.

To answer Sinatra's question, units will EFFECTIVELY be taking more damage as they become more exhausted, because A.) their DEF is being gradually lowered, so they're literally taking more damage, and B.) their max HP is being lowered, so they're taking more damage RELATIVE to how much HP they have.

So it's actually a double-whammy. You are definitely taking more damage -- you are definitely being killed in fewer hits -- as you become more exhausted.

We also have 'LP,' whose function in our game-design is kind of similar -- maybe too similar. Units have a limited number of 'life points,' and, whenever they're KO'd in battle or whenever they're struck by certain, rare abilities or by certain rare critical hits, they lose 1 LP.

Once a unit has zero LP remaining, they cannot be revived (until some criteria is met -- certainly, they cannot be revived while within the dungeon).

So, this is another measure meant to affect how the player chooses which units to bring into battle. As the dungeon wears on, you might find that some of your favorite units are getting low on LP, and so bringing them into the next encounter might be a pretty big risk.

The main difference, right now, between these two mechanics is that exhaustion is a CERTAINTY. Whenever you finish an encounter, all of the units that were in that encounter take a fixed amount of exhaustion.

On the other hand, LP is something that you can STRATEGIZE AROUND, to an extent (working hard to protect it, don't get knocked down), and which is also somewhat random (it might be extremely difficult to completely prevent LP loss from something like an enemy ability which has a very low chance of inflicting direct LP damage). So, compared to exhaustion, LP is much less predictable and much more based on player decision-making during battle.

So, we see that these two concepts serve a SIMILAR PURPOSE but not necessarily the exact same purpose.

We can also consider that there might be some rare or expensive ways to HEAL exhaustion and to HEAL LP in a dungeon, and so you might find that, in a single dungeon, your decision-making might end up being influenced more by exhaustion or LP, depending on circumstance. So, that's kind of a nice layer.

Finally, we have an option to examine: we could have 'LP' restore either entirely or partially after each encounter.

What if, as long as a unit ends the encounter with >0 LP, they gain one LP back?

Or what if LP is entirely restored between encounters.

In that latter option, we totally lose LP as an incentive to include or not include a unit in a particular battle. We can't say, "this guy is low on LP, so let's not bring him into this battle,' because his LP is always being restored between each battle.

But the argument could be made that this purpose is already well met by the 'exhaustion' system.

So, we could look at the decision-making around 'protecting LP' as taking place entirely within the confines a single battle. In that case, we could afford each unit much less LP, for instance.

I really like the idea, now that I've mentioned it, about LP either NECESSARILY BEING PARTIALLY RESTORED or having a CHANCE to be partially restored after every encounter. That adds an awesome risk-reward to bringing low-LP units into battle.

Maybe you WANT to bring a low-LP unit into a battle where you're confident that they won't lose their remaining LP, because that would be a way for them to get some LP back if they survive.

So, in general, the more I think about it, the more interesting both Exhaustion and LP become when you consider that there COULD be ways to restore it, within a dungeon. Not because it makes the game 'softer' or less dire, but because it adds dynamism and depth to the decisions that you're making.

And, for another thing, it removes some of the overlap of the purposes of Exhaustion and LP -- because one might be getting restored and one, in this dungeon, might not be.

Maybe by making Exhaustion and LP less FINAL or FIXED we're actually add tactical depth to the game. Maybe there are some rare, expensive abilities or status changes or treasures to find in the dungeon which CAN restore exhaustion and LP. And, like I mentioned, maybe we could even implement something where units will certainly or with some chance restore LP after each encounter that they take part in.

Or maybe they regain LP or Exhaustion when they DON'T take part in an encounter.

So, we've discussed a lot about game-design, tonight, but we haven't gotten much closer to what was our original goal: deciding how much LP a unit should have, literally. As a number. And I feel like we can't come up with that number until we really nail down some of these OPTIONS that we have about how LP is going to work.

Superking mentions that we could use LP restoration as a REWARD for, say, that battle's 'MVP'. My only problem with this is that, for one, you need to decide which unit is the MVP or what actions are worth rewarding a unit for -- and that seems like an impossible task in a tactical game. Because, every action you would take, ideally, would be one that you've slaved over as the most ideal tactical move.

Just as a loose example, Disgaea 1 on PS2 (and I believe a couple of the later Disgaeas) had a problem where the only way to level up was to kill a unit. This meant that healers had a HUGE problem with leveling up, because, although they were tactically significant to your team -- even necessary -- they weren't engineered to kill any units. So, if the only way to get rewarded is to kill a unit, then we see that healers are never going to level up.

That's my hesitation about rewarding an 'MVP' or rewarding certain types of actions; I feel like it could end up favoring certain unit types over others. Ideally, like I mentioned, every action that you take should have tactically weight whether it be dealing huge damage or just waiting. Doing nothing. We can't write an AI that would be able to tell when the unit or player makes an especially clutch move.

Maybe, after every encounter, one unit from the winning team will CERTAINLY have 1 LP restored, and that unit is picked at random (from the team 4). Every unit would have a 25% chance of getting an LP restored -- and maybe that number goes up if some of the units are already at max LP. Maybe if you put a unit which only has 2 LP remaining onto a team that has all of their LP, then that's a guaranteed way to restore 1 LP to that desperate unit.

Even if we don't come to a conclusion about how harsh or flexible LP and Exhaustion should be, one thing that I do want to take from today's session is that I'm CONFIDENT that neither LP or Exhaustion should be unrestorable. I feel like having an ebb and flow to these mechanics can only make them more interesting. I think that it's important that, compared to HP, for instance, these attributes be much HARDER to restore -- but I think that, seeing them change in BOTH DIRECTIONS is going to add tactical interest to our game. I think that, once the player rights off that LP and Exhaustion are never going to be restored, that's one less thing for them to think about -- yeah, they would have to make decisions around that gradually creep toward death... but I think that you could actually leverage these to make a more interesting risk / reward scenario if you leave the player with the possibility that they could actually recover from these attributes.

And another thing that I kind of want to write OFF is the possibility that LP could be completely restored between matches (the way that HP and MP are). I can see how LP could still work if it was restored completely between encounters, but I just think that it makes much more sense to leave it as something that the player has to deal with on an ongoing basis throughout the dungeon.

So, LP and Exhaustion are the ONLY considerations that a player needs to make regarding the STATE OF THEIR TEAM between encounters. And we know, for sure, that these values are going to become increasingly troublesome to the player as the dungeon wears on.

I think we also want to seriously consider giving the player LP BACK for taking part in battles, which is a stark contrast to Exhaustion, which does the opposite: it penalizes the player for taking a unit into a battle.

At the same time, by taking that unit into the battle, you're risking LOSING LP.

Another option we have (I know, we've got a lot of options and not a lot of certainty about which way to go) is to reward every unit that does NOT take part in battle with 1 LP per battle.

One reason we would do this is to add some certainty to the healing of LP, which would allow us to take LP from the player more freely. We can lower the amount of LP that our units have or take more from them if the player knows that they can restore that LP by doing a thing (leaving that unit out of the next few fights).

And something I want to point out, here, is the VISERCAL nature of battle. The DRAMA of battle.

For instance, I think that it's important that HP and MP be completely restored between battles. This is so that the player understands that these are resources meant to be CONSUMED. We want for players to get to LOW HP. We want for them to spend ALL OF THEIR MP as a part of their battle-to-battle strategy. If the player understands that there are no consequences AFTER THE BATTLE for consuming their resources, they're more likely to play fast and loose with those resources, which makes gameplay more exciting, I think.

So, understand that -- accepting that -- maybe it does make the most sense to expect a player to lose a LOT OF LP in a battle, and, therefore, we need to provide some stable way for them to get it back. It certainly will not be like HP or MP, which is certainly restored after every battle, but maybe there is some tactical consideration that the player can make to restore their LP. Maybe we shouldn't base it around luck at all. Maybe it's more INTERESTING if the player can CERTAINLY restore their LP, somehow, so that they can be more comfortable SPENDING it.

In review, we want for LP (and maybe exhaustion) to ebb and flow between battles, but it's worth noting that it might actually make more sense for LP to ebb and flow MORE DRAMATICALLY on a battle-by-battle basis rather than LESS DRAMATICALLY. Rather than it being a SLOW DECLINE TOWARD DEATH, maybe it should fluctuate enough that units are effectively in-the-game and out-of-the-game relatively freely. So that we have MORE situations where a unit is down to one or two LP and the player is sweating about it. Then, they win the fight and, through some measure, they can consistently restore that LP and then do it again.

So, the question that we're going to answer, first of all, on Monday, is this: how does the player restore LP and Exhaustion. That's what we gotta know. Tonight, we've come up with a bunch of different ideas about how to do it. On Monday, let's talk more about it and nail it down. How often does it happen? How much control does the player have over it?


08/12/19

Last Thursday we were discussing 'LP' and 'Exhaustion' and their relationship to one another. We need to figure out how LP is going to be moving back and forth, in our game, so that we can decide how much LP we ened to give a baseline unit. Approximately how much LP is the right amount of LP to encourage our players to make the sorts of decisions that we want for them to be making?

We can't answer that question until we really understand how LP is going to be used. We've got some loose ideas, but it's about time that we started to nail things down.

Here's a thought that I think is really significant: whenever a unit survives an encounter, they should get 1 LP back. This makes sense for two primary reasons: one is that, when you can reliably get LP back, you can spend it a little bit more freely. Which is what we want: we want for players to take risks, we want for them to expend their resources. We don't want for them to hoard their LP.

Another reason that it makes sense is that -- it's a similar idea. It's that, if you get 1 LP back at the end of every match that you survive, that means that you can actually DIE ONCE PER MATCH and still exit the match with the same amount of LP that you went into it with. Again, this encourages the players to play a little bit faster and looser with their HP. It means that a unit can get KO'd once per match without a hugely significant consequence. But after that, you start getting into territory where your deaths are even riskier -- and, if you're in a fight trying to RECOVER LP, then you can't die at all in that encounter. I think it adds some interesting tactical considerations to how you expend your HP in battle.

I'm quite happy with that. And what it means, in a sense, is that players are effectively AFFORDED one KO per battle, and any more KOs than that becomes a much bigger deal. So, we can use that information, along with how many battles we want for a unit to be able to survive depending on how defensively the player is playing, to figure out a good baseline value for LP.

Also, on this same note, I feel like it might be cool to have an ebb to 'exhaustion' as well, and maybe it'd be something like this: for every encounter that you're a part of, you gain 5% exhaustion, but for every time that your unit is left out of two encounters in a row, they gain back 10% exhaustion. That way, we don't have a direct correlation between LP and Exhaustion. If we gave exhaustion back after every encounter that a unit didn't take part in, we'd see situations where every encounter that you joined to GAIN LP would result in more EXHAUSTION, and every time that you rested to gain back EXHAUSTION, you wouldn't gain back LP -- so we have a sort of teeter-totter that I'd like to avoid to make things more dramatic.

So, maybe only reward the unit with exhaustion restoration after two back-to-back skipped fights. That way, we have this interesting investment where a unit might be left out of ONE fight, but they would be hugely beneficial in the NEXT fight -- so the player has to decide whether they want to bring that unit in and sacrifice the exhaustion recovery or risk trying to do the fight without that unit.

What if, by leaving the unit out of three consecutive fights -- what if, the more fights you leave the unit of, the more reward they get in terms of Exhaustion restoration?

What if we say that every fight that a unit takes part in, they gain 5% exhaustion.

If they're left out of a single fight, maybe they gain back 3% exhaustion.

If they're left out of two fights, maybe they gain back 8% exhaustion.

If they're left out of three fights, maybe they gain back 15% exhaustion.

That way, the only way to gain back 3 fights worth of exhaustion is to skip three consecutive fights. And if you skip two fights after doing one fight, you've fully recovered. But if you only skip one fight, you don't fully recover your exhaustion.

That being said, is 5% the right amount of exhaustion -- supposing that, at 100% exhaustion, your units are dead. Let's say that 5% exhaustion means that your units have lost 5% of their max attributes. So, at 100% exhaustion, all of your stats would be zero.

If you take part in four fights in a row, you've lost 20% of your max stats. Is that a harsh-enough penalty?

But it seems like 10% of your max stats per fight is way too harsh.

10% is way too harsh, because we don't want for exhaustion to be the exclusive deciding factor as to who a player brings into battle. We just want for it to be an influencing factor.

The MAIN FACTOR OF WHO A PLAYER BRINGS INTO BATTLE SHOULD BE WHATEVER TEAM THEY THINK IS THE BEST TACTICAL FIT FOR TAKING ON THE ENEMY TEAM, supposing that they rolled initiative and therefore have an idea of what units are on the enemy team. That should be the MAIN deciding factor.

Exhaustion management and LP should be secondary factors that tempt the player or maybe even, at some point, FORCE the player to strategize on-the-fly with a sub-ideal team.

Let's just go with 'every encounter that a unit takes part in adds 5% to their exhaustion'. And then, if they're left out of two or more fights, they gain back 7% exhaustion per fight they're left out of.

I'm happy with those numbers for exhaustion. So let's wrap up LP and get back on track with designing our baseline unit.

So, like we mentioned above: a unit is effectively AFFORDED one LP per encounter. Because, if they're alive at the end of that encounter, they get that LP back. So, that brings up some interesting ideas about resurrection, actually:

We haven't really settled on how our game's 'inventory' or 'item management' is going to work. So far, it hasn't really been super core to our design. We've sort of assumed that any HP restoration would be done by some kind of 'healer' unit. But with teams of 4, that means that every team needs at least 1 healer -- and, looking at LP the way that we've been looking at it, it seems like resurrection is EXTREMELY important. Because, if your unit is knocked down, you want for that unit to be revived before the end of the encounter so that they can get their LP back.

Maybe we can give them LP back even if they're knocked down at the end of the fight? I don't really see how that could do harm.

But back to this thought train about resurrection. In a game as tactically dense as we hope for our game to be, it seems, suddenly, that the function of the healer becomes incredibly significant. Like, if a healer gets knocked down, who's going to revive them? And if the healer can't be revived, that may very well be game, right?

This problem is addressed in other JRPGs by allowing every unit to have access to 'items,' but I've always been suspicious of this design because I feel like it sometimes diminishes the significance of having a 'healer' unit. Like, what purpose does a healer really serve when every unit has access to healing items which are sometimes very effective at healing?

Traditionally, healers have better access to group-healing and they also have unlimited use of what would normally consume items for as long as the player has a way to restore their MP. But, it's worth mentioning that, in JRPGs where the player is given way too much money, it's sometimes trivial to have huge storage of healing items and then you can get away with not necessarily having a healer on your team.

So, I don't see the harm in giving LP back to every unit that takes part in a battle even IF they get knocked down -- because there are a lot of ways to lose LP. You can take a crit from certain abilities and lose an LP, and that sucks. If you do get revived and you get knocked down AGAIN, you lose LP, and that sucks. If a unit is attacked while they're already knocked down, we've talked about them losing LP for that, too. So, holding onto your LP isn't going to be easy, and so, if you get knocked down before a fight is over, and you're never revived, I don't think that we necessarily need to punish the player for that; I feel like, if we give that unit an LP back, anyway, it only serves to encourage the player to play until their units are knocked out, which is what we want.

In a game where every unit has abilities from three different classes, it stands to reason that abilities which recover HP or even revive units might not be extremely rare. Also, like I mentioned above, I'm not against having some kind of 'inventory' in our game, including items which may revive units. It's just that we haven't discussed it, much. But it seems to me, after this discussion, that it might actually be pretty important to have some tertiary way for units to be revived, perhaps at some great cost (consumable item that the player has limited access to).

WodoWiesel puts forth a good question: do we want to reward our players for playing LOOSELY (intuitively) or are there going to be mechanics in play that makes using up all of your HP (and other resources) a more 'effective' course of action.

The answer is both -- or that's the idea. As a gamer, myself, I have a habit of playing EXTREMELY CONSERVATIVELY, and people that know me know that about me. And in many games, I find that's the IDEAL WAY TO PLAY if you WANT TO WIN. But it's often not the MOST FUN or EXCITING way to play -- but it is the most effective way to win.

After examining the mechanics of many RPGs and other games over the past few years, it strikes me that there are certain design tropes which I think OVER-REWARD CONSERVATIVE PLAY, and one of those tropes is whenever you have resources which GRADUALLY DEPLETE and the player isn't given a clear understanding of WHEN those resources are going to be REPLENISHED. When a player has resources that are DEPLETING and they don't KNOW when they're going to be replenished, it encourages the player to always be FRUGAL with their resources. Even when an enemy could be dispatched more QUICKLY or in a more FUN WAY, or even when the player has to play sort of CHEESY in order to conserve their resources, the player can feel like they HAVE to conserve their resources, because THEY DON'T KNOW if they're going to be fighting a BOSS soon, or if the next 'rest point' is going to be a hundred miles away.

And it often turns out that, when the player DOES find that 'rest point,' it's actually VERY NEARBY. So why was the player playing so conservatively? They got to the rest point with nearly all of their resources intact -- and it's because they don't KNOW where that rest point, and they don't want to die / lose. There are parts in that same game where the rest points are MUCH FURTHER APART, forcing the player to play more conservatively -- but the player never knows if they're in one of those parts.

So, what I've found, and what I'm trying to incorporate into this game, is that, if the game designers are CLEAR with what resources the player has to SPEND, then the player can be more EFFECTIVE and more EFFICIENT with their TIME, if nothing else -- by spending those resources to dispatch enemies. By being clear with the player about when their resources are going to be replenished, the player becomes REWARDED for spending those resources -- because, just by the very nature of JRPG resource economics, the player is supposed to rewarded for spending their resources:

You spend some MP, you get more damage.

You leave a unit on the field to attack, sacrificing some of it's HP when it's attacked in return, you deal good damage to the enemy.

Whenever you SPEND a resource, you should be REWARDED for it -- that seems obvious.

But for as obvious as that seems, TONS of JRPGs and other games get this wrong. When you have some amount of resources and you have a bunch of ways to spend those resources, but you don't know when you're going to get those resources back, you're often PUNISHED for using your resources -- because, when you ACTUALLY NEED THEM, you won't have them. You spent them already. And on what? Something that you DIDN'T REALLY NEED.

Yes, I could've beaten that opponent by just turtling and waiting and biding my time, looking for an opening, and exploiting it. I wanted to kill the enemy faster. I wanted to be more conservative with my TIME than my resources. I wanted to be more aggressive -- but I was punished for it.

So, if we tell the player that all of their resources (MP, HP) are going to be completely restored at the end of the battle. And if we tell them that they're going to get 1 LP back at the end of the battle -- NOW that player is LIBERATED to spend ALL of their MP and spend ALL of their HP and even to DIE once in battle, because they know that they're getting all of that back. They know EXACTLY when they're getting all of that back, so it makes NO SENSE to save it.

To answer Wodo's question, finally, the answer is both: we want to reward the player for taking risks, because they understand and can better manage those risks when they know how much resources they can really spend.

In some JRPGs, you know how much resources you HAVE, but you don't really know how much you can spend. In our game, you know that you can spend it ALL, and that means that the player can start looking at strategies like:

I want to end this fight SOONER so that I can do more fights per hour.

I want to kill this enemy NOW before it gets a lucky crit on me.

I want to kill this enemy NOW before I find out that it has some killer ability.

I want to kill this enemy now before my status change timer ticks down and I continue taking poison damage.

When you tell the player, "here's the resources you can spend," it liberates not only them as a player but it liberates US as game-designers to start hitting them with more risky situations or situations which encourage them to take risks.

Consider the classical status change, "poison". In most JRPGs, it's a very minor nuisance -- but THEORETICALLY, it could be so much more. The idea of poison is that you're LOSING HP FOR EVERY TURN THAT YOU TAKE. So why is it that, in most JRPGs, there isn't this pressure to end fights SOONER? Doesn't it make sense that a status change like poison would make the player want to go for riskier plays and to expend more resources to avoid taking more turns of damage from poison.

And the answer is that, in most JRPGs where poison is a factor, they can't make poison that scary for all of the reasons that I mentioned above: because of their game design, the player is expected to have to play conservatively. They don't know how long the dungeon is. They don't know when the next save point is going to be. They don't know if there's going to be a boss before the next time they can rest. So the player has to play very slow and careful with their resources or risk dying or losing -- and for that reason, the game devs sort of had to nerf things like poison to the point that they become virtually inconsequential.

Because our players can burn ALL of their resources in a single battle, that frees US UP as game-devs to create more dramatic CONSEQUENCES FOR DECISIONS, which I believe correlates to FUN in game design, and it means that our players can have these encounters which are faster-paced, more loose, and where that may very also be the most EFFECTIVE way to play.

So, with that discussion out of the way, let's look at how much LP the average, baseline unit really needs.

We know that they get 1 LP back for every fight.

We know that a unit can lose LP in a variety of ways.

Let's imagine a scenario where a unit has 5 max LP and decide, WITH THE POWER OF IMAGINATION, if that's enough LP -- or too much.

If you have 5 LP and you die TWICE in the first encounter of a dungeon -- or you die once and you lose LP because you took damage on the ground, or you got hit by a rare ability that stole LP -- now you have 3 -- but, because you took part in the fight, you got 1 LP back. So you actually end the fight with 4 LP.

In the next fight, you don't get knocked down at all -- BECAUSE the player is being conservative with that unit, in particular, in the hopes that they could fully recover their LP. After that fight, you now have 5 LP again -- your max.

In the next fight, you die once, and that's it, so your LP is recovered and you end the fight with 5 LP.

The next fight is an extreme case where you die twice and lose LP to some other situation, so you have 2 LP but then the fight ends and you get 1 LP back and now you have 3.

It seems to me, based on these hypotheticals, that a player can reasonably manage LP -- they can bring a unit with low LP into a fight, play ultra-conservatively WITH THAT UNIT and have a very good chance of breaking even or gaining net LP by the end of the fight.

So, 5 seems like kind of a lot of LP -- but let's look, then, at a SINGLE ENCOUNTER, like a boss fight or a very bad-luck situation, where a unit might have all of their LP consumed in a single fight.

Like, if your unit has 5 baseline LP, and you end up losing 2 in a single fight, so now you have 4 LP for your next encounter -- that's kind of scary, because that means that, if you die twice and take two 'crits' or otherwise lose LP in a less common way, that unit cannot be revived at least for the course of that dungeon if not beyond.

So, I feel like '5' is a pretty good balance for baseline LP, if leaning somewhat conservative. But I think that '4' is a slightly less good balance because I feel like it leans kinda risky. So, I'd say that 4-5 is a pretty healthy, normal amount of LP. And maybe glass-cannon units could have 3-4 max and tanks could have 6-8 max.

Before we move on to 3rd Strike, I want to go on a brief tangent about an idea that I had this morning.

When we talk about exhaustion and LP, we've been doing a lot of talking about SINGLEPLAYER content. We're talking about LONG-TERM SURVIVABILITY IN A DUNGEON.

But we're not going to be in a singleplayer position for quite some time. Just like Pokemon is a mix of a single-player experience and a PVP experience -- and just like some 'card games' have JRPGs associated with them where you can play a single-player campaign against AI opponents but the game really shines against other human beings -- our game is going to have a PVP component alongside its single-player campaign, and, for several reasons, I've more-or-less commited to focusing on multiplayer competition as the primary focus of the game.

That all being said, the question comes up as to how we're going to incorporate things like exhaustion and LP into the multiplayer meta.

Up to this point, I haven't really considered it, but it struck me that our game design might actually favor an interesting sort of meta or competitive ruleset:

What if the primary mode of competitive play is NOT a single match but rather to play until all of the 10 units in one of the decks is KO'd. So, a single competitive match might have as many as 5 or so individual battles.

So, that being said, LP could play more of a role, as could exhaustion, even in a multiplayer environment.

I feel like, in that situation, Exhaustion either becomes a NON-FACTOR or we need to ramp it up to 10%. I feel like, in multiplayer, Exhaustion would need to be a non-factor.

So, I'm pretty satisfied that we have a good baseline unit to start doing tests with. Let's look at it.

HP: 60
LP: 5
MP: 50
ATK: 10
DEF: 10
SKL: 10
PRY: 10

Now that we have a baseline unit sort of cut out, I guess it means that it's time for us to start going back to creating some example test classes to get a mock-up battle going.

We're going to need quite a few classes with quite a few abilities. I think that it more-or-less makes sense to stick with RPG tropes for classes or Pokemon monsters. We're going to be crossing that bridge on Wednesday, and it stands to be quite a mess. We've been laying as much groundwork as he we can to minimize how much of a mess that's going to be, but I can't help but think that we're starting to get into a position where, once we start designing units -- even for this first, basic mock-up -- we're talking about some very time-consuming work as we consider many aspects of our game's design.

But that's fine, as long as we can get a test-battle running. Once we get the test battle running, we can start outsourcing unit creation as well as taking individual streams to look at individual units, and so-on-and-so-forth. So, actually, we're on an interesting stretch right now where we need to create just a small handful of test units to get a test battle going -- and then, although the following work will be ultra TIME-CONSUMING, it may actually be more interesting and bring a little bit of life back into this series.


08/14/19:

So, after weeks of examining our mechanics and our stats and levels and parameters, it's finally time to return to creating units, classes, and abilities. I expect that this will be where we'll be spending the bulk of our time INDEFINITELY until we have the game that we want to have. In other words, we're getting into the meat.

I can already tell that we're going to be wallowing in this for a while; it's going to be tedious, but it also affords us an opportunity to continue to think about game-design and the decision-making that our players are going to be making. How can we make it as interesting as possible? How can we make these units as fun as possible to use.

Before we start looking at ABILITIES, it probably makes sense to start thinking about what sorts of ROLES we want for our units to play in battle. Let's lay some groundwork for how battles are going to play out, and we can then think about WHY a player might want to swap ONE UNIT for ANOTHER UNIT. When we're talking about 'roles,' I'd say that's what we're talking about: what is the reason that a player switches one unit for another unit.

That's the question at the core of party-building in a game like this.

1.) Each battle party consists of 4 units.
2.) Only one unit can be 'in the ring' at a time. Swapping units into and out of the ring incurs a great cost, and the unit that is left in the ring at the end of the turn is vulnerable to attack.

What do these simple rules really mean for the player?

*) The player doesn't WANT to swap, tactically speaking. The IDEAL UNIT, as far as the PLAYER IS CONCERNED -- the unit to end all the units, the unit that would break our game -- is one that can do EVERYTHING that needs to get done in a single battle, with enough HP to be able to survive the course of many turns being left in the ring.

In other words, SWAPPING UNITS is a sacrifice that the player must make for some greater good, because they don't want to swap; that has a cost that they'd rather spend on using abilities.

We can't let a single unit do everything -- or maybe we can, because we have to consider our other rule: the unit that is left in the ring is incurring damage. He's vulnerable. So that's another incentive to swap the unit out -- to protect its HP, to protect it from dying.

So, in that sense, outside of TACTICALLY SWITCHING UNITS TO ACCOMPLISH A CERTAIN OBJECTIVE OR USE A CERTAIN ABILITY, there's also the incentive to switch units because the unit in the ring is gradually losing HP.

So, basically, we have two PRIMARY INCENTIVES to pull a unit out of the ring and replace them with another unit. One is because you WANT TO USE AN ABILITY THAT ANOTHER UNIT HAS. The other reason is because you DON'T WANT FOR THE UNIT CURRENTLY IN THE RING TO TAKE DAMAGE ON THE ENEMY'S TURN.

Well, let's examine the VIABILITY of traditional JRPG roles in the context of our game's particular mechanics. Do they make sense in our game?

Let's talk about 'The Warrior'. The warrior has high base ATK power, often times pretty average defense. So, in our game, the warrior would have damage-centric abilities with pretty much no MP cost; he can use them indefinitely. Okay. Seems simple enough, seems sensible. I guess you'd want to swap this unit in to deal direct HP damage, with little cost, and, because their defense is average, it wouldn't be the end of the world to leave them in the ring for a couple of turns.

'The Mage' is a unit that has MP and so has a limited use of their abilities, and they need to budget the way that they use their abilities. For that reason, those abilities might be MORE DAMAGING than what the warrior has access to -- but, if MP is completely expended, the mage is pretty much worthless. Also, the mage has below-average HP and DEF, which means that you don't want to leave it in the ring. So, right away, a question of viability comes up:

What is the real value of a traditional 'mage' or 'clothy' when, in order to use their abilities at low-risk, you need to swap them IN and swap them OUT in a single turn. That really limits the amount of AP that the player has to spend, on that turn, on using abilities.

So, these abilities, which also have a limited use based on MP, have to be really godlike, right? Because the player is making some kind of large sacrifice to use them:

A.) leaving the clothy, with its low DEF and HP, in the ring between turns,
B.) expending 6 / 10 AP per turn just swapping units around to have access to this clothy's abilities.

That sounds kind of sensible, as long as the clothy's abilities are really effective -- but it also brings up what could amount to a pretty interesting tactical gameplay element. Basically, 'Warriors' and other non-MP-centric characters will see their AP COST go up based on how 'powerful' the ability that they use is.

What's cool about clothy's is that, because the player might be expected to be low on AP when they want to use their clothy, or to reward the player for taking the risk of leaving the clothy in the ring between turns -- it would make sense for their abilities to have a RELATIVELY LOW AP COST. Because they have this 'MP' mechanic which means that they need to be very careful of how many of what ability they use in a single battle lest they run out of MP and become very limited in their viability.

So, in other words, you have these units which could be looked at as almost being OUTSIDE of the AP system, but rather they work on their own resource of MP which lasts for an entire battle. So, rather than budgeting AP as much as other 'roles' would need to, per turn, they budget their MP PER BATTLE.

So, for the mage, we're talking about two tactical paradigms:

1.) Swap unit out, swap mage in, use a very powerful ability (whether it be direct HP damage to a single unit, HP damage to a group, or some debilitating status change), and then swap the mage out for somebody else, again. So, a turn where only one or two abilities is used. A turn with fewer abilities being used but those abilities can be devasting.

2.) Mage hits hard a couple times, is left IN THE RING. Is NEARLY KILLED BY THE OPPONENT ON THEIR TURN, and then hits really hard on the following turn one or two times before being swapped out -- or three or four times before being left IN THE RING to be sacrificed, basically.

So, before we talk about healers, let's talk about the viability of giving abilities which use 'MP' to NON-MAGE CLASSES. What does it mean for a warrior or a tank or somebody else with decent HP and DEF to have MP.

Well, it seems to me that the meaning of that design would be to have an 'ace in the hole.' Because warriors can do decent damage and fulfill their role, in general, without using MP -- that's sort of the point. But by giving them a couple of very powerful abilities which use MP, or giving them abilities from a secondary or tertiary class which use MP and which defy the 'warrior role,' a Warrior can temporarily by extra flexibility in combat by using MP for one or two turns until their relatively limited MP store runs dry. Or they can suddenly do a huge amount of damage at the cost of MP, and then it's dry.

So, you can give MP to any role, but it sort of has a different meaning when you consider how that unit is going to be swapped into and out of battle.

If a unit has low HP and DEF, they NEED MP to be able to be effective, because, with all of the ring-swapping that a player has to do in order to protect that unit, there isn't a whole lot of AP to go around in terms of actually using abilities. So, units with low HP and DEF need to have abilities with low AP cost and high MP cost. That way, they can still use abilities, but not indefinitely. They have to be budgeted over the course of the battle.

If a unit has average to high HP and DEF, MP is used to give them an 'ace in the hole,' or abilities that they can rarely use which may give them particular advantages on that turn. Having MP might make them more of a threat in terms of the damage they COULD CHOOSE TO DO on a particular turn (but then never again for the rest of the fight), or it could offset their ROLE so that the player can save AP because they don't need to swap in a unit OF THAT ROLE. For instance, a warrior could have a HEALING ABILITY which costs MP. Because the warrior has very limited MP, they can only use it once or twice per battle -- but that might be really clutch when they don't have the AP resources to swap in a healer on that turn, or the healer is low on MP, or whatever. Basically, having MP could be looked at as a way to give a unit which normally conforms to their PRIMARY ROLE a window into their SECONDARY or TERTIARY ROLES.

So, let's talk about 'healers'. A healer is a clothy, most of the time, in traditional RPGs. In our game, that would mean that they have low HP, low DEF, and high MP.

The player should be inclined to PROTECT their healer, because having the healer ALIVE supports the LONGEVITY of the team. The healer keeps the team alive.

So, what does this mean for the tactics surrounding healers in our game, working with the mechanics that we're working with?

For one thing, I immediately see a challenge: if, because of the healer's low HP and DEF, you need to swap them IN, use one ability, and then swap them OUT -- and that's an entire turn -- I can see how it would be very difficult to 'make progress' on that turn. How do you not end up getting 'stuck' in a defensive position?

The enemy team attacks your units, reducing their HP.
The entire ally turn is spent on the healer restoring that HP.
The next enemy turn, they just attack your units again, reducing their HP.

Well, one solution I can see right away is to give healers a way to restore MORE HP ON THAT TURN that the enemy can DEAL on a single turn. If a healer can heal TWO TURNS WORTH OF DAMAGE in a single ability, then we have ONE TURN where we can be aggressive:

The enemy team attacks your units, reducing their HP to 2/3.
The ally team attacks the enemy units.
The enemy team attacks your units, reducing their HP to 1/3.
The ally team swaps in a healer, healing ally units by 2/3.

So, in other words, it seems like what we're really looking at may be one of two things:

1.) The unit that we have in the ring, doing damage, is REALLY TANKY. Maybe it has some kind of buff that's raising its DEF temporarily. Maybe it's just got a ton of DEF and HP, but can't inflict that much damage, aggressively. So, that unit can survive multiple turns, and therefore we can swap in a healer every other turn to heal that single unit for a large amount of HP.

2.) We continually swap our aggressive unit in the ring so that none of them in particular takes dire damage. Then, we swap in a healer which can heal our entire team at once.

Those are the two primary situations I see which involve the healer establishing the team's longevity through direct HP healing alone.

So, abilities which restore the HP of a single unit can get a wounded unit back into the ring. If that unit is very tanky, the healer and that tank could have a relationship.

Abilities which restore the HP of multiple units can encourage a strategy where aggressive units take turns taking damage and then the healer heals all of them.

So, it seems to me that a lot of the quintessential RPG 'roles' are fairly applicable within our game's mechanics with a bit of tuning especially regarding the relationship between AP and MP.

But, one of our game's core mechanics is that every unit has three CLASSES which they draw abilities from. So how is that going to impact these roles? How is that going to impact the way that we design units? How is that going to impact the way that the player USES their units?

Well, it seems to me that ONE situation might be to have ALL THREE CLASSES DIRECTLY SUPPORT THE SAME ROLE. For instance, we could have one healer 'class' which specializes in healing one unit at a time, and we could have another healer 'class' which specializes in healing GROUPS, and we could have one more healer class which specializes in, I don't know, reviving units or maybe even restoring MP or restoring LP, even. One unit could have all of these classes at once, and that would make them a unit highly specialized to HEAL and flexible in multiple teams where a healer may need to focus on healing ONE UNIT on one team, and MULTIPLE UNITS on another team -- or maybe they're just more flexible insofar as healing HP because, over the course of a single fight, they could very effectively heal a single unit or multiple units.

So, that's one example of how we can look at our 'tri-class' system. A highly specialized unit with three classes that support a functionally similar 'role'.

Another situation is what we mentioned above regarding warriors and tanks: a single unit could have a class which specializes in doing light damage for light AP use, and a class which can, for instance, heal a single unit, and a class which can buff itself or whatever.

If we give that unit a relatively small store of MP, we see that its primary role as an AP-centric attacker is what comes through the most, but the unit has some added flexibility from these other two classes which require MP -- so this unit doesn't have unlimited access to their other two classes -- but that flexibility might be a huge advantage.

Another situation is one where we have a unit with three classes which might afford it some good flexibility, but none of those classes are especially geared toward using MP. So, this unit is, in general, very flexible without the limitation of MP. And so these three classes might need to be balanced against each other in such a way that the 'flexibility' becomes more situational, in some way, or the three classes, on their own, are just not as applicable as some other classes. A unit which may be more flexible, may be useful in a variety of situations, but those situations aren't bread-and-butter situations.

So, all of these examples rely on one hypothesis or one design philosophy which, up to this point, I haven't been fully committed to. Let's talk about it:

INTRA-CLASS FLEXIBILITY

It seems to make sense, to me, for individual classes to be HIGHLY SPECIALIZED TO A PARTICULAR TASK -- because, in a game where every unit can draw abilities from three different classes, you would expect for that unit's flexibility and strategy to be based around the options they have AS THE RESULT OF THOSE THREE CLASSES.

If a single CLASS has too much flexibility or can do too many DIFFERENT things, you can imagine a unit with three of these classes being able to do a TON of different things such that we don't need other classes or roles or units as much. Swapping becomes less important because this one unit can handle a wide variety of tasks.

So, how much flexibility is the right amount of flexibility WITHIN A SINGLE CLASS.

If we restrict their flexibility TOO MUCH, what is really the difference between a CLASS and an ABILITY. If one class's specialty is just dealing direct HP damage for an AP cost, then how is that not an ability? That's an ability: deal HP damage for an AP cost. How many abilities can we really fit into this class when they all conform to that pattern?

*.) An ability that does a little damage for a little AP.
*.) An ability that does decent damage for decent AP.
so on and so on, but that's not very many abilities. How many abilities do we want for each of these classes to have -- and if it's a FEW, then how many different TASKS or ROLES do these classes need to support.

One answer to this question would be that we could have SOME CLASSES which are HIGHLY SPECIALIZED and whose abilities are all very much the SAME, and we can have OTHER CLASSES which have more INTRA-CLASS FLEXIBILITY insofar as their abilities are concerned, but those abilities might be balanced AGAINST THAT FLEXIBILITY -- maybe they're just not as good.

One thing that we haven't really discussed regarding classes is how many classes we expect to have in our game, and that's something that I'm not only TOTALLY open to but which I expect will be a somewhat high number.

If we want to have a wide variety of interesting units (monsters, Pokemon, whatever) and each one draws its abilities from 3 different classes, I don't think that having FOUR CLASSES is going to cut the mustard. I don't think we want to go, "Warrior, Mage, Healer, Tank." I don't think that we could get that many interesting combinations from those four classes.

If we had TEN classes, I'm not sure that it'd be enough.

So, do we want MORE CLASSES or do we want LESS CLASSES but those classes are more flexible.

That's an interesting question that we have to discuss.

What are the ramifications of including a greater VARIETY of abilities in a single class.

We have to establish a couple of things, here:

1.) Although each unit has three classes, they can only access the most BREAD-AND-BUTTER abilities from ONE of those classes. And, from their third class, they can only access the most tangential of abilities. Each unit has three classes, but one is PRIMARY, one is SECONDARY, and one is TERTIARY -- and that WILL HAVE AN IMPACT on the role they play in battle.

2.) Although a unit can learn abilities from all three of their classes, there IS A LIMIT TO HOW MANY ABILITIES A UNIT CAN TAKE INTO BATTLE AT ONE TIME. In our game, abilities are 'learned' and then they're 'equipped,' and a unit has a limited number of slots to equip their abilities. I believe that each of their three classes has their own limit. It's not a shared limit.

What does that mean when we make each of those classes MORE TACTICALLY FLEXIBLE INDIVIDUALLY.

One apparent advantage is that it makes the process of learning and equipping abilities MORE FUN. If we have MORE VARIED ABILITIES PER CLASS, and the player can choose which of those abilities to LEARN and EQUIP, it makes EACH UNIT MUCH MORE CUSTOMIZABLE. And that's fun. I love customizing my units in any game. I love customizing anything in any game, ESPECIALLY if there's a tactical ramification.

But here's the risk. Here's the downside of that advantage: we're not Final Fantasy. We don't have 8 party members to choose from. We have potentially more than 60 different party members to choose from. If we give the player too much freedom over customizing individual monsters, they have less incentive to try other monsters.

In Pokemon, they have this very rigid and tactically SHALLOW 'type' system which is meant to encourage the player to swap units regularly. Also, Pokemon are not very customizable at all; they're very rigid -- but that supports the fact that there's SO MANY OF THEM. You don't customize INDIVIDUAL units as much as you customize the TEAM by bringing units into and out of it.

It's a card game. You don't customize the CARDS. You customize the DECK.

Now, in our game, we're talking about inviting the player or even REQUIRING the player to CUSTOMIZE THE CARDS. And we want for that to be FUN and INTERESTING, but we don't want for that to come at the cost of the experience of CUSTOMIZING THE DECK.

We have to strike a balance between how deep it is to customize the individual CARDS and how interesting it is to customize the DECK. Because if you have too much control over how the CARDS behave, there's much less interest in swapping in OTHER CARDS. If you limit how much you can alter the way that the cards behave, now it becomes more exciting to bring in OTHER cards.

In other words, if we make individual cards too flexible, they make the need for having OTHER CARDS obsolete. And maybe that's not a bad thing.

So, maybe, when we're talking about how flexible we want for individual monsters to be -- and, by extension, how flexible we want individual CLASSES to be -- what we're really talking about is HOW MANY DIFFERENT MONSTERS DO WE WANT IN OUR GAME.

More monsters means that they need to be less flexible.

Less monsters means that they can be more flexible.

What if -- and I'm just spitballing, here -- what if each class only had 3 abilities -- a primary ability, a secondary ability, and a tertiary ability. Or what if each class only had 6 abilities -- two primaries, two secondaries, and two tertiaries.

It's kind of exciting to me to LIMIT THE NUMBER OF ABILITIES THAT A CLASS HAS. That puts you into a position, as a designer, where, if your class is fixated on ONE TASK, you have more options for going about that one task (more flexibility regarding a single task).

If your class has support for MULTIPLE TASKS, it MUST INHERENTLY HAVE FEWER WAYS TO GO ABOUT EACH OF THOSE TASKS, because we're working with a limited number of abilities per class.

That answers the question I had, earlier, about whether we could have two classes which deal with the same task -- but one handles it more exclusively and one handles it along with other tasks but not as effectively. Immediately, once you limit how many abilities a class can have, that answer becomes 'yes'. You can have two classes which tackle the same task, but one might be able to do other things as WELL -- it's just that it becomes a jack-of-all-trades-and-a-master-of-none.

Wodo's looking WAY AHEAD at UI design. I always imagined that we'd be working with a traditional JRPG layout where the first phase of menus is:

Unit Ability
Item
Leader Ability

When you open 'Unit Ability,' you get access to how- lemme backspace through this.

I think that Wodo misunderstands.

We're not talking about having units with 4 abilities, max.

We're talking about having classes with 6 abilities, max. And the player can only equip 3 of them from that class. And they also have abilities from two other classes.

Wodo's not talking about classes; he's talking about the max number of abilities that the player can bring into battle.

We're talking about a game which is going to have a text-based UI for a part of the alpha testing, but our end-game is to have a graphical version for Pygame and for browser. We may even skip Pygame, to be honest.

While addressing that concern, it struck me that, if a class only has 6 different abilities, it really diminishes the importance of having an 'equip limit' for that class. We also know that each of those 6 abilities can have an ARBITRARY NUMBER OF VARIATIONS.

Maybe, before we can really be done talking about what it MEANS TO DESIGN A CLASS IN OUR GAME, we need to look at how abilities are LEARNED, EQUIPPED, etc.

So, we touched on this before, but lemme repeat it: the more interesting abilities that a single class has, the more interesting is to choose which of those abilities to equip.

We have this mechanic in our game where a player is asked to LEARN ABILITIES FROM THEIR CLASS and then EQUIP THOSE ABILITIES, and there's a limited number of slots for equipping abilities which they player can RAISE. They can unlock more slots to equip more abilities.

Let's also consider that, going into a dungeon or into a PVP battle, the player has a deck of ten monsters from which they must choose four to bring into battle.

If we limit too much how individually capable these monsters are, we really limit the amount of variety and maybe depth of tactics that we can see in a single battle. In other words, let's say, for the sake of argument, that each monster comes into battle with access to 6 abilities. And, at this rate, even that is looking kind of generous, which may be evidence that we're on the wrong path.

Let's say that they have two abilities from each of their classes. You've got 4 units. I wonder if that's just not enough DYNAMISM for that single battle, which includes 8 total monsters.

I mean, keep in mind that each unit has a 'Unit Dynamic' which applies special rules to the fight just by virtue of that unit being there. So, as you face off against different TEAMS, your circumstances are going to necessarily be somewhat different.

20 abilities total per team seems like it could be a good compromise between INTRA-BATTLE FLEXIBILITY or INTRA-BATTLE VARIETY and the profound difference that you can see from playing different parties.

We've been struggling with this essential riddle that's inherent to an RPG of this type: the microscopic DYNAMISM and VARIETY and DEPTH, vs the MACROSCOPIC dynamism and variety and depth. How much variety do you really want to see in a single battle where you're going to be having tons of battles, and the whole heart of the gameplay is based around choosing what you bring into those battles, tactically. Like, how much strategy takes place BEFORE-HAND and how much strategy takes place IN the battle. How carefully do you want to PICK YOUR UNITS vs how carefully do you want to play your turn. How much depth do you want to have in designing YOUR DECK vs how much depth do you want to have on an individual TURN.

By the very nature of a CARD GAME, you can only play the hand that you're dealt. Or, in a CCG, you can only play the cards that you've drawn. There IS DEPTH IN HOW YOU PLAY THOSE CARDS, obviously. But the ways that you can play those cards are inherently limited -- and that's what makes designing your DECK so interesting, right?

You can't have your cake and eat it to. At what point are you giving the player so much flexibility in how they play their HAND that the way that they design their deck becomes arbitrary. You have to limit the player's options PER TURN in order to make them more thoughtful BEFORE the battle -- in the preparation phase. You can make the preparation phase more meaningful by making the consequences of it harsher.

So, it seems to me that this compromise between consequences for the PREPARATION PHASE and having tactical variety WITHIN THE BATTLE is where we're at.

Before we end today's discussion, let's examine the sorts of conclusions that we came to:

1.) Traditional JRPG roles seem to work fine within our game's mechanics, with some tweaking to accommodate the relationship between AP and MP.

2.) MP can be used in a variety of ways to make sense of the contrast between 'clothies' and 'warriors'. MP can be used AS A REPLACEMENT FOR AP for clothies who need to be swapped in and out in a single turn and thus don't have much AP to work with. For units which can survive in the ring better, MP can open up FLEXIBILITY for that unit as a window to their secondary and tertiary classes that they can only reach through a couple times per fight.

3.) If we explicitly limit the number of abilities that a single class can have, it will make them much easier to balance and compare to each other.

4.) When deciding how much we want to limit the tactical flexibility of a single unit, both in a single battle and in general, we need to keep in mind that whenever you give more potential to a single monster, you're making other monsters obsolete and therefore are reducing the tactical interest in deck-building. Whenever you allow a player to play a card in another, wholly different way, you're taking away consequences that maybe should have come along with placing that card in the deck. You want, to an extent, for the player to be limited by what they've chosen to put into their deck.


08/15/19:

While I was washing my ass today, i was thinking about classes and having a strict limit to how many abilities they can have.

The one thing that strikes me right away is that, if we give classes a maximum of twelve different MetaAbilities, then it doesn't really make any sense to limit the player's equipped abilities BY CLASS. We would want to limit their number of equipped abilities TOTAL.

So, if each unit has three classes and each class has two abilities per TIER, that means that each unit has access to a total of 12 MetaAbilities: 6 from their primary class, 4 from their secondary class, and 2 from their tertiary class.

So, it seems to me that it would make sense to limit a level 1 unit's total equipped skills to some low number like 4, and then, over the course of the single-player game, they could enhance that unit until it can have all 12 of its metaabilities equipped at once.

Previously, we were limiting the number of equipped abilities per CLASS, but if, for instance, the tertiary class only has 2 abilities to choose from, limiting it per-class doesn't really make any sense.

On the other, if you limit the TOTAL NUMBER OF ABILITIES and you only give a unit access to two TOTAL abilities from their tertiary class, it seems highly unlikely that players are going to fuck around with their tertiary classes that much.

So maybe it DOES make sense to limit the abilities per-class...? What if a unit started out being able to equip only 1 ability per class...? And then they could 'level up' each class to equip more abilities from that class.

What's interesting about this is that, if we increase the 'cost' of character-growth insofar as each subsequent equip-slot per class costs more to unlock, the player might have more of an incentive to unlock tertiary and secondary slots, because there will come a time where it's much more expensive to unlock a new slot for their primary class.

I guess, when you put it that way, it still makes sense to limit the number of equip slots PER CLASS to encourage the player to experiment more with their secondary and especially tertiary classes. Otherwise, it just seems like, if you have 6 equip slots, you're highly unlikely to want to equip something from your tertiary class. It's just too situational.

So, I guess I'm really in love with the idea of limiting the number of abilities per tier, per class. I've been mostly looking at '2 abilities per tier, per class,' but we could go as high as 3. Nine abilities per class.

That could make, for instance, tertiary and secondary classes more interesting, because you'd have quite a few more abilities to choose from.

The problem with having only TWO abilities per tier, per class, is that tertiary classes get pretty boring: you only have two abilities to choose from. If we give them one more ability, that adds 50% more variety to all classes. I think that's still conservative. I think that should keep things limited enough that we have more classes to go around.

Another thing I was thinking about in the shower was that it might make classes more interesting and it may make it easier to DEVELOP CLASSES if we say that no ability in the game can be shared between two or more classes. So, classes don't share abilities. Every ability that we design for a class must be unique to that class.

That makes some things kind of difficult, especially regarding bread-and-butters like 'attack normally for normal damage,' but maybe that's a good thing. Maybe we don't WANT 'bread and butters' like that. Maybe, by taking away that most obvious option, we can encourage the player to end up in more INTERESTING SITUATIONS and to come up with more INTERESTING STRATEGIES. Maybe very simply dealing direct HP damage is just not that common.

But, yeah, that is the problem with not sharing any abilities between classes. These most simple of concepts need to be divvied up very carefully. I think, with some creativity, we could work around this very effectively in a way that could actually make the game more interesting, but we would need to think about it.

I think that the class-designing process would look like this:

You would come up with a simple TASK that the class is especially geared toward. You should be able to describe it in one sentence.

Then you cook up 9 abilities for that class that aren't in any other classes. Then you split those 9 abilities into 3 tiers of 3 abilities each.

So, that sounds simple enough. I really think that THE MOST DIFFICULT PART OF THAT BRIEF PROCESS is creating 9 abilities which are all useful that no other class already has. Also, keep in mind that these 'abilities' that we're talking about are actually what we refer to in our code as 'metaabilities,' because they have VARIATIONS. So, you can create an IDEA for an ability and then you can create little versions of that ability. So, there really is much more than '9' abilities to choose from for any given class.

Let's close our eyes and imagine -- feel the magic. Vegas on acid. Let's make a class.

Binding an enemy caster.

It has 9 meta-abilities.

* Restrict the usage of abilities that have an MP cost above some value.
* Reflect abilities which have an MP cost above some value.
* Restrict the usage of abilities which have more than one target.
* 'Drain MP,' but that's pretty generic and I can see how that'd cause a problem if no other class can have an ability which simply drains MP.
* Increase MP costs by some percentage.
* We could have some kinds of nerfs that specifically target units that have a particular class or 'tag'. Like, a unit could have a 'magical' tag which might not target a high-MP-cost unit like, say, Akuma who uses dark hadou or whatever, but it would target a unit like My Little Pony or The Care Bears or whatever -- a wizard, Merlin -- because we can arbitrary tag units with things like 'magical'.
* Maybe restrict units that have some kind of MP / HP ratio. That sort of defines a caster.

Let's work with those ideas, above, and create some abilities. Or, at least, an outline for some abilities.

1.) If an ability has an MP cost above ____, it can't be used...? That seems pretty harsh. Maybe, if its MP cost is above ____, then its AP cost goes up by ____%? Maybe the SEVERITY of this 'Dynamic Rule' determines whether the ability CAN'T BE USED AT ALL or if it simply increases an AP cost. Maybe variations will cause the casting unit to take damage or some other negative status change. But all of these ideas sound so different -- distinct -- it feels like maybe they should be different metaabilities? Or maybe they're not that distinct because they all explictly serve the same purpose: limit the usage of abilities above a certain MP cost for a single unit.

Maybe we should have an ability for this class which limits the usage of abilities above a certain MP cost for the whole field -- both ally and enemy teams.

2.) A 'reflect' buff which targets a single ally and reflects the effect of any ability which costs above a certain MP value.

Could also have one which affects the entire ally team.

3.) Target a single enemy to increase the MP costs of their abilities by some %.

Again, like most of these nerfs or buffs, could have a variant which targets the entire enemy party.

4.) Prevent the enemy team from swapping in a unit with some particular HP / MP ratio.

We could also have nerfs which target either enemy units or all units with a particular HP / MP ratio.

#

I'm starting to see a pattern when it comes to the difficulty of creating an interesting ability -- and that's the problem of choice. To satisfy a simple idea like 'restrict casters,' there are SO MANY THINGS THAT WE COULD DO. SO MANY that would be interesting or balanced. Some that target an individual unit. Some that target the enemy party. Some that target the whole field. Some which will reflect damage from abilities that cost a certain amount of MP. Some which reflect damage from units that have a certain HP / MP ratio. Some which reflect damage from units which have a certain TAG.

All of these can be seen as functionally similar but with very slight variations. Maybe that's a case for the 'variation' system? Maybe we have a 'reflect' skill which has variations that have different criteria for what they reflect -- all very similar criteria but which may be different enough to create some interesting decisions in battle.

So, maybe what I'm saying is that we need to create some sort of CRITERIA for what constitues an 'ability variation.' We need to decide when it makes sense to create a WHOLE NEW ABILITY and when it makes sense to create a variation of an existing ability. We also need to decide when it makes sense to create a whole new DYNAMIC_RULE and when it makes more sense to just alter the affects of a Dynamic Rule based on its severity.

We have all of these situations which can affect what an ability 'does'. Like, what's the difference between having two affects split over Ability 1 and Ability 2 or having two affects split over Ability 1 Normal and Ability 1 Crit. It's kind of difficult to break these abilities up based on their affect when affect can be so dynamic in our game's engine.

We need some kind of guidelines or some kind of advice that we can adhere to and offer to other designers when it comes to breaking an idea into abilities. You have an idea for something that you want for a unit to be able to accomplish.

That idea can be accomplished in an infinite number of ways, really.

So when do you make those 'different ways' into Glance, Normal, and Crit effects for a single ability. When do you make them into Intra-Meta-Ability variations. When do you make them into entirely separate Meta-Abilities. When do you make more than one different DynamicRule and when do you just alter that DynamicRule's severity.

I feel like, whenever we've sat down and tried to create abilities, this is the #1 problem that we run into: in a game that's so dynamic, how do you actually settle on where to make ideas distinct.

It's almost like we need some guidance. Some system to decide when it makes sense to split up an ability and when it makes sense to just have a variation on crit and when it makes sense to just lean on 'variation,' linear or non-linear -- but I wonder if having guidelines like that would make abilities less interesting in general. I feel like part of the fun is that, sometimes, certain abilities, when they crit, have crazy affects.

But the problem with THAT way of thinking is that it sort of implies having an INSANE NUMBER OF ABILITIES. Like, do we really need an ability which does extra damage on crit AND an ability which deal AP damage on the opponent's next turn on crit. Those COULD BE THE SAME META-ABILITY but different Non-Linear-Variations... but how many NLV's do we really want for that ONE IDEA.

How do we draw the line? There's SO MUCH that these abilities could do.

Well, maybe one thing that would help would be to EXPLICITLY RESTRICT THE NUMBER OF NON-LINEAR VARIATIONS OF A SINGLE META-ABILITY. And maybe every Meta-Ability has the same number of non-linear variations. That would force us to pick the non-linear-variations which make the MOST sense. Yeah, maybe 10 or 20 or 100 different variations could MAKE SENSE, but if every MetaAbility in the game only has 3 NLVs, then maybe, of those 100 ideas, we have to pick the 3 which make the MOST sense for our class, for our Meta Ability. And then we can re-use the other ideas in other classes and other abilities if need be.

That, right away, makes sense to me. That's one way to control how much variety goes into a single MetaAbility.

So, now we have the question of how do you define and DELIMIT what a particular Dynamic Rule can do. In particular, I want to pose this scenario:

'Bind Spell'

Targets a single unit. Any time that unit takes MP damage, that MP damage is increased by some percentage. This includes when they take an MP cost from using an ability, obviously.

Seems simple. Stands to reason that, as the SEVERITY of Bind Spell goes up (remember that every Dynamic Rule has a 'severity value' which can be altered in a variety of way), that percentage increase in MP damage goes up.

But here's my question: is it fair, or does it make sense, or does it make the game MORE INTERESTING to say something like this:

When 'Bind Spell' reaches max severity, abilities which deal MP damage to the user are nullified. In other words, at max severity, a unit under Bind Spell cannot cast.

Or how about this idea:

When 'Bind Spell' reaches max severity, it targets the entire team of the targetted unit.

The reason that I pose these scenarios is that, right there, I've presented three different options for how Bind Spell could behave at max severity. All three options seem sensible considering what Bind Spell represents. How do we decide which of these three options to go with. How do we decide when to make a whole new Dynamic Rule.

Wouldn't it make sense to say that Bind Spell, as a Dynamic Rule, should be restricted to targeting a single unit. I mean, that's what it's for: restricting a unit's ability to cast by increasing the self-MP-damage of their skills.

But isn't it kind of fun that, at a certain severity, the affect could mutate? Like, now it targets the entire enemy team because it became too severe. Or now the target can't cast at all because it became too severe. And then do we need another Dynamic Rule which really DOES just increase self-MP-damage all the way through max severity. Like, that idea seems sensible, too.

How do we decide when we need two similar Dynamic Rule and when we need to consolidate into one Dynamic Rule.

We're talking about WHAT ARE BEST PRACTICES FOR CREATING AN ABILITY IN THIS GAME.

Well, I'm just spit-balling here, but maybe the argument could be made that you could think of some 'classes' as being subservient to particular Dynamic Rules. In other words, maybe, although you have access to 9 Meta Abilities per class and each Meta Ability can have 3-5 Non-Linear-Variations, maybe the entire class only has access to a few different Dynamic Rules...?

That almost seems like tying disparate ideas into one another, but it also could be an effective way to not only limit ourselves, as creators, and give us some ground to latch onto, but it could also be effective for PLAYERS to get a better understanding of how these classes work. If you can look at a class and get a list of the Dynamic Rules that it can afflict, then you can get an idea of what that class is about and how it's meant to be used.

That really makes sense to me. That's a way to limit the number of Dynamic Rules in our game by the number of classes in our game.

Could even say that, like MetaAbilities, no two classes can share a single Dynamic Rule. Maybe that's a part of what defines a class: the Dynamic Rules that it can afflict.

Although, if you can't share Dynamic Rules AND you can't share abilities, I can see how we could run into situations where we don't have interesting abilities or Dynamic Rules to go around.

Also, that means that we can't really create different Non-Linear-Variations which afflict different Dynamic Rules...? Which is sort of the point of Non-Linear-Variations. I feel like they would OFTEN afflict Dynamic Rules.

So maybe it makes sense to not limit Dynamic Rules to a single class. But, rather, a single class only has access to some number of Dynamic Rules.

That gives us some healthy restrictions when defining how Dynamic Rules will work. If we want for a single class to be able to have more AFFECTS with their Dynamic Rules, that means that we need to lump more affects into a SINGLE Dynamic Rule by way of Severity or something.

Supposing that we go with the ideas that twe defined today regarding classes and meta-abilities and dynamic-rules, we have some questions to answer regarding LIMITATIONS.

Q1.) How many Meta-Abilities per Tier should a single Class have?
Q2.) How many Non-Linear-Variations should a single Meta-Ability have?
Q3.) What is the maximum number of Dynamic Rules that a single Class's
     abilities has access to?
Q4.) How should we limit what learned abilities a single unit can bring
     into battle?

Regarding Q4, up to this point, I've expected that we would limit the unit to ONE NON-LINEAR-VARIATION OF A PARTICULAR META-ABILITY at a time. Why? I guess because that seemed tidy.

But why, seriously? Is there any reason to limit a unit to having one version of an ability equipped at a time? If they really feel like there's a tactical advantage to sacrificing one of their ability-equip slots to another variation of an ability they already have equipped, why not let them do that? I don't think there's any way to game the system by having more than one of the same ability equipped -- or by filling their equip slots with a bunch of similar abilities?

AS LONG AS WE DON'T HAVE OVER-POWERED ABILITIES WHICH SAVE THEIR OWN 'HIT COUNTER' AS A WAY TO LIMIT THEM. Like, what if there's a really powerful ability which can only be used 'once per battle.' No MP cost, no nothing else that would limit its usage to once per battle. It's just that the ability instance, itself, saves a record of how many times it's been used in battle -- and, if that flag is at '1' or greater, it can't be used.

If the unit can bring more than one of THAT ability into battle, they could abuse the system.

That being said, THAT particular problem is solved by just tagging the UNIT, itself, rather than saving the value into the ability. That's really a non-issue.

I really feel like there's no reason to limit the number of learned variations of a particular ability that a unit can bring into battle, and that opens up some interesting creative possibilities for us as designers of abilities.

For instance, if you have some kind of slap which afflicts status, and there's one version which afflicts poison and one version which afflicts blindness. Now, the player can bring both into combat if that's what they want to do -- and we can limit those to being NLVs.

To answer a part of Q4, we should NOT limit what abilities a player can bring into battle based on whether or not they belong to the same Meta-Ability.

To continue examing Q4, I DO think, after today's discussion, that we want to limit the number of abilities that a unit can bring into combat for EACH OF THEIR CLASSES. And I think that, as the unit 'grows' to unlock more of these equip-slots, they should become increasingly expensive PER CLASS.

In other words, because the player has the most, best abilities from their PRIMARY CLASS, they're going to want to unlock the most slots for their primary class. But for EACH SLOT THAT THEY UNLOCK FOR THEIR PRIMARY CLASS, the cost for unlock ability-equip slots goes up.

For this reason, a player might be encouraged to open up slots for their Secondary and Tertiary classes instead of their Primary class because it'd be less expensive to open up the 3rd slot for those classes than the 6th slot for their primary class. That makes sense to me.

Now, if we're not going to limit the Non-Linear-Variations that a single unit can equip within their class, there's no reason to place a maximum cap on how many abilities a unit can unlock for any given class.

So, maybe a level 1 unit can equip 4 different abilities at a time: two from their primary class, one from their secondary class, one from their tertiary class. And then that unit can learn new variations of their abilities and they can unlock the ability to equip more abilities for a single battle.

So, that answers Q4.

Q1 is "How many meta-abilities per tier should a class have." What we're talking about, here, is hwo flexible and varied we want for a single class to be.

Originally, I was thinking that we could go as low as 6 total meta-abilities per class, 2 meta-abilities per tier.

But my issue with that is that it makes ESPECIALLY THE TERTIARY CLASS, where a unit can only learn ability variations from TIER 1, very boring. You literally only have two meta-abilities to learn variations from.

Now, obviously, the whole point of limiting a unit's access to their tertiary class to being the 'tier 1 abilities' is meant to be LIMITING. But to only have access to TWO meta-abilities from that class? I'm feeling like we need to go to 3 Meta-Abilities per tier.

So, you have 9 different meta-abilities to learn from in your primary class.

6 different meta-abilities to learn from in your secondary class.

3 different meta-abilities to learn from in your tertiary class.

So, my question becomes... is that still too few? Can we work with that? Or does it make more sense to go to 4 per tier or HIGHER? And I really feel like this comes down to the Tertiary and Secondary classes of a particular unit. That's what's going to benefit THE MOST from having more abilities per tier.

I feel like 4 abilities per tier is too much ESPECIALLY WHEN YOU CONSIDER ALL OF THE NON-LINERA-VARIATIONS OF THOSE 4 META-ABILITIES.

So, let's say that every tier of every class has 3 meta-abilities.

That means that a single unit can learn from 18 different meta-abilities.

That seems pretty fair if we want to have more units in our game, which we do -- it's a monster-collecting game. I don't think that a single unit needs access to more than 18 different meta-abilities, each of which has several non-linear-variations.

So, that's my answer to Q1. 3 Meta-Abilities per tier, per class.

Q2 is "How many Non-Linear-Variations should a single Meta-Ability have?"

More than two. Less than 6.

I feel like '5' would only make sense if you have, like, 3 common variations and 1 uncommon variation and 1 really rare variation. But is that too many -- or is that sort of a good template? Like, one thing I've been wondering is this:

Considering that the Non-Linear-Variation system in our game is based around GACHA. You insert your 'learning points' into the gacha machine and then it spits out a random variation of the ability you picked. Considering that, how much of a role do we want 'rareness' to play in this mechanism? Do we want for these variations to all have approximately an even chance of coming out? Maybe it doesn't make sense to have a 'rareness system' in this sort of game...? Like, how many times do we want for someone to put points into the gacha before they get the variation they want -- it's not like they're earning new abilities after EVERY FIGHT. Learning an ability should be SOMEWHAT expensive, and there-fore I feel like maybe it doesn't make sense for there to be especially rare Non-Linear-Variations.

So, maybe all variations should necessarily be equally common. That makes sense, because, in PVP especially, you wouldn't want for somebody to have a really rare version of an ability that's better because it's more rare.

So, let's lock in the fact that, when you settle down to learn a new ability from the 'gacha,' you have an equal chance of getting any of its variations. You wouldn't want to balance anything around 'rareness' anyway.

That being said, I definitely don't think that we need 5 variations.

So, the question becomes do we want 3 or 4 variations per Meta-Ability? 3 is a pretty round number but seems kind of limiting -- but maybe that's what we want. Makes things simpler for the player. Makes things simpler for us, as designers, because we have to limit ourselves more. When you put it like that, I really feel like we don't NEED 4 VARIATIONS FOR EVERY ABILITY. 3 seems like a GOOD NUMBER for some, a bit of a stretch, even, for others -- and, for a few, maybe not enough. But that's fine. That's what you want.

I'm pretty satisfied with that. Let's lock it in and leave Q3 for Monday.

Q1.) How many Meta-Abilities per Tier should a single Class have?
A1.) 3 Meta-Abilities per Tier.

Q2.) How many Non-Linear-Variations should a single Meta-Ability have?
A2.) 3 Non-Linear-Variations per Meta-Ability.

Q3.) What is the maximum number of Dynamic Rules that a single Class's
     abilities has access to?
A3.) No clue! Let's look at this on Monday.

Q4.) How should we limit what learned abilities a single unit can bring
     into battle?
A4.) A level 1 unit has 2 slots for their Primary Class and 1 slot each for
     their Secondary and Tertiary Classes. Each additional slot unlocked
     for a particular class costs more than the previous to encourage
     players to unlock from their classes evenly. No limit to how many
     variations of a single Meta-Ability can be equipped.


08/19/19

Recently, we've been talking about CREATING GUIDELINES AND BEST-PRACTICES for the development of units in our game. In particular, we've been thinking about ways that we can abstract away a lot of the work of creating roles and abilities.

Since the beginning, we've had difficulty creating abilities and roles and units because, in our game, there's a big focus on 'dynamism.' As a result of this, we find that, as far as DESIGN is concerned, there's virtually no limit to what we can do with our Unit Abilities. So, it becomes very difficult to settle on a handful of different abilities per class; because we could immediately come up with hundreds of abilities. Where do you draw the line? What variation of an ability is the one that you go with?

So, we've been coming up with some guidelines that I think are going to be HUGELY helpful. Let's review those guidelines right now:

For one thing, every monster has 3 classes at a time. 'Class' means the same thing as, like, a pool of abilities. Every monster can draw abilities from 3 different ability pools.

They have a primary pool, a secondary pool, and a tertiary pool of abilities that they can draw abilities from. And when we talk 'abilities,' we're talking about commands that they can use in battle when it's the player's turn.

What's interesting about having these there ability pools is that the abilities that the monster can draw from that pool are limited based on whether that pool is in their primary, secondary, or tertiary slot. Every pool has certain abilities that can only be accessed depending on what slot that pool is in for that unit.

If an ability pool is in the monster's PRIMARY slot, they have access to the Tier 1, Tier 2, AND Tier 3 abilities in that pool. So, all of the abilities.

If the pool is in the monster's SECONDARY slot, they only have access to the Tier 2 and Tier 3 abilities in that pool.

Finally, if the pool is in the monster's TERTIARY slot, they ONLY have access to the Tier 3 abilities.

One guideline that we created for defining these ability pools, which I think will be helpful, is that there's always going to be THREE abilities per TIER per POOL. And each of those abilities is going to have THREE variations.

One question that we haven't answered regarding the ability definitions for classes (ability pools) is one that we posed last week, on Thursday: I think that it would make sense to LIMIT THE NUMBER OF DYNAMIC_RULES THAT A SINGLE CLASS'S ABILITIES CAN INFLICT. I think that would do a lot to DEFINE the limitations and the purposes of that class.

So, if you have nine abilities per class (three from each tier) and each of those abilities has 3 variations, what is a good limit for how many different Dynamic Rules those abilities can inflict?

I guess it would make sense to think about what kind of class would need to have access to a TON of different Dynamic Rules. It would be, like, an afflicter? Some kind of shaman that would inflict a variety of different negative status changes?

Nine abilities. 3 variations each.

If we have 5 Dynamic Rules split over 9 abilities and their variations (so, 27 abilities total), is that too little? Is that workable? Can we do less than that.

Let's look at it this way: if you had access to only THREE dynamic rules, then each of your 9 abilities could have a variation which afflicts ONE of those rules. You could have nine abilities, and each ability could have a variation which inflicts each dynamic rule.

Also, if you had NINE dynamic rules, you could have a different dynamic_rule for EACH metaability. That's too much.

You could also have different abilities which afflict the same dynamic_rule onto SINGULAR and MULTIPLE opponents. You could have some that afflict at different SEVERITY.

What are some other ways that you can afflict the same Dynamic Rule in different ways?

1.) Afflict on a different number of targets.
2.) Afflict at a different severity.
3.) Different % chance to afflict.

We're talking about dynamic_rule economy, basically. Trying to get the most possible mileage out of one dynamic_rule. How many different abilities can you create which all focus around the same dynamic_rule?

Severity is super clutch. The fact that you can use a severity difference to sort of... emphasize DAMAGE on this ability but emphasize THE DYNAMIC on this ability is pretty important.

Like, you could have a 'blind punch' which does ____ damage but also afflicts blindness at a low severity. Or a low chance to afflict.

But compare that to a 'blind spell' which does no damage but therefore has a much higher chance to afflict and / or a much higher severity.

You have nine abilities and three variations per ability. I feel like even 5 dynamic_rules might be cutting it kind of close to create 27 different abilities. And 5 seems like a lot to use to define a class.

'Dynamic Rules' are the core of our game's gimmick. It's pretty much what our game revolves around. They're like 'Laws' in Final Fantasy Tactics Advance, sort of. They're like status-changes in other RPGs in the sense that they can work as buffs or nerfs.

Basically, a Dynamic Rule is a condition that's applied to the battle which takes affect when it's triggered by some other condition.

So, 'Poison' would be a Dynamic Rule expressed like this:

Whenever Unit A takes an action, Unit A takes HP damage.

'Blindness' would be a Dynamic Rule expressed like this:

Whenever Unit A uses an ability, Unit A's 'SKL' (chance to hit) is reduced to some value.

It's like a 'status change' but with an emphasis on controlling your opponent's tactics. For instance, you could have a Dynamic Rule like:

Whenever Unit B is swapped out of the ring, Unit A takes 5 MP damage.

Dynamic Rules are like events which are triggered under certain conditions, and there are a variety of ways that the player(s) can attach these rules to the battle.

Whenever a monster uses an ability, they can attach any number of Dynamic Rules to the battle.

Every monster in the game automatically brings a certain Dynamic Rule into any battle that they're a part of.

A single Dynamic Rule can have any number of 'Severity' values. Basically, in our game code, whenever a Dynamic Rule is TRIGGERED, it checks its own Severity value in order to decide what to do. So, a single Rule can actually have many different outcomes based on its severity.

For instance, a Rule like Toxic which says, "When Unit A takes an action, Unit A takes damage," it could be engineered so that, at Severities 1-9, the Toxic damage varies (goes up) -- but, if it's at Severity 10, maybe the unit just instantly dies.

And a Dynamic Rule on the field can be targeted like a unit, so some abilities may be able to increase or decrease the severity of an active Dynamic Rule.

We're talking about LIMITING A SINGLE CLASS'S POTENTIAL TO INFLICT NEW RULES ON A BATTLE.

I think that, if there was a strict limit to how many different kinds of rules a single class could inflict on a battle, that would go a long way to defining WHAT THE CLASS IS, WHAT IT DOES. We can't just let a single class have access to an indefinite number of rules.

So, I'm asking about rule-economy -- how many different ways can we afflict the same rule.

The problem we're having is that, in a game where every monster ability could potentially do ANY NUMBER OF THINGS. They can do ANYTHING. Obviously, like in most RPGs, yeah, you can HP damage, sure. You can MP damage with some kind of 'drain' ability. You can lower somebody's ATK power.

BUT WITH THIS DYNAMIC RULE SYSTEM, a single ability can do almost ANYTHING. Yeah, maybe your ability does just reduce the opponent's ATK power -- OR, maybe it reduces their ATK power by 1 after every turn in the battle. Or maybe it reduces their ATK power by 1 whenever they take an action. Or maybe it reduces their ATK power by 1 whenever the opponent swaps the unit in the ring. Or maybe it reduces their ATK power by 1 whenever a certain ability is used. Maybe it lowers their ATK power whenever they TAKE damage, to encourage them to be more defensive.

So the problem we're running into is, when you can create abilities which can do ANYTHING, how do you decide which ones to actually bring INTO the game.

And so my idea was to create a LIMIT of Dynamic Rules that a single CLASS (ability pool) can afflict. Not only will that help us as DESIGNERS to encourage us to come up with only the 5 BEST rules that make the most tactical sense, but also I think that it would help the players really understand what a class is FOR if they can see what sorts of Dynamic Rules that class is engineered to afflict. I feel like, by limiting the number of Dynamic Rules that a class can afflict, we're sort of taking a more conscious role in DESIGNING that class.

We're asking the question of rule-economy, and how much we can squeeze out of a single rule? And so Dixx asks a good question: how 'specific' can a single rule get. How much can a single rule's affect vary.

Above, I mentioned a few different things. There's 'severity,' where a Rule's affect can vary depending on its 'severity' value, which can be different when FIRST AFFLICTED, and it can also change over the course of a battle. Also, you could have one ability which afflicts on a single opponent and one which afflicts targeting multiple opponents (or allies).

So, basically, every Rule has a few different variables: severity, target... Rules can know which ability was used to AFFLICT THEM and use that in some way to define their behavior.

Maybe the reason this is causing so much trouble is that I don't really have a great understanding of what it means for an ability to have 'variations'. Let's review that, too.

I'm going to start changing the language of 'class' to 'ability pool,' because I think that it's more clear of what a class actually is.

In terms of character growth, every unit has access to three ability pools, and they're going to have some currency to 'learn' new ability from those pools. And, once learned, that ability can be EQUIPPED onto that unit at any time, but a unit or monster can only equip SO MANY ABILITIES at a time.

So basically, you buy an ability and then you equip it. Sounds straightforward enough.

And your monster's ability pools determine what abilities it can learn.

But there's a GACHA element: when you choose to buy an ability -- to learn an ability -- you will get ONE OF THREE VARIATIONS OF THAT ABILITY, and that variation also has some randomness built in that can make it better or worse, such as a slightly randomized COST to use it, or slightly randomized effectiveness.

So, you'll be learning or buying the same ability repeatedly to get different variations and different 'levels' of that particular variation.

So the idea is that the OVERALL ABILITY THAT YOU'RE PICKING OFF OF THE MENU TO 'LEARN' has some defined usage and purpose, and the three variations below it, one of which you're going to get, put a slightly different spin on that usage and purpose.

In our example, when we were programming this mechanism, was a basic attack ability called 'Slap,' and, when you bought Slap, you got a chance to get either a single, powerful Slap, or a double-slap, or a slap with a small chance to afflict poison.

Those are all essentially similar abilities, but their usage can vary slightly.

That being said, although I like the core of this idea, I don't really understand, PRACTICALLY, how and why we're implementing these three variations per ability. Like, how much are they gonna vary? How do they stay true to the core of their parent ability?

There are any number of Ability Pools in our game, and each Monster has limited access to three of those Pools.

Therefore, the THREE POOLS THAT A MONSTER HAS ACCESS TO IS WHAT DEFINES THAT MONSTER'S TACTICAL POTENTIAL. That's what defines what that monster is good for, so to speak.

Monster A might have access to THESE pools, and therefore THESE abilities. Monster B has access to THESE OTHER POOLS and therefore OTHER abilities. That, probably even more than the monsters' different in stats, is what makes those monters different.

Think Pokemon, how every monster has access to different abilities. That's how these 'pools' work.

And each POOL is meant to serve a certain PURPOSE. Like a pool which specializes in HEALING, or a pool which specializing in limiting the opponent's ability to swap units, etc., etc. So, by having access to these THREE POOLS, you can sort of get an idea of that monster's behavior.

You COULD use stats to differ monsters which have the same three pools, but I don't think that it would make sense to give more than monster the same three pools IN THE SAME ORDER. I look at 'stats' as being more SUBSERVIENT TO THE ROLE IMPLIED BY THE THREE POOLS rather than as a way to distinguish monsters.

I want to stress again that, although a monster has access to three pools, they don't have EQUAL ACCESS TO ALL THREE OF POOLS. One of those pools is going to be their PRIMARY POOL, which they can access ENTIRELY. One of those pools is going to be their SECONDARY POOL, where they can't access the pool's most POWERFUL or BREAD-AND-BUTTER abilities. The third pool is their TERTIARY POOL, where they can only access the most situational or least bread-and-butter of that pool's abilities.

We call those Tier 1 (bread-and-butters), Tier 2 (slightly more situational), and Tier 3 (very situational abilities probably not used often or to great affect).

So, the idea is that each POOL defines a certain tactical behavior, supposing that it's a monster's PRIMARY POOL. So, all of the abilities in a single pool should all be toward a similar purpose or a similar tactic. And therefore, by having access to three DIFFERENT POOLS, we can see a particular monster's tactical FLEXIBILITY. How CAN you use monster?

That being said, each ability can only belong to ONE POOL. So, when talking about how these pools are DESIGNED by US as the game-designers, we need to think about how SPECIFIC a particular ability is to a certain purpose. A challenge immediately arises because you see that only one pool can have something like 'tackle,' which just does raw HP damage.

That seems kind of nuts that only one ability pool would have access to a very simple, raw-damage ability.

But it makes more sense when you consider how our game is meant to be played with a strong emphasis on Dynamic Rules. It's about controlling the battle INDIRECTLY. So maybe it makes sense that abilities which only do straight-up HP damage might be somewhat rare. And, therefore, a monster which has that ABILITY or that POOL could be pretty specialized toward coming in and doing damage.

To answer dixx's question, "What makes Ability 1 belong to Pool 1," the ability's function has a major impact on what pool it goes to -- and, on the other side of the coin, a particular pool might NEED a certain ability in order to round it out, and so that would define what ability it gets, there.

So, the way that I imagine designing these abilities is coming up with a POOL IDEA, first -- a tactic in battle. A way of playing. A purpose that a monster might serve. And then we would come up with abilities which make sense for that pool. And we would break those abilities up into tiers.

Bread-and-butters or THE MOST POOL-DEFINING ABILITIES in Tier 1.
Abilities which might fulfill that purpose fairly strongly but not as much as the bread-and-butters in Tier 2.
Some supporting or supplementary abilities which fall under that purpose as Tier 3.

Kind of where we're at, in our game-design process, is thinking about LIMITATIONS and how having those limitations are going to help us understand how many different POOLS and MONSTERS we need.

Last time, we did a lot of talking about INTRA-MONSTER FLEXIBIILTY versus INTRA-DECK FLEXIBILITY.

We talked about how, if a single MONSTER has too many tactical OPTIONS available to it, then there's LESS INCENTIVE to design your entire DECK in a flexible way.

So, we have to limit how many uses a single monster can have -- like, how many purposes -- so that it makes sense to look at a wide variety of monsters and pick them carefully for your deck.

At the same time, we do want to be more flexible than Pokemon, where each monster is pretty much EXTREMELY limited in their role. In Pokemon, you have 4 ability slots, and you can fill them with a variety of abilities depending on what you choose to remember and forget as you level up -- but that's it.

So dixx's question is, "how many monsters are we planning on? And how many pools?," and that's exactly the question that we're trying to answer.

If each pool has more tactical flexibility, then we need less pools. And, by extension, less monsters.

If each pool's purpose is more NARROW, then we need more pools and we need more monsters.

In part of answering that question, in the last stream, we argued back and forth about whether a single POOL should have 6 ABILITIES with 3 variations each or 9 ABILITIES with 3 variations each.

The former would see each pool being more limited, and so we'd end up with more pools and more monsters, which would make deck-building more interesting.

The latter, which we decided to go with, gives each pool more abilities, and therefore more flexibility, and so we won't end up needing as many pools or as many monsters.

But, before our last stream, we had conceived no limits for how many abilities a single pool might have, and so the answer to dixx's question was COMPLETELY up in the air.

Now, we're trying to create guidelines and limitations for each pool so that we can come to a better understanding of what each pool is going to be LIKE. How much flexibility defines a single pool.

Part of answering this question is going to involve taking a closer, more critical look at the idea of 'ability variations.' What kinds of variations make sense for a single ability?

For one thing, we've already discussed that these 'variations' HAVE TO BE MORE than slight differences in cost or effectiveness, because those fall under the randomization that occurs WITHIN a variation. So, a 'variation' (or 'non-linear-variaton,' as we've called them) does imply some tactical difference, but still serving a common purpose with its parent ability.

For each POOL to have TWENTY SEVEN DIFFERENT ABILITIES is starting to sound kind of extreme. Yes, those 27 abilities are divided up under 9 master purposes, but DAMN that's 27 abilities.

Do we need to lower the number of 'parent abilities' to SIX per pool. Two for each tier.

We decided to go with 3-per-tier because we wanted to make learning TERTIARY ABILITIES more interesting. If you have a tertiary pool and you can only access its Tier 3 abilities, that means that, with 6 abilities per pool, you would only have access to 2 abilities from that pool -- and, by extension, 6 different variations.

But I mean hey, depending on what we decide makes sense for the idea of a 'variation,' I mean, that's 6 different abilities to choose from for your tertiary class. Six sounds like a lot. But, if those six pretty much fall under 2 different purposes, maybe that's NOT enough -- but it all comes down to what a 'variation' really amounts to.

Okay, well, how about this: I think we need to look at ability pools as having SIX abilities, two per tier. That encourages us to make variations more interesting. Because, I just don't think that a single pool needs TWENTY SEVEN DIFFERENT 'CHILD' ABILITIES. That's just too much variation for a single pool. Too much to choose from.

If we lock in SIX PARENT ABILITIES PER POOL, or two per tier per pool, that gives us a total of EIGHTEEN CHILD ABILITIES, and that sounds like a lot. That's plenty to choose from. And that extra limitation means that it becomes easier for US to decide what a pool is really 'for,' and it's easier for the player to see, at a glance, what a pool is really for.

And that makes it easier for us to look at those EIGHTEEN VARIATIONS and SIX ABILITIES and figure out how we're going to divy up the DYNAMIC RULES insofar as what these abilities are meant to be used for.

Again, for that sense of clarity for both the designer and player, I'm interested in limiting the number of Dynamic Rules per ability pool as much as we can -- as much as we can where things are still flexible and still make sense.

So my question is this:

If we have six abilities with three variations each, can we work with three dynamic rules per pool. Or is that just too little.

Maybe it makes sense to ask ourselves WHAT AN ABILITY REALLY DOES IN OUR GAME.

Abilities can lower or raise attributes DIRECTLY, PERMANENTLY.
Abilities can afflict Dynamic Rules.

I think those, in the abstract, are the two things that an ability can do.

So, that being said, what are we REALLY LOOKING AT for ability variations:

1.) They afflict a different dynamic rule.
2.) They have a different balance between afflicting a rule and affecting an attribute directly.
3.) Different properties (see above) on glance, normal, crit. Maybe one variation always afflicts at a low-severity but another variation only afflicts on crit but at a high severity.
4.) They have different options for picking targets, at a spectrum of effectivenesseseses. But then, we gotta remember that our abilities should REALLY focus on the opponent in the ring with only relatively minor attacks on other units. Whenever you talk about targeting multiple units or a team, we gotta be careful with that design.
5.) Could alter effectiveenss at an altered cost, but this difference would need to be dramatic enough to not fall under the perview of 'linear variation,' or the randomness that can occur within a single variation.

Let me say this: if we have 6 parent abilities per pool and 3 child abilities per parent, and if we only have 3 dynamic rules to afflict, it hardly makes sense to have a variation which afflicts a different dynamic rule.

Maybe we need to examine the option of lowering the number of child abilities per parent ability. I've been hesitant to do that because it calls into question the entire purpose of these variations -- it dramatically reduces the 'gacha element' -- but that would make abilities more sensible to design.

If we were going to go from 3 child abilities to 2, maybe we just simplify it to say that one is common and one is rare. Or maybe we could leverage dixx's idea of having some inherent value into the monster, itself, where some monsters are more inclined to learn Ability B and others are more inclined to learn Ability A, and that could be a fun way to have two different monsters of the same type which have different abilities.

Because, honestly, coming up with THREE DIFFERENT VARIATIONS OF EVERY ABILITY without being able to arbitrarily create new DYNAMIC RULES FOR THOSE VARIATIONS is going to be a huge challenge, right?

Or maybe not. I mean, we could even establish a guideline like, "every ability has a cheap and an expensive variation." That immediately leaves only one variation left to create.

Maybe it makes sense to have a version of each ability that has a greater cost and a greater effectiveness. That doesn't sound that bad. We could do 3 variations per ability.

If we have three dynamic rules per pool and 6 abilities, that would give us a pretty good balance...? Where- yeah. Yeah. But then, taking the example of the 'shaman' or 'afflicter' class which entirely revolves around afflicting a status change, how do we create 6 abilities from three rules?

Well, speaking of 'variations,' let's just assume that every parent ability has a 'cheap' and an 'expensive' child. And let's just assume, for the sake of argument, that there's also a 'risky' child, where the affect on normal is shittier but the affect on crit is much better.

There you go: three interesting variations per ability.

So, what we're realling working with, then, is SIX ABILITIES split over THREE DYNAMIC RULES.

How does this shaman define their abilities from that?

WELL, let's say that this shaman's 'function' revolves around this idea of a 'destiny bind,' where, when one unit takes damage, another unit also takes damage.

Maybe he has ONE ability where he binds a FOE to an ALLY, so now this ALLY cannot be targeted damage unless the enemy player is okay with hurting his own unit.

Maybe he has ANOTHER ability where he bindes a FOE to a FOE, so now it's much riskier for the opponent to swap EITHER of those units into the ring.

Maybe he has an ability where no unit can leave the ring. That binds their fate together and has tactical implications.

So that's three abilities and two rules.

So, basically, we have three abilities left to define and only one rule left to define.

The third rule could be a more severe version of the first rule, where maybe EVERY TYPE OF DAMAGE THAT UNIT A TAKES, UNIT B ALSO TAKES, whether it be damage to ATK or damage to MP or to LP or to HP.

Or maybe it's a rule which swaps the attributes of two units.

Well, that first rule could actually be a SEVERITY VARIATION of the rule for abilities one and 2.

I love the idea of swapping the attributes around for two units. But the problem becomes intra-rule variation: it'd be nice to have one which only swaps HP, and then one which swaps MP and HP. Maybe one that swaps ATK and DEF between two units. So, we have this problem where we want to define too many different rules.

It strikes me, though, that swapping HP and MP wouldn't really need to be a rule, because it'd be permanent, where-as trading ATK and DEF would need to wear off after a while, hence 'rule'.

Maybe the 'ring' ability where neither unit can leave would be a better fit for a different class. So, maybe this pool's three rules are:

1.) Two units share the damage they take.
2.) Two units have their ATK, DEF, PRY, and SKL swapped.
3.)

So, basically, I gotta end the stream and play some 3rd Strike. But, based on this example, it seems kind of reasonable, to me, to limit a pool to 6 parent abilities, each with 3 child abilities, and 3 dynamic rules split among those abilities.

We're gonna leave it there.


08/21/19:
I just had an idea. Considering that, in our game, units are limited to a certain amount of 'LP,' maybe we don't need abilities which are for the express purpose of 'reviving' units. Maybe any ability which restores HP could restore a unit back to a non-KO'd state just by bringing their HP from 0 to some value above zero.

The immediate downside of this is that you may end up in situations where your team has some kind of 'regen' buff, and let's say that it restores 5% of max HP to the entire team, per turn. Now you have a situation where a unit is repeatedly being KO'd and revived maybe only to be KO'd again.

Also, this trivializes the idea of 'reviving' a KO'd team-mate. Like, if this mechanic were to behave as described above, 'regen' would be an INCREDIBLY POWERFUL buff because it would mean that you could passively revive KO'd units without having to expend a turn.

Before we go on talking about game-design and working on our game-design document, the topic has come up a bizarre number of times, tonight, about our game's settings and themes.

When we began this project in January, the idea was for it to be a community-effort where we all chipped in and shared ideas and came up with the world, graphics, music, and game-design together.

That ideal for this series didn't really pan out the way that I hoped it might, although it has mostly panned on the way that I expected it would.

Basically, back when we started, there were, of course, a lot of ideas floating around for THEMES and NARRATIVE and SETTING and ideas for various art style we might use, etc.

As we got past that point and began to focus more on programming and game-design, a lot of interest fell off -- and I do think that programming and game-design should make up the bulk of any game-dev project.

But, going back to January and February, we did more-or-less settle on some ideas for our game's settings and themes:

The idea was that a mild-mannered mall employee, in his early twenties, ends up with this extra-dimensional power that makes him solely aware of an invasive alien force which is going to take over the world by bringing FICTIONAL CHARACTERS from the world of POPULAR CULTURE into the realm of reality and using their power to subjugate mankind.

So, our lead character(s) inherit this ability to also summon these fictional characters and force them to fight, making them pretty much the only opposing force to this evil invader.

What's cool about this idea is that it comes BUILT-IN with ideas for 'monsters' or 'units.' We're talking about tongue-in-cheek copyright-free variations on popular characters. We could do, like, "Scarred Boy Wizard," and "Sparkly Vampire," "Electric Mouse," "Magic Pony." The idea was brought up that we could include pro-wrestlers -- any character from movies, cartoons, music, wrestling -- any pop culture figure.

We kind of put it to a 'majority rules' poll and this is the theme that won out, but there was some push-back from others that thought that it was kind of silly. It was a missed opportunity to go for some more serious themes.

Now that it's literally been more than six months and 90% of those people that voted have apparently lost interest in the project, I think that there will come a time in the future where we're going to reexamine our options for themes.

So, to answer the question that has been coming up tonight, I'm going to say that we're not particularly attached to any ideas yet regarding theming or setting or characters. That's still up-in-the-air. But what we've been WORKING WITH is this idea where the units are pop-culture icons.

Dixx mentions that going with an overly serious tone for the story wouldn't really make a whole lot of sense -- perhaps -- because the STYLE of the game's art and music is going to be such a mish-mash. On the other hand, if we take a step BACK from traditional narratives and go for something more 'surreal', maybe we could even accomplish MORE with the user-created content.

Maybe, instead of having one central story, maybe we could take submissions for more, smaller stories. Maybe these characters end up in ALL kinds of situations that may have little relationship to one another. Just as vehicles to see more peeps' artwork and catch new monsters.

Is it fair to say that we've completed our game-design bible up to the point that we've designed the game. I think that anyone reading this document would get a pretty good idea of how our game is played -- maybe as good of an idea as we have, as designers. There are still quite a few topics which I feel we've explored INADEQUATELY. I've been recording them in the 'to-do list' of the game-design document, but I'm going to refer to them here.

1.) We gotta talk about Exploration and the 1-player experience, in
    general.
A.) Fuuuuuuuuck thiiiiiiis. We are so far from worrying about the 1-player experience that I don't even want to think about. As from this very moment, there is no 1 player aspect of this game. We can worry about that once we have the multiplayer working. Which means there's no more narrative, there's no more characters, there's no more theming. In the short-term, as we approach having a playable, multiplayer game where the community comes together to create new 'units' or 'monsters,' there is no theme. If anybody wants to make a unit, make whoever they want. If we want to get to a single-player point, eventually, we can talk about re-skinning the units that we've already made to conform to a theme. But, as of right now, I want to be clear that we're entirely focusing on the multiplayer aspect, and that makes things like 'exploration,' and 'setting,' etc., kind of trivial.

2.) Character growth. How does the player earn points to grow their
    character? How many kinds of points are there? What are these points
    used for?
A.) Alright, let's talk character growth. This is something that we've been HINTING AT for a long time but whose individual mechanics we haven't designed.

First of all, let's talk about what we DO know: first of all, one thing that I'm feeling kind of hard-assy on is that UNITS DO NOT LINEARLY LEVEL UP THROUGH COMBAT EXPERIENCE. This is contrary to 90% of JRPGs, but this NON-LINEAR, POINT-BASED GROWTH is more consistent with WRPG design.

But, that presents a problem: if a unit is meant to be tanky and has default attributes suggesting such, how are we going to encourage it to STAY TANKY if it doesn't level up linearly, but, rather, players get to decide what attributes they want to raise.

Maybe we can give each unit some sort of DISCOUNT for raising certain attributes over others.

In other words, here's a few loose thoughts:

When you succeed in combat, you earn GROWTH POINTS -- toward you, as a player -- not toward your team. Not toward your units. Just toward you: you have an inventory of growth points that you can choose to spend on any unit.

The advantage of this, right away, is that it encourages you, as a player, to experiment with different units on your team -- because you can effectively level-up your units without EVER BRINGING THEM INTO BATTLE. You could save up a store of Growth Points and then pick a brand new unit into your team and level it up to be competitive with other units in the game.

Also, it simplifies things -- but really, I think that, in a game where you're meant to constantly be making tactical decisions about which units are on your team, choosing from potentially more than 50 different unit-types, I think it makes the most sense to allow the player to earn these 'growth points' and then spend them on WHOEVER. That way, it minimizes the player being stuck with a certain team just because that team keeps WINNING and therefore LEVELING UP.

Before we move on from THIS point, let's BE TEH DEVIL'S ADVOCATE and look at ways that this DESIGN immediately fails.

For one thing, you could argue that it TRIVIALIZES THE PLAYER'S ATTACHMENT TO THEIR UNITS when the units that they bring into battle have no impact on which units are actually BENEFITING from that battle.

My immediate counter-argument is that we want for the player to pick units based SOLELY ON TACTICAL CONCERNS. And so this design where growth points are earned and spent freely between units is in support of that design.

One thing that I want to consider is that we're getting ahead of ourselves: we're talking about a ONE-PLAYER, GROWTH-BASED GAMEPLAY EXPERIENCE, and maybe we're just NOT THERE YET. So, before we go any further in that direction, let me pose THIS question:

What IS character growth for the game's PVP element.

First of all, I think that, in the competitive, PVP space, it's important that all units conform to a META LEVEL. I don't think it's constructive, ESPECIALLY BECAUSE OUR GAME'S 1-PLAYER ASPECT IS SO UNDER-DEVELOPED, that we consider teams where one team may have out-grinded another team.

So, in order to facilitate this CHARACTER CUSTOMIZATION, I feel like maybe, rather than worrying about how Growth Points are EARNED, we need to think about a situation where all of the units on both decks are considered to be at the SAME STARTING LEVEL, and both teams are given some budget of Growth Points to spend among their team.

So, yeah, let's walk backwards and forget about the 1-player experience and just consider THIS experience:

The players pick their units for their deck, and they're given some amount of growth points to spend on those units before the battle begins.

So, now we can answer: WHAT ARE THESE POINTS BEING SPENT ON.

Basically, let's list what we KNOW we want to be able to spend points on insofar as growing our units:

I.) Linearly raise their attributes: HP, LP, MP, ATK, DEF, SKL, PRY. Spend some points, raise your attributes.

II.) Learn new abilities from our Ability Pools. Spend some points, get a
new child ability.

III.) Unlock new Ability Equip Slots. Spend some points, now you can bring more abilities into battle.

IV.) Dixx points out that we could maybe spend this SAME CURRENCY ON BUYING ITEMS BEFORE THE BATTLE. Below, I note that 'items' and 'inventory' are not something that we've talked a lot about, in the past, but which I want to talk about more.

Because this process of 'creating a team from scratch before battle' could be very TIME CONSUMING, maybe it's healthier to imagine a player creating a sort of 'meta build' deck that they can use, at will, in PVP.

Can we just use one master currency? Do we want to use more than one kind of currency? And, importantly, let me ask THIS:

In our game, learning abilities constitutes a GACHA ELEMENT. Abilities you learn have semi-randomized effectiveness and outcomes. We've talked a lot about that. How does this impact the PVP meta? I almost feel like 'learning' abilities shouldn't even be a part of the PVP meta insofar as maybe you can learn abilities OUTSIDE OF COMBAT, OUTSIDE OF YOUR BUDGET, and then use any one you want in PVP.

In some ways, as gross as it sounds (it's not as gross as it sounds), there are some parallels to loot boxes in the way that our game handles Abilities. I don't think that, within the limited randomization of these abilities effectiveness, choosing one over another is going to have a HUGE impact on combat. So, if you grind for a long time and end up with an ability with quite ideal randomization (low cost, high effectiveness), it will give you a MINOR advantage over an opponent who hasn't grinded to get that ability (at random). And, if you're just choosing from 'any ability' before you enter PVP anyway, maybe it makes sense that you can just bring in the abilities that you've unlocked for that unit.

My question is, with the gacha element working as it does, does it make sense AT ALL for abilities to be a part of the budgetted-GP-pre-PVP meta. Because, if you spend GP to learn a Parent Ability, you get one of its 3 child abilities at random. And those child abilities, while conforming to a similar purpose, could be varied enough to have a relatively significant impact on your tactics -- and, like Dixx said, if you don't get the roll that you want, you could obviously just re-roll your whole deck. The only downside to that would be that, if you got a GOOD ROLL on a previous unit and then you get a BAD ROLL (at least, for the strategy you were expecting to play) on the next unit, you have to decide whether you want to re-roll or not.

So, you have to decide how many points you want to spend on re-rolling for abilities (probably only wanna learn each parent ability once, honestly) and how much you want to have left over for raising your attributes or spending on items.

The alternative would be that the GP budget you get is for raising attributes, unlocking ability equip-slots, and / or buying items, but you can bring in any abilities that you've learned for that unit.

Now that I've said it out loud, I can see merits for both approaches: if you can bring in any abilities that you've learned, for that unit, and your GP budget doesn't go toward learning abilities at all, that simplifies things a lot.

If you have to spend your budgeted GP on learning abilities through the gacha, there's this element of randomness that makes the strategy that you end up employing be somewhat DYNAMIC. I kind of love when games give you something you don't expect and you need to think on the fly of how you're going to make the best use of it.

Dixx talks about how spending GP makes it more limited regarding what abilities you can bring into combat, but I want to stress that the 'meta unit' that you bring into PVP defaults to only have 4 ABILITY EQUIP SLOTS. So, no matter how many abilities you've learned, you can still only bring in 4 of those abilities, per unit, unless you want to spend GP to unlock more equip slots.

The gacha kind of suits our ideal of having the CHILD ABILITIES conform to a STRICT PURPOSE OF THE PARENT ABILITY. Like, you would still be able to design your strategy around the PARENT ABILITY THAT YOU BUY, but the implementation might change slightly based on what ability you get from the gacha. So it's not like you completely lose tactical control.

As a loose note, I want to point out, ESPECIALLY after making that lootbox comparison, that none us here want to SELL POINTS TO LEARN ABILITIES, which is a dangerous game when you talk about having GACHA in your game. If you can GRIND for ability-unlocks and then take any ability you've unlocked into the PVP meta, the question becomes: how do you grind for these unlocks in the first place. Winning in PVP? Winning in the hypothetical one-player game? Or, MICROTRANSACTIONS.

I kind of feel like it's more IN THE SPIRIT OF THE GAME to BUDGET the player with some amount of points that they can choose to learn abilities with for this deck -- and if they don't like the rolls that they get, they can start a new deck and try again. Because we're talking about TEN DIFFERENT UNITS IN THE DECK, you're not going to be able to roll until you get a hypothetically PERFECT SET OF ABILITIES. Therefore, the player is always going to have to work with what they're given, and that's kind of attractive to me.

In our MAIN GAME (hypothetical 1-player), you RE-LEARN ABILITIES as many times as you want -- as many times as you can afford. You just get different copies -- you have this inventory of abilities. The unit has this inventory of abilities that they've learned which could feature all kinds of different CHILD ABILITIES of the same parent (we used to call this 'Non-Linear Variaton') and all kinds of LINEAR VARIANTS of those individual child abilities (different effectiveness-levels).

So yeah, in the PVP meta, you would hypothetically be able to relearn abilities the same way -- which could create some fun risk-reward in deck-building. For instance, let's say that you've customized 9 of your ten units and you're quite happy with how they turned out. Now you're on your tenth and last unit, and you get a REALLY SHITTY ROLL ON YOUR ABILITY. Maybe it's the Non-Linear Variant that you LEAST-WANTED, and maybe, as a Linear Variant, it's also really weak (high cost, low effectivenes).

With your budgeted GP, you could choose to RE-LEARN THAT ABILITY and see if you get a better roll. Obviously, you would never do this on your FIRST UNIT you were customizing, because you would just re-roll the deck. But since you're 9 units in and very happy with it, now is the time that you might choose to RE-LEARN AN ABILITY instead of spending those same points on raising attributes.

Now is the time to talk about LEARNING ABILITIES and the COSTS ASSOCIATED WITH THAT.

My thinking has always been that there wouldn't be per-ability costs like there is in a game like, say, Final Fantasy Tactics. Because all abilities are supposed to be designed such that they're all useful, EXCEPT THAT:

Tier 1 Abilities are bread-and-butters that are meant to define the ability pool (or 'class').

Tier 2 Abilities are less-commonly used than bread-and-butters but are still usable pretty often.

Tier 3 Abilities are supportive of the ability pool's goal, but are more situational or less effective.

So, maybe there's a pricing system based on tier? Pricing based on tier doesn't necessarily make sense because the player is already LIMITED to what abilities they can learn from which POOL, by their tier. So, tiers already have a significant limiting impact on the player.

So, I've always just kind of imagined that 'learning an ability' would cost some amount of points -- whether that be some fixed amount of a UNIVERSAL CURRENCY, or whether that be 1 'Ability Learn Token' or whatever, if we want to go with splitting up the currencies.

I think that we want a UNIVERSAL CURRENCY WHEREVER POSSIBLE, because, I don't know if you guys would agree, that a MORE UNIVERSAL CURRENCY MEANS MORE INTERESTING DECISIONS. It means more interesting compromises -- but, then again, that's where splitting your currency comes in. It allows the player to make CERTAIN DECISIONS WITHOUT impacting OTHER DECISIONS, which means that they can be more RISKY.

Like, for instance, if we create 'Ability Coins,' and you spend one ability coin to get a child ability. Now, the player can say, "I have this many Ability Coins, so I have ______ chances to fuck up a gacha roll." So, now they're more inclined to take interesting risks with their Ability Coins. They have to decide WHICH abilities they want to re-roll for.

On the other hand, if our currency is TRULY UNIVERSAL, now the player has to choose between re-rolling and missing out on an opportunity to raise somebody's HP or something. On the one hand, that adds depth -- but, on the other hand, it also kind of makes the player want to lean overly toward optimization.

I guess, in terms of game-design, it kind of makes sense to split up your currency with consideration to the sorts of decisions that you want your player to make -- especially as it relates to CHOOSING BETWEEN TWO THINGS.

Do we want the player to be choosing between TWO ABILITIES? Or do we want the player to be choosing between an ABILITY and RAISING THEIR HP? I mean, for instance, what if we also budgeted them, like, "Equip Slot Coins." Now, the question is no longer, "Do I want an extra equip slot on Unit A or more DEF for Unit B," but rather, "Which of these units do I want to have the most EQUIP slots?"

Let's talk about what we've NAILED DOWN:

A player is going to be able to choose 10 units from their collection for their PVP deck. These units will all be given a meta-level of default attributes based on their unit type. The player will be given a budget of SOME KAINA POINTS that they will use to CUSTOMIZE their PVP team. This INCLUDES learning abilities.

* Should a unit start with 4 default abilities (perhaps the randomized abilities that it had when it was 'caught'), or should the player have to buy any abilities that they're gonna use?

The question is, how many types of currency do we want to budget them to customize their team. How much double-duty is this currency running. Is it the same currency for buying abilities, buying new equip slots, buying enhanced attributes, and buying items? If it's all the same currency, then we get some decisions HIGHLY BASED AROUND OPTIMIZATION, which could be very subjective to what each player thinks of as being optimal, and it means that how you spend this currency has TERRIBLE consequences -- and you guys know how much I love terrible consequences. It means that you've got some really tough decisions to make.

If we split up the currency, it makes the consequences of each individual decision much less drastic, which could benefit the game insofar as allowing the player to be riskier.

When I type it like that, it makes me think about how much more VARIATION you could see in decks when the currency is universal. Like, if we gave the player some 'Attribute Coins' and they just choose how they want to spend them -- yes, that's still an interesting decision, and it may benefit from being much less DIRE compared to when you're deciding if you want more attributes or more abilities... but it also means that EVERY TEAM WILL HAVE RAISED THEIR ATTRIBUTES BY THE SAME AMOUNT. If we make currency universal, it means players will choose WHAT ASPECT OF THE GAME'S MECHANISMS ARE MOST SUPPORTIVE OF THEIR PLAYSTYLE. Maybe they want a greater variety of ABILITIES, or maybe they want a greater variety of ITEMS, but they can't have both.

When I come back from my break, I want to talk more and then FINALIZE a decision regarding the NATURE of this budget that we're giving players to customize their units with. Do we want to go with a universal currency. Do we want to go with individual currencies for EVERY aspect of character develop. Do we want to budget it PER UNIT or PER TEAM.

It's gonna be tough to decide. We gotta really talk this out. The pro's and con's.

We're talking about DIRENESS MANAGEMENT. That strikes me. It seems like the main difference between splitting up our currency per TEAM and per UNIT and per PURPOSE is 'direness management.' It seems like, the more UNIVERSAL we make our points-pool, the GREATER THE CONSEQUENCES OF SPENDING EVERY POINT, because we COULD HAVE SPENT IT on MORE THINGS.

The more LIMITED IN SCOPE we make EACH currency, the less DIRE THE CONSEQUENCES OF SPENDING IT. So, a major question becomes HOW MUCH WE TRYNA STRESS THESE PLAYERS OUT.

But, as I was saying that, it strikes me that there actually is another concern when it comes to making points less universal: and that's balance.

Think of this. What if we had a UNIVERSAL CURRENCY that was in a shared pool FOR THE WHOLE TEAM.

Now imagine that we use that ENTIRE CURRENCY to boost the DEF of a single unit. That unit would be unbeatable unless the enemy team spent their entire currency on buffing the ATK of a single unit.

So, that's a concern that hadn't struck me until now. Universal currency, team-wide pool: what if you just dump everything into one or two things. Does that break our game? Can we make the cost of raising ATK go up so that it's not feasible or sensible to spend all of your points on ATK? Probably, but that NOTION is still there: you can and maybe SHOULD sacrifice entire UNITS of your team to buff others.

I mean, for god's sake, we're talking about PVP mechanism where players can choose to do ONE BATTLE or BEST-OF ANY NUMBER OF BATTLES. If we're doing a one-or-two battle format, then, honestly, we literally have no way to even USE all of the units in our deck. So, they're getting this budget FOR THEIR ENTIRE POOL OF UNITS, and it stands to reason that a couple (or more) of these units would be totally neglected.

But, what we've always said when faced with these sorts of balance problems is that it becomes our responsiblity, as designers, to incentivize the player to grow ALL OF THEIR UNITS. Like, you should WANT to raise ALL of your units. If you fail to raise all of your units, that should come at a great cost to you.

Well, for one thing, we could ask that players choose a BATTLE-TYPE for each deck. Rather than say, "Do you want to use this deck in 1 fight, 2 fights, 3 fights, etc.," we could have them answer that question on deck creation.

Let's not forget, though, that we expect for players to tactically pick their units based on counter-picks of their opponent's units. So, maybe having a larger deck is still sensible -- I mean, you don't want 4 over-powered units... You'd rather have 10 units offering a better tactical splay...? Maybe not. Maybe that's a problem.

It strikes me: let's talk about the DOWNSIDES of having the currency be divided up PER UNIT. Because, when I think about, there really is no downside.

The UPSIDE of having a TEAM-WIDE CURRENCY POOL is that you can choose to buff certain characters more than others. I'm not convinced that's an upside. It's a DECISION that you can make, and that's cool. It's a SACRIFICE.

But isn't that sort of sacrifice CONTRARY to what we're trying to accomplish with this game. The idea is that you should be making TACTICAL DECISIONS ABOUT WHICH UNITS YOU BRING INTO WHICH BATTLES based on their tactical merits. We don't want people bringing in certain units because those units are STRONGER.

So, maybe we need a currency PER UNIT.

And, if we're going PER UNIT, that means that it makes much more sense for that currency to be UNIVERSAL.

If we do it that way, though, it means that we'd need to give the player a separate currency for buying items? Or maybe they could just refund all of the points that they don't use for each unit and use that to buy items?

But we haven't talked about items at all. We don't even really know the FUNCTION or VALUE of items in our game.

So, we've looked at 'inventory,' now, and are more-equipped to come back here and continue looking at CHARACTER GROWTH. Here's how I see deck-construction:

First, you go through and pick 10 units for your DECK. Each unit has its stats set to its meta. You also pick a leader.

Then, you go through on a unit-by-unit basis and spend that unit's POINTS. These points can be spent on any combination of RAISING ATTRIBUTES, LEARNING ABILITIES, AND BUYING ABILITY-EQUIP SLOTS. The responsibility falls on us, as game-designers, to balance these costs in such a way that all three of those options are equally attractive.

When you're done doing this for all of the units in your deck, you can refund all of your unspent points from every unit into a single pool which you can then use to buy items to take into battle.

I.) For PVP, players can choose a deck of 10 of their units which are reset to a 'meta level' with default attributes per-unit. They're also given a per-unit budget of 'Growth Points' we can be spent on learning abilities, unlocking ability-equip slots, and / or raising attributes.

II.) Players can refund their unspent points and use that to buy an item inventory that they can use during their PVP bout.

3.) 'Equipment'. We talked about gear being permanently or semi-permanently
    bound to a unit and affecting their growth and maybe even their
    tertiary class? How is this all gonna work?
A.) I like the idea of GEAR as one more way to AUGMENT a unit. So, WHAT DOES THIS GEAR DO.

I.) Gear augments the 'meta level' of various attributes on the unit. In other words, whenever you BUY AN UPGRADE TO A PARTICULAR ATTRIBUTE, the amount that it GOES UP is in relation to its META LEVEL. This is how we're going to make certain units conform to certain BUILDS even if you want to spend points to make their attributes better.

For example: let's say that we have the Infraggable Cronk, and his meta attributes are as such:

ATK 10
DEF 5
SKL 10
PRY 5

Those are his starting, meta stats. What this also means, though, is that, if you spend 10 GP on raising DEF, you get 1 DEF back. But if you spend 10 GP raising ATK, you get 2 ATK back. The idea is to incentivize the player to conform to the character's meta. You get more of a return for raising the attributes that this unit is supposed to specialize in, and we can see what attributes the unit is supposed to specialize in by looking at their 'meta' or 'level 1' attributes.

This is kind of how Pokemon works and other CLASSIC (and I mean OLD) JRPGs work when it comes to leveling up. In some of these old-ass games, when you level from 1 to 2, you just get your level 1 attributes AGAIN -- and every time you level up, you get your level 1 attributes added to your current attributes. This is how you design a character's percentage splay of attributes across all of their stats: you use their level 1 attributes as a guideline.

So, the way that this relates to 'equipment' is that whatever gear you put onto a unit will augment its META ATTRIBUTES. Therefore, not only does it change their attributes, but it re-incentivizes you to level up certain attributes insofar as spending GP. This would allow you to take a character specializing in ONE ROLE and make them a little bit more suitable for ANOTHER ROLE.

Also, we've been tossing around the idea of having the GEAR SLOT be the determining factor for the unit's TERTIARY ABILITY POOL.

Maybe units inherently only have TWO ability pools: their primary and their secondary. And the TERTIARY POOL can be effectively ANYTHING that you have the gear for.

Also, there was some talk about having this piece of gear bring in its own DYNAMIC.

This is a lot of "there's been talk about," but we gotta start nailing shit DOWN. Does our game even HAVE gear? Does it NEED gear? Does gear make things MORE INTERESTING or LESS interesting?

Let's talk about how it could hypothetically make our game LESS INTERESTING.

If gear augments your meta attributes and especially if it does that AND define your tertiary ability pool, maybe that's too much flexibility for a single unit to have? I mean, that could really change the function of a unit.

But the thing about that argument is, no, it really couldn't. A slight change to your meta-attributes and the INTENTIONALLY INSIGNIFICANT IMPACT OF TERTIARY ABILITIES means that maybe it's PERFECT for letting players pick their own.

Because TERTIARY ABILITIES are meant to have an IMPACT on battle and to come in clutch SITUATIONALLY, but them being so far removed from the bread-and-butter abilities, I feel like it wouldn't really diminish the decision of which units you pick if you could affect their tertiary ability pool with this piece of gear. It could just be a net gain insofar as the extra interest that could come from the player augmenting an existing unit with these new features.

So here's a question that comes to my mind, as I describe these pieces of 'gear': should their functionality BE UNIFORM?

I almost feel like it would be more interesting if it WASN'T.

What if some gear doesn't provide a tertiary class, but provides a Dynamic instead. What if other gear doesn't provide either a tertiary class or a dynamic but just augments your attributes by a greater amount.

What if a piece of gear did ALL THREE but just in a very minor way.

Also, speaking in the sense of PVP (which is now the ONLY aspect of our game), how does the player ACQUIRE this gear? Where does it come from?

Before we go on any further, let's revisit the question: does this mechanic add anything to our game?

One more time, repeating myself, let's examine the MERIT of having gear in the game -- and that merit is pretty simple: it allows you an otherwise extraordinary bit of customization of an individual unit.

It allows you to take a unit that was designed to be good at one or two things and maybe add something else that it could be decent at.

It's just one more way for you to customize a unit.

But here's a question: SUPPOSIGN THERE IS NO 1-PLAYER GAME (and there's not), HOW DOES EQUIPPING A PIECE OF GEAR FOR A UNIT ON YOUR DECK FACTOR OUT TO BEING MORE INTERESTING THAN JUST SPENDING GP TO CUSTOMIZE YOUR UNIT'S ATTRIBUTES.

Well, right away, one difference is that, as stated, equipping gear CHANGES YOUR META-ATTRIBUTES, so it actually changes the RETURN ON INVESTMENT you get when spending your GP. Also, supposing that gear CAN bring an additional Dynamic Rule into battle, that's something that you just can't buy with GP.

First of all, let me lock this in: I kinda like the idea of 'equipping' something onto a unit which changes their meta-attributes. I think that makes customizing their attributes with GP, later, more interesting. One way or another, I think that it makes sense to augment a unit's meta-attributes before you start leveling them up with GP.

Second of all, it kinda makes sense to me that you should be able to exercise control over your units' tertiary ability pool... but should units INHERENTLY have a tertiary ability pool, and then this 'equipment' REPLACES it. Or maybe it just ADDS A SECONDARY TERTIARY ABILITY POOL. I mean, these abilities are so SITUATIONAL that it certainly wouldn't be game-breaking to allow a unit to pick tertiary abilities, for their tertiary-equip-slots, from more than one pool.

But THAT OPENS UP SO MANY DOORS. What if, HYPOTHETICALLY -- and this could stand be game-breaking -- but what if there was gear that could give you a second SECONDARY ability pool? or PRIMARY? Or what if there was gear that could upgrade your tertiary ability pool into a secondary one?

Third of all, if you can exercise control over what dynamics your unit brings into battle, would that REPLACE their old unit-dynamic, or add a new one?

All these questions.

BUT PERHAPS THE MOST IMPORTANT QUESTION REGARDING GEAR, BEFORE WE GO ANY FURTHER: HOW YA GET IT? How ya get gear.

Where does it come from. Are we back on this 'lootbox'esque' idea where we have some persistent inventory that grows BEYOND the stage of a single war.

I want to point out that, right now, our game, has literally NO ACCOUNT SAVING, STEVE. That's kind of crazy to think about, but, right now, it's an entirely multiplayer COMPETITIVE experience where two players pick 10 units from our ENTIRE COLLECTION OF UNITS and then use some budget of points to customize that deck and then battle with that deck.

So, basically, outside of saving 'loadouts' or 'decks' to be used repeatedly, the player isn't earning anything that's kept between battles. As of right now, they're not catching new MONSTERS. They're not unlocking new ABILITIES. They're not leveling anybody UP. And, pertinent to this concern in particular, as of right now, they're not earning any gear or anything.

Everything that you can customize is available to every player, equally, through the meta.

Let's not kid ourselves: being able to earn new stuff that you can then use in future fights is a primary motivating factor for playing games like this. It'd probably do a lot for our gamer-base if they COULD capture units -- if the units they could use were the units they'd somehow earned. Same with gear. Maybe same with abilities (dixx and I were talking about this earlier).

Does that make the game UNFAIR in some way? Maybe not, as long as they're not LEVELING UP MONSTERS. As long as all of the gear is balanced against one another, all that it really means is that, whatever you do end up earning can afford you more TACTICAL OPTIONS IN YOUR NEXT BATTLE. So, the players that have been playing the LONGEST, in this example, would have the most TACTICAL FLEXIBILITY, where-as players that are just starting off would sort of need to play with what they have -- but, in terms of LINEAR FIREPOWER, longer-term players aren't at any advantage. They just have more options with their deck-building -- which would, honestly, correlate directly to more wins against newer players -- but, you know... you unlock things even if you lose. Starting players can get there.

Before we wrap up for the night, let's examine our OPTIONS for how you would get a hold of this gear to equip on your units.

I.) Perhaps most obvious and most in-line with our current mechanisms would be that you're afforded a certain BUDGET of currency and you use THAT to buy equipment. That's option #1. I don't like that. It just doesn't seem like it would work for equipment.

II.) Somehow (????) this gear is earned by or between PVP battles and it's saved to the account (the first of such 'acquisitions' that we've talked about) and then, having earned or otherwise acquired this gear, you can now equip it for future decks.

Neither of these options is especially attractive to me. There's gotta be a better way.

Like, I feel like the FIRST OPTION is worse. I don't think that you can give a player a budget and let them pick from any of the gear in the whole game. That doesn't make sense -- especially if every unit is going to have a piece of gear. Maybe they don't all have a piece of gear -- but even then, how do you choose how to spend your currency? Gear is just too dynamic of a factor to make someone choose BETWEEN THEM with some limited currency. Like... some being more expensive than others? Doesn't make any sense.

Our options then become let the player EARN and SAVE their gear for future decks, or just give them ALL of the gear like we're currently doing for units and make them pick between what gear they use, on who.

But maybe we could partially answer this question if we were also to answer the burning question of HOW DOES A PLAYER ACQUIRE NEW UNITS. We've just been assuming that every player has access to every unit, but that's kinda wack. I like the idea more where units are 'caught' or 'collected,' like Pokemon -- but in an entirely PVP-centric game with no singleplayer element, I'm not immediately accosted by a gang of ideas on how exactly that should work.

Well let's first of all examine some PITFALLS. Things to AVOID. Things that don't make sense.

This is, at least at first, going to be an entirely PVP-centric, tactical competitive game played by an EXTREMELY SMALL POOL OF PLAYERS. EXTREMELY SMALL. IF IT'S EVEN PLAYED BY TWO DIFFERENT PEOPLE. Therefore, whatever solution that we come up with 'earning' stuff needs to scale well from a very, very, very small audience (of two people) up to an arbitrarily large number.

This is one reason that I'm skeptical about 'rewarding' the player for something like 'wins,' because I feel like beating an opponent in a beta-testing environment where neither player is necessarily trying their hardest to win -- that's cheating, it doesn't make sense. You can't reward them for that.

My question is, is there something else that we can look at and reward the player? Steve's suggestion, right away I'm sure, is that we could REWARD the player for giving us MONEY. That's totally independent from 'winning' or 'losing' or performance in general.

Maybe both the winner and the loser get some amount of points -- some amount of reward -- but the winner gets a bit more, and then we're rewarding the player for PLAYING. But then you might as well just have some kind of auto-play script which just plays all day to farm points.

It just seems like, in a PVP-centric game, the ONLY way to effectively reward players is to have an established install-base of competitive players who are all guaranteed to be trying to win.

So that's one reason why it makes sense, for the alpha and beta-testing and perhaps beyond, to just GIVE EVERYONE EVERYTHING from the git-go. And then you just play with the stuff.

This question is just too broad for us to answer, today. Let's sleep on it. Here's the question that we're sleeping on:

We want for the player to be able to earn new units, new equipment, and maybe even new abilities. How do they earn this stuff?

I almost feel like there HAS TO BE SOME SINGLE-PLAYER ASPECT, even if it's something goddamn trivial like some Neopets mini-game shit. Just... there has to be SOMETHING. INTERESTING. THAT THE PLAYER CAN DO TO EARN STUFF.

Match wins SHOULD be rewarded. We gotta assume that people are playing fair -- because, if we're talking about ideas that SCALE, when you assume that you have a large player-base of actually competitive players who are competing for rewards, yeah, you reward them with stuff. It's just that, at a low level, with 10 guys as an OPTIMSTIC ESTIMATE -- making it fun for those TEN GUYS... I kind of feel like rewarding wins is kind of not gonna work.

Dixx points out that the loser could get robbed ("like Pokemon"), and, although that's funny, it's also kind of profound -- one thing we haven't examined is that the LOSER could be PUNISHED for losing by just as much or nearly as much or, hell, worse, than the guy who wins. That way, you just won't see people farming each other for wins, to cheat.

I've always sort of been attracted to the idea of Triple Triad (FFVIII), where the loser has to give one or more of their cards to the winner. This is also a mechanic in marbles and pogs.

When you rob a loser, you gotta be careful, because that can be seen as being not very fun and it can be a huge incentive to quit playing. But I think the CORE of the idea is solid: that the loser loses something. That adds a lot more balance, I think.

Steve's question is extremely valid regarding "does the player who's behind have an incentive to keep playing," and the answer to that is that we need some kind of comeback mechanic -- in the sense that, if some player's resources get too low, we gotta bring it up. There's gotta be a minimum. Like, if we go the triple-triad route (and I doubt we will) where the loser has to surrender one of their units from their deck or something, we gotta give the losing player a random unit if they fall too low or something like that so that they always have enough to make a deck that's at least competitive.

4.) For being a monster-catching game, we haven't really talked at all
    about exactly how monsters are going to be caught. What's the monster-
    catching mechanism like? Maybe it's dependent on theme, and that's why
    we haven't touched it?

5.) How permanent is permadeath? What really happens when a unit runs out
    of LP?

6.) Do leaders need attributes like HP? MP? ATK, DEF? SKL, PRY? We gotta
    talk about Leaders.
A.) I love the idea of leaders having MP, right? They already have abilities which cost AP and which may be unique to each Leader, such as the ability to somewhat 'heal' a particular unit or something like that. Why not give them MP that gives them a limited amount of resources to use certain, powerful abilities...? The only reason not to would be SIMPLIFY a game which already has a LOT OF MECHANICS GOING ON. Maybe the question is worth asking: do leaders NEED MP? Not, "would it be cool if they had MP," but rather, "do leaders really NEED MP?"

If they had MP, what would they use it for? The purpose is MP is to give units a limit to how much they can use certain abilities. Maybe leaders don't need MP because they don't really have that MANY abilities. Yeah, they might have ONE special ability or even TWO special abilities -- but, them being so limited, maybe it doesn't make sense to have this 'MP' limit where they have to say, "Do I want to use THIS five times? Or THIS two times?" Because they just don't have that many abilities to choose from.

Let's be clear: the abilities that a player is using on a given turn are MEANT TO BE THE ABILITIES OF THE UNIT IN THE RING. That's what makes the choice of who is in the ring SIGNIFICANT. You don't want for the player to be over-relying on these 'Leader Abilities'. They should really only be used in EMERGENCIES (maybe you need emergency healing) or to burn 1 or 2 AP that you have left at the end of your turn when your unit doesn't have any abilities that cost less than 3AP.

In other words, Leader abilities need to be SHITTY to make up for the fact that they can be used AT ANY TIME, REGARDLESS OF WHAT UNIT IS IN THE RING.

So, if you look at things that way, maybe we see that leaders don't need a lot of attributes: maybe they DON'T need MP, because they don't have enough interesting abilities to choose between that MP becomes an intresting mechanic. They also probably don't need ATK, DEF, SKL, or PRY, because they're not going to be directly attacking the enemy team in any serious, dynamic capacity.

That leaves one MAJOR question: should leaders have HP?

So, the answer to this question has everything to do with HOW WE WANT FOR OUR BATTLES TO PLAY OUT, TACTICALLY, ESPECIALLY RELATING TO THE END OF BATTLE.

We have two options:

I.) Traditional JRPG combat, including the Pokemon system. There is no over-arching, invisible 'leader' that's a part of the battle, and combat ends when all of the units on the field have been KO'd.

II.) Yugi-oh-oh-hhhh! combat, where all of the monsters and units, etc., are on the field to PROTECT the 'leader' or the 'wizard' or the 'caster,' and when there are no units on the field to protect the wizard or leader, the leader takes direct damage and the fight only ends when the leader has lost all of his HP.

One thing that I find really attractive about giving the leader HP and ending the fight when the leader's HP reaches 'zero' is that it adds another win condition, which I think adds depth to our game. It's one more win-condition for an aggressive player to PURSUE, and it's one more win-condition for a defensive player to AVOID.

So, for instance, our game has an 'LP' system for that very reason. There are MULTIPLE LEVELS of 'defeating' a unit. You can lower its HP to zero, which knocks it out but it can be revived, or you can lower its LP to zero, which knocks it out of the fight entirely. I love that, on top of protecting a unit's HP, you also have to consider it's LP. I love that there will be times where your HP is FULL, but your LP is down to 1, so you can't afford to get knocked out, again, and you might just get one-shotted by an ability which deals LP damage directly. So, there's multiple win-conditions, so to speak.

If we were to give leaders an HP value, it's sort of like having this extra value in th background which is EVEN MORE DIRE THAN LP. It's this value that, once it reaches zero, the fight is over.

But this raises some questions that absolutely have to be answered, especially when you're considering the types of tactics that players will end up choosing between and employing.

First of all, HOW DO YOU DO HP DAMAGE TO THE LEADER. In a game like this, where units take turns in the ring, doesn't it stand to reason that the only way that a player could be directly damaged would be if ALL OF THEIR UNITS WERE DEFEATED, in which case the leader would have NO WAY TO DEFEND HIMSELF, and therefore the fight IS EFFECTIVELY ALREADY OVER. In other words, we've just recreated the 'Pokemon' mechanic, where, once all of your units are dead, the fight is over. Now we're just wasting this extra time, at the end, where the enemy team does a victory lap by bodying the fuck out of your leader.

So, we would need to come up with some creative mechanisms that would allow the enemy team to directly damage your leader before all of your units are down. What sorts of mechanics would support this?

If you have Leader HP, and the goal of the fight is to reduce the leader's HP to zero, HOW DO YOU DAMAGE THAT HP, and HOW CAN YOU PREVENT YOUR LEADER'S HP FROM BEING DAMAGED.

First idea: what if you CANNOT SWAP UNITS UNTIL YOUR NEXT TURN. We know that, in our AP-based system, a team can attack more than once per turn. If your unit in the ring is knocked out on the enemy's first ability, maybe the enemy can use their remaining AP on that turn to directly attack your leader. Once your next turn starts, you choose a unit to bring into the ring.

Neon's idea: special, RARE abilities which directly attack the leader's HP or special abilities (or rules) which bleed damage to the leader. This makes a constructive parallel with our game's 'LP' system, where most abilities in the game are just going to deal HP damage, and, yeah, units always lose 1 LP when they get knocked out, but some rare attacks will attack LP directly or bleed into LP damage. It kinda makes sense that leader HP would work similarly, since it is sort of a parellel of LP.

My question is, if leaders do not have a DEF value, how do we know how much damage they take from a unit that's attacking them?

My solution: units don't ever attack leaders using their regular abilities. Instead, when my unit in the ring is DOWN, my opponent can choose HOW MUCH AP TO SPEND ON A LEADER-ATTACK. I take damage equal to the amount of AP that my opponent spends attacking me.

If I have a wounded unit in the ring and my opponent expends 4 of their 10 AP to knock out my unit, they know have 6 AP that they can choose to use to lower my leader HP by 6.

Or, they can use 3 AP to lower my HP by 3, and then they can use the remaining 3 AP to do something else (heal one of their units, etc.)

This makes sense to me for a variety of reasons. It allows you to set the leader HP to a LOWER value, which means that it's more like LP. It means that you could have rare abilities, as with Neon's idea, where maybe, if this ability crits, it does 1 damage to the leader. Or it has some insane MP cost but it does 1 damage to the leader.

This idea also means that a player has to CHOOSE between taking this opportunity to ATTACK THE ENEMY LEADER or to SUPPORT THEIR OWN TEAM. Yeah, I just knocked out your unit in the ring. I have 6 AP remaining. If I'm feeling HUNGRY, I can expend that AP to reduce your HP and get closer to the battle's ultimate win condition. However, this would almost certainly also be a good time for me to HEAL MY OWN UNITS, or BUFF MY OWN UNITS, or NERF THE ENEMY TEAM. Especially because, at the start of YOUR NEXT TURN, you're going to be able to SWAP A UNIT IN FOR FREE, which is very rare in our game.

As you guys know, it costs 3 AP (1/3rd of your turn) to swap a unit in. When a unit is KO'd, however, that team can swap a unit in, for free, on their next turn. That could give them a lot of comeback potential where now they have 10 AP to spend on this one unit's abilities. So, I have to choose between preparing for THAT or attacking the enemy leader -- or, probably more commonly, I have to compromise. I might heal a unit, make a swap, and then spend 1 or 2 AP to attack the enemy leader.

I like these solutions, but I have one more question regarding this SITUATION IN OUR GAME.

We've discussed the possibility that DOWNED UNITS MIGHT BE VULNERABLE TO ATTACK. In Saga Fronter 2, I believe (which I wanna play on stream soon), when a unit is knocked out, it can still be targeted for attack, and each attack that it takes reduces it LP by 1.

We talked about having this mechanic in our game. In particular, we talked about implementing a system where, when prompted to swap a knocked-out unit out of the ring, a player could ACTUALLY DECLINE and say, "nah, leave that fucker in there."

If the player declines to swap in a unit, the unit left in the ring will be vulnerable to potentially lots of LP damage. The upside would be that certain DYNAMIC RULES that may be taking effect OVER THE COURSE OF SOME TURNS may actually benefit you to just let them ROCK while your party remains safe, hiding behind the corpse of their homie.

By leaving a knocked-out unit in the ring, it means that you don't need to swap in another unit, which means that none of your units are vulnerable (except for the knocked-out one). The two downsides would be that, again, the unit in the ring would be subject to a LOT of LP damage. But, also, you have nothing to spend AP on -- you can't use any of your units' abilities.

So, is this a feature that makes sense?

Do we want for units to be targetable while they're down to lose LP? In many ways, I feel like that just doesn't make sense.

Like, for instance, if we calculate LP loss as, "Every time they get hit, they lose 1 LP," then some 'machine gun blow' move which does 1 HP of damage 10 times would insta-kill a downed opponent.

I think we just need to write this idea off. When your unit is downed, for one thing, you shouldn't be able to choose if it stays in the ring, and it shouldn't be subject to attack.

So, to summarize: when your unit in the ring is knocked out, the opposing team can choose to spend their remaining AP to directly attack your leader's HP. Also, as with LP, some rare attacks, with high cost, may directly target leader HP or may have a rare chance of dealing HP damage to a leader.

This raises a question: how is leader HP going to factor in to the PVP element.

An idea that I recently had for the PVP element is that it doesn't take place over the course of a SINGLE BATTLE. Rather, it takes place until all units on one DECK have been knocked out of the fight.

So, this raises the question: what happens if a battle ends before all of the units on the losing team have been knocked out, because the leader's HP was attacked directly?

And the answer that I think would be cool: what if we look at battles as ROUNDS in a fighting game, of sorts, and maybe you don't fight until an entire DECK IS DEAD. Maybe you fight until some number of battles or 'rounds' are won.

For instance, you could have a two-round-victory condition where you need to win two battles out of three. Or you could have a three-round-victory endurance match.

An alternate condition for victory, instead of winning all of your rounds, would be to kill all of the units on the enemy deck.

The players could agree, beforehand, on how many battle wins it takes to win the match. And, as long as the battle is ongoing, the player can starting new battles, but their units' EXHAUSTION is going up and their LP is probably going down.

So, the players could decide whether they want to do an ENDURANCE MATCH where dwindling LP and rising Exhaustion would be more of a factor, or they can just do a quick one-off or two-off war, where LP and Endurance will probably hardly come into play.

7.) What does 'exhaustion' and LP restoration really mean for PVP? For
    single-player?

8.) Review the limits of Dynamic Rules to target units and teams that are
    already being targeted.

9.) I also want to talk about inventory.
A.) We've spoken about how a common Leader Ability will be to use items from an inventory. This mirrors Pokemon, where the leader (trainer) can use any item that they own in place of using a Pokemon action from their in-ring unit. In our game, the player would choose between spending their AP on unit-abilities or on leader-abilities or a combination of the two until all of their AP spent, and maybe one of these options is to use an item.

So, what kinds of items do we have? How much do they cost? How useful are they?

Basically, it seems like having a large-enough pool of awesome-enough items could totally negate the need for certain roles on a team -- and maybe that's a good thing.

What jumps out at me right away, about inventories, is that, growing up playing JRPGs, I never fucked with healers because buying potions was so trivial that it freed up a whole party member slot.

That seems broken to me.

If we had items that could temporarily buff our units, maybe that would preclude the need for some kind of support unit.

But, here's the thing about that: maybe it's a GOOD IDEA to allow the player to trade a ROLE for ITEMS, because there is (or should be) an INHERENT LIMITATION TO ITEMS, and that is that... you run out of items! If items COST ENOUGH, we get an interesting risk-reward where a player brings 'x' number of potions into battle, and that means that, if they don't wanna bring a healer in, they're counting on the fact that they're never going to need to heal more than 'x' number of times. So, now we have a team which has some other type of unit in play INSTEAD OF a healer, and they have potions instead. The reward is that they have a freed-up unit slot on their team. The risk is that they have limited use of these potions, so they really gotta budget them.

Therefore, it seems that the INTEREST -- the gameplay interest -- inherent to having an INVENTORY is dependent on the COST or the LIMITATIONS of this inventory.

So, it stands to reason that we could have items which could HEAL HP. Could REVIVE UNITS. Could DAMAGE UNITS. Could PUT CERTAIN RULES INTO PLAY. Basically, an item could do anything that an ability could do, but with a limited usage -- limited by how many of that item you have.

So, what are the dangers -- the game-design pitfalls -- of including a mechanic like this.

Like I said above, items could be too easy to acquire, which would make individual units and team composition less important.

Items can be too DIFFICULT to acquire, which means that nobody ever wants to use them.

In particular, it sounds like items could replace Leader Abilities in many respects, because, like leader abilities, they behave as normal abilities but can be used on any turn. That makes them very powerful (if they aren't limited by how many you have).

So, they're basically limited-use Leader Abilities. Limited to what scale? Per battle? Per dungeon? Per EVER (truly consumed)?

A theme of our game-design, so far, is RESTORING STATE AFTER BATTLE. Units get all of their HP and MP and other attributes (aside from LP and exhaustion) back, entirely, after battle. Should we also restore items after battle? Maybe the player picks 5 items, or so, to bring from their pack -- and they get one use of each item, per battle? That could be tactically interesting.

That's basically what we're talking about in the PVP side of things, so why wouldn't it behave the same way in the 1-player experience.

Although, we need to decide if these item-uses in PVP are per-battle or per-war. We've talked about how PVP in our game will mostly consist of MORE THAN ONE BATTLE. It's, like, best-of-three or best-of-five or more. So, if you spend points on items for your PVP build, should they be PER-BATTLE or PER-WAR?

Right away, my gut says "per battle," because the other things that you're spending your points on are per-battle. Because, your team's HP and MP are restoring between fights. So, maybe it makes sense that the items that you buy should be a persistent part of your strategy and therefore be restored at the end of every battle.

On the other hand, AS ALWAYS, we can make these decisions carry more WEIGHT if their consequences are felt in the longer-term. Do you want to spend this potion NOW or do you want to save it for when you might really need it in the next fight?

To answer that question, we again can turn to other design decisions we've made so far:

The reason that we restore HP and MP completely between fights so that the player is encouraged to play RISKIER. To play FASTER and LOOSER, because they know that these resources that they're burning are going to come back.

This is a fairly new concept in JRPGs, and what I found, growing up, playing classic JRPGs, was that the OBFUSCATED NATURE of WHAT EXACTLY YOU'RE BUDGETING FOR makes it very difficult to spend resources. In the example above, there's just no telling if, in the next few fights, you're going to be in a situation where you need to spend this potion more than you need to spend it now. There's just no telling.

In classic JRPGs, your HP and MP wouldn't auto-restore between fights, and so you had to budget your HP and MP to last you for an entire dungeon.

THE PROBLEM IS THAT YOU DON'T KNOW HOW LONG THIS DUNGEON IS UNTIL YOU'VE ALREADY BEATEN IT.

The result is that, in order to budget for an ARBITRARILY-LONG DUNGEON, the player is encouraged to play HYPER-CONSERVATIVELY and not explore the thrill of the game's resource mechanics. The whole point of having resources is in deciding how and when to spend them. If you don't know what you're budgeting for, you can't make those decisions.

Living by that philosophy, it would make the most sense to give the player an auto-refilling inventory. When deciding on their team -- their 'build' -- they decide how much they want to spend on items and which items they want to buy. THAT'S the budgeting phase.

Now that you're IN A FIGHT, we want for you to SPEND THOSE ITEMS. You choose WHEN you spend them. You don't want to use your ONLY HEALING ITEM too early in the FIGHT because you might have a better use for it BEFORE THE END OF THE FIGHT, but, by not asking the player to budget for ARBITRARY FUTURE ENCOUNTERS, we are LIBERATING THEM to spend these items.

That makes items more interesting. You have to be able to use them. Yes, you want for that to be a tough decision -- and we still have that tough decision. Who do you use the item ON? Is now the best time to use it? But, this way, the player has some idea of the SCALE for which they're budgeting: the course of this encounter.

If items auto-restore for each battle, that makes the problem MORE SIGNIFICANT where items are replacing 'Leader Abilities.' What is the point of a Leader with a Leader Ability to offer a small heal at some AP cost when they could just have two potions, per battle, which auto-restore between battles.

Honestly, maybe we should replace the notion of 'leader abilities' WITH ITEMS. One thing we've struggled with regarding how to balance 'leader abilities' is that the NOTION OF THEM IS INHERENTLY STRONG. They're abilities that you can use on ANY turn, regardless of who's in the ring.

So we've asked ourselves, "How WEAK can we make these abilities?" "How much should they COST?"

Maybe the answer is simple: make them as strong as any other ability in the game. As strong as we want. But they can only be used once per battle, per item that the player has budgeted. Maybe the leader abilities come as the result of these itms that you have.

Also, you can easily parallel the decision of which LEADER TO BRING (previously because you wanted an ability of theirs) for which ITEMS TO BRING. So, they're really parallel, in that respect. Maybe we don't need both Leader Abilities and Items, and, honestly, maybe items are more interesting -- because they solve that problem of, "You can use these abilities on any turn." It's like, YEAH, you CAN use these items on any turn, but only until you run out of items. That adds more weight -- more cost -- to these abilities which would otherwise be godlike.

The only downside is that I kind of liked the idea of 'leader abilities' as being a way to burn loose AP. Like, leaders would have some really cheap abilities which would cost 1 or 2 AP and that would be how you spend your remaining AP if you can't spend it any other way. Some shitty little consolation, like healing a unit by 1% or something like that.

But that raises another idea, as I type that. What if we RE-INTERPRET 'Leader Abilities' as some kind of per-leader PERK which allows you to TRADE AP for some RETURN. Maybe one leader can convert your remaining AP into a heal. Maybe another leader can convert your remaining AP into something else. Maybe, it always being a buff, maybe it just happens AUTOMATICALLY when you end your turn; any remaining AP you have gets processed for some BONUS, and that bonus is unique to each Leader.

I kind of like that more than 'Leader Abilities,' and that frees us up to re-interpret leader abilities as a limited inventory.

Let's not fall for the trap, as we think about inventory, of overly-fixating on the singleplayer experience. That whole idea is just so under-developed that we need to continue looking at things with two players fighting each other in mind.

So, okay. Each unit in your deck has some number of points that it can spend to be customized. Any remaining points can be refunded to buy some items for the leader.

So now, all of your units are customized, and the time has come to spend your remaining points on some items. You're presented with a menu of items to buy. What kinds of decision-making are taking place in this phase?

I.) You're looking at a wide variety of items which have a wide variety of effects.

II.) These items have different costs based on their effectiveness.

II*.) A potion that heals 10 HP should cost less than twice as much as two potions which each heal 5 HP.

II**.) So, basically, you have to choose between buying MORE, VARIED ITEMS or buying higher TIERS of other items.

II***.) This raises the question, WILL YOU EVER HAVE MORE THAN ONE OF AN ITEM -- or would you rather save for a higher tier. As soon as I type that, the answer is obvious -- YES, you sometimes buy MORE THAN ONE OF A SINGLE ITEM because you want to use that item TWICE, either on two different targets or at two different times. You could buy one 10HP potion for LESS than two 5 HP potions, but you'd only be able to heal one unit with it.

III.) It's worth noting that you can choose to cash out EARLY of growing a unit so that you have more currency to spend on items. I don't think that we want for this to be a popular strategy, and so, therefore, it's important that we take a few measures.

III*.) We want for there to be a better RETURN ON INVESTMENT FOR RAISING A CHARACTER than using that same amount of GP on buying an item.

III**.) We want to create INTERESTING SITUATIONS where the player MAY END UP WITH MORE EXTRANEOUS GP. For instance, if the cost of raising some attribute is going UP each time it grows, and none of the other attributes interest the player as much, then they may have more spare GP.
