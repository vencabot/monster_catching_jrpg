It seems that my existing mechanism for implementing Dynamic Rules is somewhat flawed. The idea of having certain BattleEvents become 'neutralized' before they can 'take effect' while still using those same BattleEvents to trigger DynamicRules carriesa paradox: how can you 'undo' the very BattleEvent that triggered you in the first place? That's the problem.

So, in my example, I give dixxucker two different perks that are BOTH triggered by him taking damage. The first perk is 'Sacred Protection' which will UNDO any damage done to him by another Rule. The second perk is 'Rage' which will grant him additional ATK any time that he takes damage.

The issue is that, with both of these perks on him, he will gain ATK without taking damage, because the first rule, Sacred Protection, undoes the damage AFTER its already triggered Rage.

There's a few different ways that I could go about fixing this problem. I've been thinking about it, and, on one hand, I think that this gives us an opportunity to completely do away with the BattleEvent queue system. I think I've devised a better way to handle triggering DynamicRules that doesn't involve iterating through a list of BattleEvents.

But to abstract things, you could say that what I'm proposing is this:

Any time something HAPPENS in the game that could trigger a DynamicRule, it creates a PAIR of 'events', split across two phases: a PRE-EMPTIVE phase where the happening can be PREVENTED or ALTERED, and a REACTIONARY phase, where the happening can be REACTED to.

In the example of the 'Sacred Protection' and 'Rage' conflict, Sacred Protection would be triggered as a part of the PRE-EMPTIVE phase, thus PREVENTING the damage from ever occuring. Then, Rage would be in the REACTIONARY phase, and it would never trigger because there was no damage dealt to react to.

That seems simple-enough, but what I'm actually proposing is doing away with the event queue completely. I had an idea for how we could go about this.

I'm proposing a new type of object which represents a unit attribute that can trigger DynamicRules. For instance, we know that a unit's 'HP', when altered, can trigger any number of DynamicRules.

If HP goes up, it might trigger some DynamicRule.

When HP goes down, it might trigger some DynamicRule.

So, what I'm proposing is that, instead of saving a unit's 'current_hp' as a simple Python integer attribute, what if we saved it as an object like so:

class DynamicIntAttribute:
    def __init__(self, value):
        self.value = value
        self.rules = []

    def alter_value(self, amount):
        for rule in self.rules:
            prevented = rule.check_event(
                    "value_will_be_altered", self, amount)
        # Here's where the problem BEGINS.
        if prevented:
            rule.check_event("value_alteration_prevented", self, amount)
            return
        # Here's where the problem ENDS.
        self.value += amount
        for rule in self.rules:
            rule.check_event("value_altered", self, amount)

Another thing that I'm proposing is that EVERY ACTION in the game trigger rules on two phases: the pre-emptive phase and the reactionary phase. This 'DynamicAttribute' system would streamline that as well, and I'm going to flesh out the example, above, to reflect that.

dixxucker.current_hp.rules.append(SacredProtection(dixxucker))

A problem we're gonna have, with this, is recursive depth. The problem is, "will all of these events eventually RESOLVE."

If we trigger RAGE, for instance, in the PRE-EMPTIVE phase of dixx's current_hp DynamicIntAttribute being altered. We'll just imagine, for the sake of argument, that the rule is, "If Dixx is targeted for damage, his defense goes up." It raises his defense before he takes damage.

What we end up having is a pre-emptive phase that, itself, triggers another pre-emptive phase before the FIRST alteration can actually take effect. Are we at risk of creating some kind of loop where we are forever stuck in these pre-emptive phases and nothing can ever actually happen.

1.) Vencabot uses Slap on Dixx. Slap calls dixxucker.current_hp.alter_value(-10)

2.) Before the HP reduction actually occurs, dixxucker's 'Rage' is triggered.

3.) Rage calls dixxucker.def.alter_value(3).

4.) If there's a Rule in play that prevents units from gaining DEF, it would
call -- the problem is that the act of PREVENTING THE UNIT FROM GAINING DEF would need, itself, to be an event, in case there's a Rule that prevents another Rule from blocking DEF.

5.) Let's say there's rule called "Diamond Wall," which prevents another Rule from preventing DEF growth. What I'm saying is, the conceptual problem is this: WHEN IS THE UNDERLYING ATTRIBUTE ACTUALLY EVER CHANGED. When are we out of this Hell of asking for permission to do something. When does it actually happen. In this scenario, we're talking about a Rule asking for permission to prevent the effect of another Rule.

6.) Let me rephrase this: with this proposed mechanism, one thing that seems impossible is to PREVENT something from happening in a PRE-EMPTIVE phase. The PRE-EMPTIVE PHASE of an attribute-change is MEANT to PREVENT or alter THAT change. I don't think that you can PREVENT the PREVENTION. If you could, I feel like we might be stuck in a loop of pre-emptive phases where we're constantly checking if anyone is interested in pre-empting the pre-emption of the pre-emption of the pre-emption. That's the thing.

And that seems wack. I don't know if that's feasible considering what we want to accomplish with the DynamicRule system.

Maybe we don't need for preventative Rules to trigger other Rules. Maybe that's just a conceptual limitation of what we're trying to accomplish with this sort of emergent gameplay. Maybe that's just the line: you can't prevent a prevention.

Let's list some situations where it would make sense for a DynamicRule to prevent the prevention caused by another DynamicRule:

If Vencabot uses Slap, Slap does half damage.
^ That's a pre-ventative Rule, because, when Vencabot chooses Slap, it proposes a change to HP at some amount of damage. This Rule is triggered in the pre-emptive phase and sees the amount of damage proposed and prevents it. After that, it proposes a new amount of damage (half as much).

That's a preventative rule.

Would be interesting -- do we need -- Rules of the type that would be like, "Abilities always deal full damage." This would effectively negate the above rule, which, itself, is a preventative rule. It would prevent and preventative. I don't think I could implement that, with this mechanism as it stands.

I don't think, with this mechanism, I could implement Rule like, "Abilities always deal full damage." How would I prevent the first rule, "Soft Slap," from doing its job.

What would need to happen, in this mechanism, would be for the very NEGATION of the effect to, itself, be able to trigger both a PRE-EMPTIVE and REACTION phase. And, if that were possible, WOULD WE BE STUCK FOREVER IN A TIME VORTEX where nothing could ever happen because we were too busy asking for permission for it to happen (a never-ending spiral of PRE-EMPTIVE phases).

Let's break it down: how would the negation of an alteration trigger other rules. How.

I looked at the example above and made a simple alteration that I think fixes the problem. Let me re-phrase my solution like so:

You have an object, "DynamicAttribute". When the player makes a decision that would alter some value in the game, a few things happen:

Before its value changes, that attribute warns all of its listening Rules that it's about to change and gives them a chance to prevent that change and propose their own changes.

If that change is prevented, then it reports this to all Rules that might be interested in that prevention having occured.

if the change ISN'T prevented, the value is altered and listening rules are notified of this.

Even with this solution, there are conceptual weaknesses with the VERY IDEA of DynamicRules. One that Kenny points out is when you have two Rules that use very absolute language:

SacredProtection prevents damage from Rules.
DireRules prevents Rules from being prevented.

I feel like this might NOT be a huge problem, and we would just need to... fall back on the ORDER that the Rules were implemented in. I've been considering this, too: in some cases, perhaps the ORDER of the Rules would be significant when determining their priority, and maybe some classes could alter the order of Rules. But I think that's sensible: in cases where PRIORITY would be a factor, perhaps it's just that the bottom-most Rule takes priority. Whatever would trigger last. And if you don't like, then maybe you could somehow change the order of the Rules to be in your favor. I feel like that might be a solution to the problem of when you have two rules that are in competition.

I THINK that solves the Kenny predicament of the immovable object and the unstoppable force. But another problem that I think we have is how Rules will or won't 'stack'. My fear is that this might require an entirely separate and complex mechanism, in itself, to manage.

For instance, what if we have these two rules in play:

ClassicProtect: the target unit takes 75% damage.

Seems simple.

But then we also have this:

FlubbidityWoo: the target unit takes 50% damage and the attacker takes the other 50%.

How do these stack on the same unit? They both directly influence the amount of damage the unit takes.

The obvious thing would be to just have them stack. Vencabot he would've taken 10 damage, but ClassicProtect caused him to take 7.5 instead. But flubbitywoo is triggered, which causes him to take HALF of that damage and his opponent takes half: they both take 3.75 damage.

That makes sense MECHANICALLY. Although it makes sense mechanically, I'm not convinced at all that it makes sense in terms of GAMEPLAY BALANCE. Because, the core gimmick of our game -- the heart of all of the strategy -- comes from the interaction of different Rules and teams playing within these rules. That being the case, I don't think it would be unusual for these two Rules to end up on the same unit. Maybe even more Rules that affect the damage that unit takes. I think it'd be trivial to build a team that could put four rules into play that all lower the amount of damage that Vencabot takes.

I feel like, if we don't have some kind of mechanism that prevents too many rules from stacking on a single unit, it'd be trivial to make that unit super over-powered very quickly.

Let's say you had three different rules, like so:

ClassicProtect
FlibbityWoo
Dispersion: The targeted unit takes 50% damage and his teammates get the remainder split among them.

That makes sense. It's fun. The problem is that, that same unit could have two other fucking rules on them that reduce their damage by 50%. That are also, in isolation, fun and interesting. But combined, it just breaks the game.

This is what I was thinking about earlier, in the shower, which coincides directly with KG's recommendation that we 'tag' certain Rules. Like, the 'tag' would somehow influence the way that they stack with each other -- or don't stack. Maybe some Rules simply OVERRIDE other rules. Maybe they can interact but with some special stacking algorithm. Maybe others just stack outright, like we demonstrated above. But, again, my fear is that we're talking about having to implement a whole separate mechanism -- be it tag-based or whatever -- to balance the interactions between certain Rules to prevent their COMBINATION from being too powerful.

You could abstract the problem like this: it's hard to make Rules that are exciting and interesting in isolation without making them completely broken in certain, VERY SIMPLE combinations. It seems we would need some kind of way to influence how certain rules stack with each other.

That's something that we're going to probably need to sleep on.

I think, for today, I'm mostly happy with this 'DynamicAttribute' idea, where Rules are triggered on TWO phases whenever an attribute of certain objects is altered. That makes sense to me, and I don't think that it would result in any infinite-loop problems, as long as we stick with the idea of a 'recurrence limit' on Rules.

You could argument that a rule that both 'buffs' and 'debuffs' a character could be split into literally both of those things: it adds 1 buff and it adds 1 debuff. But what about 'debuffs' that are like, "if MutantXP takes damage while in the back row, whoever's in the ring takes that damage for him." Which character gets that buff? Or is it debuff? If it's for whoever's in the ring, does it count toward their debuff limit? What happens when they're not in the ring anymore?

For this reason, I've sort of been straying away from using terminology like 'buff' and 'debuff.' And that's ONE MORE THING that makes it difficult when talking about how these Rules are going to stack and otherwise negotiate with each other to make the game more balanced.

It's like, you have these Rules which, in isolation, don't debalance the game -- but when you start applying more of them, they game can get unbalanced real quick. And not in a super-strategic way where there's a reasonable counter-play. We're talking about, just some broken-ass shit.

It sounds like what Kenny is saying is that every rule in the game would apply to all units equally.

Here's our final note: on Thursday, I'm going to mock-up our current encounter but using the new DynamicAttribute system that I devised above, and we're gonna see if it works. Supposing that it works (I expect that it will), I think that we will be free to create any Rule that we can imagine and have it work like we expect.

That would be a huge accomplishment.

IF that works, we should definitely move on to figuring out how to balance Rules against each other so that they can't very easily make some super broken combinations. I feel like KG's recommendation that we tag Rules in a certain way to determine how they stack might be the key -- but whatever the solution ends up being, I don't think that it behooves us to worry about that right now. I'm gonna get Rules working so that they're flexible, interesting, exciting, and powerful -- and if we can get that working, then we'll worry about how to balance them.




03/21/19

Roadmap for today's stream:

I want to get our original example, which does NOT work, working in a newly designed DynamicRule system which relies NOT on a queue of 'event' objects but rather on callbacks that are associated with DynamicAttribute objects, which call their callbacks whenever anything changes.

Let's get going.

How are phases supposed to work, again?

Before a change is made to any attribute, we WARN the rules that this is gonna happen. That way, the rules can PREVENT this from happening.

AFTER an attribute changes, we ALSO report this to all of the rules so that they can react.

So, DynamicAttributes need TWO lists of rules, right? They need a list for pre-emptive rules and reactionary rules.

Can we agree that pre-empting is only for preventing an event from happening? I would say yeah, right? Yeah.

Should more than one rule be able to prevent a single event? No. Only the first rule to prevent the event should be triggered.



WELL, IT WORKED, but I'm not super confident in it. I wish I had more time to test it, but we're already more than half-an-hour late for 3rd Strike.

That means that, next week, our first order of business is to review the code that we just wrote and figure out how it works. We could probably use some documentation, better function and attribute names, etc. Because I'm not super confident in my own understanding of exactly all of the mechanisms that we're working with in this relatively simple example. But it seems to work.




03/25/19

We have a very minor bug in our code regarding order-of-operations (which is always the trickiest thing about this system).

If GoodVibe's 'Hench' rule is applied BEFORE Vencabot's 'Invincible' rule, things behave in a way that makes sense to the player (and to the developer): when GoodVibe attacks Vencabot, the damage he would've dealt is doubled, but he can't do damage to Vencabot because he's invincible.

The problem is this: if Vencabot's 'Invincible' rule is applied BEFORE GoodVibe's 'Hench' rule, GoodVibe will not get Hench when attacking Vencabot.

The end result is the same: Vencabot doesn't take damage.

The difference is that, if GoodVibe is going to do damage to Vencabot, all of the Rules that are triggered in this situation are checked in-order. if GoodVibe is going to do damage to Vencabot, 'Invincible' prevents this, neutralizing the event.

BUT ALSO, if GoodVibe is going to do damage to Vencabot, 'Hench' neutralizes the event and then creates a new event to deal double damage.

So, if Hench is applied first, it neutralizes the FIRST damage event and then creates a NEW damage event. And then Invincible neutralizes that SECOND damage event.

However, if Invincible is applied first, it neutralizes the FIRST damage event, and then there's no damage event to trigger Hench.

The problem is, conceptually, abstractly, the player (and the developer) would expect for GoodVibe's 'Hench' to be triggered regardless of whether Vencabot is invincible or not. Either way, Vencabot's not taking any damage -- but GoodVibe should still OUTPUT that double-damage.

Now, obviously, we could phrase 'Hench' in such a way that our existing mechanism makes sense, and maybe that's just gonna have to be the limit, here:

"When GoodVibe deals damage, it's doubled."

It's clear from that definition of Hench that it wouldn't trigger if Vencabot was Invincible, because GoodVibe wouldn't have dealt damage.

But is there a way to make this work in a more intuitive way.

Let's make a new way for Hench to behave. In fact, let's call it something different. Let's make a new Rule just to demonstrate our problem.

What the player expects from 'BloodLust' is that, whenever GoodVibe attacks, he gets attack power.

But the reality is that, when GoodVibe HAS AN ACTIVE DAMAGE EVENT, he gets attack power.

So this can behave a bit unintuitively if his DAMAGE EVENT is PREVENTED before 'BloodLust' can trigger.

Panders brings up a point that may very well be key to our solution, and that's to create another phase. So much of the difficulty we've had has been in the ORDER OF OPERATIONS of our Rules, and the solution has often been to create ANOTHER PHASE for rules to be triggered on. That helps to make it more explicit WHEN rules should be run.

The problem we have, with this NEW system in particular, is that Rules are always triggered WHEN AN ATTRIBUTE HAS CHANGED.

So, when GoodVibe SELECTS an attack, we can't trigger a Rule, because no attributes have been changed, yet.

When goodvibe CHOOSES to attack, nothing has happened for us to react to in terms of an attribute being raised or lowered.

The idea was that we would know that Goodvibe chose to attack because the game reacts to him wanting to LOWER someone's HP.

The HP attribute is being manipulated, and THAT'S what triggers the rule.

The problem is that this CHANGE can be PREVENTED. That's the whole point of the 'pre-attribute-change' phase.

Basically, the way our system works, guys, is that, whenever a unit's attribute -- such as their HP -- is being manipulated, it triggers rules on 3 different phases:

1.) Before the change is made to HP, we ask every rule if they want to prevent that change.

2.) If that change IS prevented, we notify all of our rules that the change was prevented. This might trigger other Rules that may only happen if a another rule takes affect.

3.) If that change is NOT prevented, then we actually implement the change (HP is reduced) and then we notify all of our Rules of the change, in case they want to react to the DAMAGE HAVING BEEN DONE.

We've been through a few different solutions for this 'dynamic rule system,' and the problems always occur when we talk about PREVENTING things from happening before they happen.

So much trouble comes from the fact that we NEED for a PROPOSAL to TRIGGER rules so that they can PREVENT that thing from happening (such as Invincibility).

However, when that thing is prevented from happening, it prevents other Rules from being triggered that would have ALSO prevented that thing from happening.

Our problem here is, with Hench and Invincible, we have TWO RULES that want to prevent damage from happening. Whichever Rule is implemented FIRST will PREVENT the damage from happening, and, therefore, the second Rule will not trigger.

Now, if you're not keeping up with the programming and behind-the-scenes stuff, you might be asking: how does 'Hench' prevent damage. It doubles damage. It doesn't prevent it.

But what happens, internally, is that Hench is triggered by GoodVibe wanting to do 5 damage. THAT DAMAGE IS PREVENTED and Hench creates a NEW EVENT to do 10 damage.

So, if Hench is BEFORE Invincible, then Hench will PREVENT the first damage, which also prevents Invincible from triggering (since it needs a damage event to pre-empt). Then, hench creates a SECOND damage event, which DOES trigger Invincible.

In other words, if Hench is first, then things behave as we expect: GoodVibe chooses to attack, he gets all buff, and then he hits Vencabot really hard with a hench'ed up attack that doesn't do damage because Vencabot is invincible.

ON THE OTHER HAND, if Invincible is first, then it prevents the initial damage from being done -- and since Hench checks AFTER that, it never sees that GoodVibe was doing an attack and, therefore, he never henches out.

This would be kind of solved if GoodVibe could get henched out before even proposing to do HP damage.

Like, if he chooses an attack, then he gets hench.

The problem with this is that it makes the 'damage multiplier' aspect of the Rule a lot dirtier. Because, at this point, before we deal damage, how do we know how to 'double' his damage. The only way I can think of would be to give each unit some kind of 'attack multiplier' attribute, which is sub-ideal. Just adds more complexity. I like the way it works now: when a unit is gonna deal damage, they can see how much damage they're gonna do and we can boost that.

BUT THERE'S ANOTHER PROBLEM. The problem is that, if we have a Rule that says, "When Vencabot chooses to Slap, his ATK goes up," we can currently only have his ATK go up AFTER he slaps and gets damage calculation.

We can't request a new damage calculation with Vencabot's newly-raised attack power. We could do that if we could catch 'slap' before it happens and then raise his attack power and re-slap.

It also strikes me, as I say this out loud, that, if we ONLY TRIGGER RULES BASED ON ATTRIBUTES CHANGING, which is our current system, we can NOT have certain rules trigger when a unit chooses to use a certain move, or a move from a certain class, or anything like that -- which could make for some very reasonable and interesting rules.

Because, there's no indication, in the DynamicEvent, of what Skill was used. We only know that a target unit had an attribute changed by a perpetrator.

But that's not a problem because 'perpetrator' can be a RULE (not just a unit), and I don't see why it couldn't be a SKILL. Perpetrator can be a skill, and then we can use that Skill's 'owner' attribute to figure out what the perpetrating unit is. Then we'll know what skill they were trying to use and we can use that as part of our checks for the rule.

The problem is a problem of ORDER. Order of operations. Especially when we're talking about PREVENTING or NEUTRALIZING or CANCELING things from happening before they happen. That's the problem.

How can you PREVENT something from happening, but make sure that all of the Rules that would have prevented it all get their chance to trigger.

The obvious thing would be to run that 'prevented' event through ALL of the rules that would've prevented it and only prevent the change from happening after that.

The problem with that is the RECURRENCE LIMIT. Let's say that 'Invincible' can only occur once per event phase. If Invincible triggers when GoodVibe tries to do damage to Vencabot, we COULD VERY WELL SAY, "that event is now prevented. However, continue to check other rules that would have been triggered."

That would seemingly solve our problem. HOWEVER.

When Hench is triggered, it CREATES ANOTHER DAMAGE EVENT. Invincible is at its recurrence limit, so IT WOULD NOT BE ABLE TO PREVENT THAT SECOND DAMAGE EVENT.

But I think I have a solution.

The solution is what I just described above: in the 'preemptive phase' of a DynamicAttribute being updated, we will run that event through EVERY Rule, EVEN IF it was prevented.

And, as I described above, that would cause a problem with the recurrence limit. In our example, that would cause Vencabot to take damage even though he's invincible. In fact, I'm going to demonstrate that right now.

The bug works as expected. Both Invincible and Hench are now given the opportunity to prevent the initial damage. The problem is that Hench, after preventing the damage, RE-TRIGGERS a new damage event (double damage), and, at that point, Invincible cannot protect Vencabot because its reached its recurrence limit.

Here's my solution. My solution is to tell preempting rules whether or not the event has already been prevented by the time it reaches them. After that, they can choose what they wanna do. Watch how I fix Hench with this.

So, Hench is apparently fixed, but I feel like we've made a bunch of new bugs by going toward this solution.

Hench's recurrence limit increases whether or not Hench actually deals damage. So, we have, surprise-surprise, an order-of-operations problem.

Let's make an example that doesn't involve invincibility.

I'm gonna make a new rule called ExtraDamage.

When Extra Damage stacks with Hench, you would expect the order to be significant:

Slap does 2 damage.
That's replaced by 3 damage when Extra triggers.
That's replaced by 6 damage when Hench triggers.

But if Hench triggers first:

Slap does 2 damage.
That's replaced by 4 damage when Hench triggers.
That's replaced by 5 damage when Extra triggers.

That makes sense. That's what you want.

The problem is, neither Hench nor Extra creates a new damage event if the triggering damage event was ALREADY PREVENTED. This wouldn't be an issue if not for the recurrence limit. But, before I lose my train thought, couldn't this be solved by the Rule giving itself a bonus to its recurrence limit at this point.

But let's demonstrate the bug.

Well, that didn't work like I expected, but now I see why it worked and that also means that there's a new FACTOR in this situation than I expected to have which might be a good thing or a bad thing (probably good).

What's happening is that Extra Damage is creating a new hp update (which is a new event), BEFORE the 'for loop' continues in the scope that first triggered Extra Damage. It's kind of abstract.

Basically, before the for loop that Extra Damage was triggered in can 'continue' (iterate), we're already triggering a new set of rules -- because, in our new system, rules are triggered at event-creation (essentially). I'm still thinking in terms of event queues, but that's wrong. Rules are triggered when a DynamicAttribute runs 'update'.

I THINK, although this provides me with a much more complex way to look at the relationship between Rules and the order that they operate, this is over-all a good thing. This actually makes things play out in an order that the player would expect.

so, before we call it quits, let's see how invincible plays with this.

I can already see that we... no, actually? We don't have a bug? it's kind of a bug.

It's the end of the stream, it's time for 3S. By giving DynamicEvents a 'prevented' attribute, we allow Rules to see whether the event that's triggering them is going to follow through or not and make decisions off of that. Maybe they'll say, "Okay, well, the damage that triggered is not going to occur, but I still wanna do SOMETHING." That's their prerogative, now.

I also think that the recurrence_limit isn't going to be a problem for a few reasons. One is that we've already seen that the scoping and recursion situation can solve some of these limit problems. But also, even if they couldn't, we could just have the Rule, itself, decrease its own recurrence counter. There's no reason it couldn't say to the game, "Oh hey, you thought I triggered and raised my recurrence counter. Well, I'm gonna manually lower my recurrence counter so that I can trigger again."

We still have order-of-operations bugs, although they aren't necessarily as severe. For instance, even if Vencabot is invincible, you would want for the damage he's GONNA take to be the FULL damage that GoodVibe would've otherwise done if he WASN'T invincible. That just stands to reason. That's what makes sense.

If GoodVibe would've done 10 damage and Vencabot is Invincible, of course he's taking zero damage -- but you would want for that 10 damage to be absorbed by Invincible.

You wouldn't have wanted only 4 damaged to be absorbed and the rest of the damage 'aborted' before it could even be born. Kind of an abstract problem -- kind of difficult to wrap you around, but the fact of the matter is that 'Invincible' sort of kills the damage BEFORE it can be multiplied -- think of it that way. If Invincible is in the Rule List BEFORE 'Extra Damage' and 'Hench,' it KILLS the damage BEFORE it can be multiplied.

However, if Extra Damage and Hench are BEFORE Invincible, then the damage multiplies and then the multiplied damage is killed by Invincible.

The latter situation is what you expect.

So, if we have Rules that would trigger if GoodVibe is fixin' to do 10 damage, they would NOT trigger if Invincible is higher than Hench and Extra Damage.

Sure, if Vencabot WASN'T invincible, then GoodVibe WOULD'VE BEEN FIXIN' to do 10 damage.

However, if Vencabot IS Invincible, then GoodVibe IS NEVER EVEN FIXIN' to do 10 damage, and that's the problem.
