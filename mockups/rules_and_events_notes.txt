It seems that my existing mechanism for implementing Dynamic Rules is somewhat flawed. The idea of having certain BattleEvents become 'neutralized' before they can 'take effect' while still using those same BattleEvents to trigger DynamicRules carriesa paradox: how can you 'undo' the very BattleEvent that triggered you in the first place? That's the problem.

So, in my example, I give dixxucker two different perks that are BOTH triggered by him taking damage. The first perk is 'Sacred Protection' which will UNDO any damage done to him by another Rule. The second perk is 'Rage' which will grant him additional ATK any time that he takes damage.

The issue is that, with both of these perks on him, he will gain ATK without taking damage, because the first rule, Sacred Protection, undoes the damage AFTER its already triggered Rage.

There's a few different ways that I could go about fixing this problem. I've been thinking about it, and, on one hand, I think that this gives us an opportunity to completely do away with the BattleEvent queue system. I think I've devised a better way to handle triggering DynamicRules that doesn't involve iterating through a list of BattleEvents.

But to abstract things, you could say that what I'm proposing is this:

Any time something HAPPENS in the game that could trigger a DynamicRule, it creates a PAIR of 'events', split across two phases: a PRE-EMPTIVE phase where the happening can be PREVENTED or ALTERED, and a REACTIONARY phase, where the happening can be REACTED to.

In the example of the 'Sacred Protection' and 'Rage' conflict, Sacred Protection would be triggered as a part of the PRE-EMPTIVE phase, thus PREVENTING the damage from ever occuring. Then, Rage would be in the REACTIONARY phase, and it would never trigger because there was no damage dealt to react to.

That seems simple-enough, but what I'm actually proposing is doing away with the event queue completely. I had an idea for how we could go about this.

I'm proposing a new type of object which represents a unit attribute that can trigger DynamicRules. For instance, we know that a unit's 'HP', when altered, can trigger any number of DynamicRules.

If HP goes up, it might trigger some DynamicRule.

When HP goes down, it might trigger some DynamicRule.

So, what I'm proposing is that, instead of saving a unit's 'current_hp' as a simple Python integer attribute, what if we saved it as an object like so:

class DynamicIntAttribute:
    def __init__(self, value):
        self.value = value
        self.rules = []

    def alter_value(self, amount):
        for rule in self.rules:
            prevented = rule.check_event(
                    "value_will_be_altered", self, amount)
        # Here's where the problem BEGINS.
        if prevented:
            rule.check_event("value_alteration_prevented", self, amount)
            return
        # Here's where the problem ENDS.
        self.value += amount
        for rule in self.rules:
            rule.check_event("value_altered", self, amount)

Another thing that I'm proposing is that EVERY ACTION in the game trigger rules on two phases: the pre-emptive phase and the reactionary phase. This 'DynamicAttribute' system would streamline that as well, and I'm going to flesh out the example, above, to reflect that.

dixxucker.current_hp.rules.append(SacredProtection(dixxucker))

A problem we're gonna have, with this, is recursive depth. The problem is, "will all of these events eventually RESOLVE."

If we trigger RAGE, for instance, in the PRE-EMPTIVE phase of dixx's current_hp DynamicIntAttribute being altered. We'll just imagine, for the sake of argument, that the rule is, "If Dixx is targeted for damage, his defense goes up." It raises his defense before he takes damage.

What we end up having is a pre-emptive phase that, itself, triggers another pre-emptive phase before the FIRST alteration can actually take effect. Are we at risk of creating some kind of loop where we are forever stuck in these pre-emptive phases and nothing can ever actually happen.

1.) Vencabot uses Slap on Dixx. Slap calls dixxucker.current_hp.alter_value(-10)

2.) Before the HP reduction actually occurs, dixxucker's 'Rage' is triggered.

3.) Rage calls dixxucker.def.alter_value(3).

4.) If there's a Rule in play that prevents units from gaining DEF, it would
call -- the problem is that the act of PREVENTING THE UNIT FROM GAINING DEF would need, itself, to be an event, in case there's a Rule that prevents another Rule from blocking DEF.

5.) Let's say there's rule called "Diamond Wall," which prevents another Rule from preventing DEF growth. What I'm saying is, the conceptual problem is this: WHEN IS THE UNDERLYING ATTRIBUTE ACTUALLY EVER CHANGED. When are we out of this Hell of asking for permission to do something. When does it actually happen. In this scenario, we're talking about a Rule asking for permission to prevent the effect of another Rule.

6.) Let me rephrase this: with this proposed mechanism, one thing that seems impossible is to PREVENT something from happening in a PRE-EMPTIVE phase. The PRE-EMPTIVE PHASE of an attribute-change is MEANT to PREVENT or alter THAT change. I don't think that you can PREVENT the PREVENTION. If you could, I feel like we might be stuck in a loop of pre-emptive phases where we're constantly checking if anyone is interested in pre-empting the pre-emption of the pre-emption of the pre-emption. That's the thing.

And that seems wack. I don't know if that's feasible considering what we want to accomplish with the DynamicRule system.

Maybe we don't need for preventative Rules to trigger other Rules. Maybe that's just a conceptual limitation of what we're trying to accomplish with this sort of emergent gameplay. Maybe that's just the line: you can't prevent a prevention.

Let's list some situations where it would make sense for a DynamicRule to prevent the prevention caused by another DynamicRule:

If Vencabot uses Slap, Slap does half damage.
^ That's a pre-ventative Rule, because, when Vencabot chooses Slap, it proposes a change to HP at some amount of damage. This Rule is triggered in the pre-emptive phase and sees the amount of damage proposed and prevents it. After that, it proposes a new amount of damage (half as much).

That's a preventative rule.

Would be interesting -- do we need -- Rules of the type that would be like, "Abilities always deal full damage." This would effectively negate the above rule, which, itself, is a preventative rule. It would prevent and preventative. I don't think I could implement that, with this mechanism as it stands.

I don't think, with this mechanism, I could implement Rule like, "Abilities always deal full damage." How would I prevent the first rule, "Soft Slap," from doing its job.

What would need to happen, in this mechanism, would be for the very NEGATION of the effect to, itself, be able to trigger both a PRE-EMPTIVE and REACTION phase. And, if that were possible, WOULD WE BE STUCK FOREVER IN A TIME VORTEX where nothing could ever happen because we were too busy asking for permission for it to happen (a never-ending spiral of PRE-EMPTIVE phases).

Let's break it down: how would the negation of an alteration trigger other rules. How.

I looked at the example above and made a simple alteration that I think fixes the problem. Let me re-phrase my solution like so:

You have an object, "DynamicAttribute". When the player makes a decision that would alter some value in the game, a few things happen:

Before its value changes, that attribute warns all of its listening Rules that it's about to change and gives them a chance to prevent that change and propose their own changes.

If that change is prevented, then it reports this to all Rules that might be interested in that prevention having occured.

if the change ISN'T prevented, the value is altered and listening rules are notified of this.

Even with this solution, there are conceptual weaknesses with the VERY IDEA of DynamicRules. One that Kenny points out is when you have two Rules that use very absolute language:

SacredProtection prevents damage from Rules.
DireRules prevents Rules from being prevented.

I feel like this might NOT be a huge problem, and we would just need to... fall back on the ORDER that the Rules were implemented in. I've been considering this, too: in some cases, perhaps the ORDER of the Rules would be significant when determining their priority, and maybe some classes could alter the order of Rules. But I think that's sensible: in cases where PRIORITY would be a factor, perhaps it's just that the bottom-most Rule takes priority. Whatever would trigger last. And if you don't like, then maybe you could somehow change the order of the Rules to be in your favor. I feel like that might be a solution to the problem of when you have two rules that are in competition.

I THINK that solves the Kenny predicament of the immovable object and the unstoppable force. But another problem that I think we have is how Rules will or won't 'stack'. My fear is that this might require an entirely separate and complex mechanism, in itself, to manage.

For instance, what if we have these two rules in play:

ClassicProtect: the target unit takes 75% damage.

Seems simple.

But then we also have this:

FlubbidityWoo: the target unit takes 50% damage and the attacker takes the other 50%.

How do these stack on the same unit? They both directly influence the amount of damage the unit takes.

The obvious thing would be to just have them stack. Vencabot he would've taken 10 damage, but ClassicProtect caused him to take 7.5 instead. But flubbitywoo is triggered, which causes him to take HALF of that damage and his opponent takes half: they both take 3.75 damage.

That makes sense MECHANICALLY. Although it makes sense mechanically, I'm not convinced at all that it makes sense in terms of GAMEPLAY BALANCE. Because, the core gimmick of our game -- the heart of all of the strategy -- comes from the interaction of different Rules and teams playing within these rules. That being the case, I don't think it would be unusual for these two Rules to end up on the same unit. Maybe even more Rules that affect the damage that unit takes. I think it'd be trivial to build a team that could put four rules into play that all lower the amount of damage that Vencabot takes.

I feel like, if we don't have some kind of mechanism that prevents too many rules from stacking on a single unit, it'd be trivial to make that unit super over-powered very quickly.

Let's say you had three different rules, like so:

ClassicProtect
FlibbityWoo
Dispersion: The targeted unit takes 50% damage and his teammates get the remainder split among them.

That makes sense. It's fun. The problem is that, that same unit could have two other fucking rules on them that reduce their damage by 50%. That are also, in isolation, fun and interesting. But combined, it just breaks the game.

This is what I was thinking about earlier, in the shower, which coincides directly with KG's recommendation that we 'tag' certain Rules. Like, the 'tag' would somehow influence the way that they stack with each other -- or don't stack. Maybe some Rules simply OVERRIDE other rules. Maybe they can interact but with some special stacking algorithm. Maybe others just stack outright, like we demonstrated above. But, again, my fear is that we're talking about having to implement a whole separate mechanism -- be it tag-based or whatever -- to balance the interactions between certain Rules to prevent their COMBINATION from being too powerful.

You could abstract the problem like this: it's hard to make Rules that are exciting and interesting in isolation without making them completely broken in certain, VERY SIMPLE combinations. It seems we would need some kind of way to influence how certain rules stack with each other.

That's something that we're going to probably need to sleep on.

I think, for today, I'm mostly happy with this 'DynamicAttribute' idea, where Rules are triggered on TWO phases whenever an attribute of certain objects is altered. That makes sense to me, and I don't think that it would result in any infinite-loop problems, as long as we stick with the idea of a 'recurrence limit' on Rules.

You could argument that a rule that both 'buffs' and 'debuffs' a character could be split into literally both of those things: it adds 1 buff and it adds 1 debuff. But what about 'debuffs' that are like, "if MutantXP takes damage while in the back row, whoever's in the ring takes that damage for him." Which character gets that buff? Or is it debuff? If it's for whoever's in the ring, does it count toward their debuff limit? What happens when they're not in the ring anymore?

For this reason, I've sort of been straying away from using terminology like 'buff' and 'debuff.' And that's ONE MORE THING that makes it difficult when talking about how these Rules are going to stack and otherwise negotiate with each other to make the game more balanced.

It's like, you have these Rules which, in isolation, don't debalance the game -- but when you start applying more of them, they game can get unbalanced real quick. And not in a super-strategic way where there's a reasonable counter-play. We're talking about, just some broken-ass shit.

It sounds like what Kenny is saying is that every rule in the game would apply to all units equally.

Here's our final note: on Thursday, I'm going to mock-up our current encounter but using the new DynamicAttribute system that I devised above, and we're gonna see if it works. Supposing that it works (I expect that it will), I think that we will be free to create any Rule that we can imagine and have it work like we expect.

That would be a huge accomplishment.

IF that works, we should definitely move on to figuring out how to balance Rules against each other so that they can't very easily make some super broken combinations. I feel like KG's recommendation that we tag Rules in a certain way to determine how they stack might be the key -- but whatever the solution ends up being, I don't think that it behooves us to worry about that right now. I'm gonna get Rules working so that they're flexible, interesting, exciting, and powerful -- and if we can get that working, then we'll worry about how to balance them.




03/21/19

Roadmap for today's stream:

I want to get our original example, which does NOT work, working in a newly designed DynamicRule system which relies NOT on a queue of 'event' objects but rather on callbacks that are associated with DynamicAttribute objects, which call their callbacks whenever anything changes.

Let's get going.

How are phases supposed to work, again?

Before a change is made to any attribute, we WARN the rules that this is gonna happen. That way, the rules can PREVENT this from happening.

AFTER an attribute changes, we ALSO report this to all of the rules so that they can react.

So, DynamicAttributes need TWO lists of rules, right? They need a list for pre-emptive rules and reactionary rules.

Can we agree that pre-empting is only for preventing an event from happening? I would say yeah, right? Yeah.

Should more than one rule be able to prevent a single event? No. Only the first rule to prevent the event should be triggered.



WELL, IT WORKED, but I'm not super confident in it. I wish I had more time to test it, but we're already more than half-an-hour late for 3rd Strike.

That means that, next week, our first order of business is to review the code that we just wrote and figure out how it works. We could probably use some documentation, better function and attribute names, etc. Because I'm not super confident in my own understanding of exactly all of the mechanisms that we're working with in this relatively simple example. But it seems to work.




03/25/19

We have a very minor bug in our code regarding order-of-operations (which is always the trickiest thing about this system).

If GoodVibe's 'Hench' rule is applied BEFORE Vencabot's 'Invincible' rule, things behave in a way that makes sense to the player (and to the developer): when GoodVibe attacks Vencabot, the damage he would've dealt is doubled, but he can't do damage to Vencabot because he's invincible.

The problem is this: if Vencabot's 'Invincible' rule is applied BEFORE GoodVibe's 'Hench' rule, GoodVibe will not get Hench when attacking Vencabot.

The end result is the same: Vencabot doesn't take damage.

The difference is that, if GoodVibe is going to do damage to Vencabot, all of the Rules that are triggered in this situation are checked in-order. if GoodVibe is going to do damage to Vencabot, 'Invincible' prevents this, neutralizing the event.

BUT ALSO, if GoodVibe is going to do damage to Vencabot, 'Hench' neutralizes the event and then creates a new event to deal double damage.

So, if Hench is applied first, it neutralizes the FIRST damage event and then creates a NEW damage event. And then Invincible neutralizes that SECOND damage event.

However, if Invincible is applied first, it neutralizes the FIRST damage event, and then there's no damage event to trigger Hench.

The problem is, conceptually, abstractly, the player (and the developer) would expect for GoodVibe's 'Hench' to be triggered regardless of whether Vencabot is invincible or not. Either way, Vencabot's not taking any damage -- but GoodVibe should still OUTPUT that double-damage.

Now, obviously, we could phrase 'Hench' in such a way that our existing mechanism makes sense, and maybe that's just gonna have to be the limit, here:

"When GoodVibe deals damage, it's doubled."

It's clear from that definition of Hench that it wouldn't trigger if Vencabot was Invincible, because GoodVibe wouldn't have dealt damage.

But is there a way to make this work in a more intuitive way.

Let's make a new way for Hench to behave. In fact, let's call it something different. Let's make a new Rule just to demonstrate our problem.

What the player expects from 'BloodLust' is that, whenever GoodVibe attacks, he gets attack power.

But the reality is that, when GoodVibe HAS AN ACTIVE DAMAGE EVENT, he gets attack power.

So this can behave a bit unintuitively if his DAMAGE EVENT is PREVENTED before 'BloodLust' can trigger.

Panders brings up a point that may very well be key to our solution, and that's to create another phase. So much of the difficulty we've had has been in the ORDER OF OPERATIONS of our Rules, and the solution has often been to create ANOTHER PHASE for rules to be triggered on. That helps to make it more explicit WHEN rules should be run.

The problem we have, with this NEW system in particular, is that Rules are always triggered WHEN AN ATTRIBUTE HAS CHANGED.

So, when GoodVibe SELECTS an attack, we can't trigger a Rule, because no attributes have been changed, yet.

When goodvibe CHOOSES to attack, nothing has happened for us to react to in terms of an attribute being raised or lowered.

The idea was that we would know that Goodvibe chose to attack because the game reacts to him wanting to LOWER someone's HP.

The HP attribute is being manipulated, and THAT'S what triggers the rule.

The problem is that this CHANGE can be PREVENTED. That's the whole point of the 'pre-attribute-change' phase.

Basically, the way our system works, guys, is that, whenever a unit's attribute -- such as their HP -- is being manipulated, it triggers rules on 3 different phases:

1.) Before the change is made to HP, we ask every rule if they want to prevent that change.

2.) If that change IS prevented, we notify all of our rules that the change was prevented. This might trigger other Rules that may only happen if a another rule takes affect.

3.) If that change is NOT prevented, then we actually implement the change (HP is reduced) and then we notify all of our Rules of the change, in case they want to react to the DAMAGE HAVING BEEN DONE.

We've been through a few different solutions for this 'dynamic rule system,' and the problems always occur when we talk about PREVENTING things from happening before they happen.

So much trouble comes from the fact that we NEED for a PROPOSAL to TRIGGER rules so that they can PREVENT that thing from happening (such as Invincibility).

However, when that thing is prevented from happening, it prevents other Rules from being triggered that would have ALSO prevented that thing from happening.

Our problem here is, with Hench and Invincible, we have TWO RULES that want to prevent damage from happening. Whichever Rule is implemented FIRST will PREVENT the damage from happening, and, therefore, the second Rule will not trigger.

Now, if you're not keeping up with the programming and behind-the-scenes stuff, you might be asking: how does 'Hench' prevent damage. It doubles damage. It doesn't prevent it.

But what happens, internally, is that Hench is triggered by GoodVibe wanting to do 5 damage. THAT DAMAGE IS PREVENTED and Hench creates a NEW EVENT to do 10 damage.

So, if Hench is BEFORE Invincible, then Hench will PREVENT the first damage, which also prevents Invincible from triggering (since it needs a damage event to pre-empt). Then, hench creates a SECOND damage event, which DOES trigger Invincible.

In other words, if Hench is first, then things behave as we expect: GoodVibe chooses to attack, he gets all buff, and then he hits Vencabot really hard with a hench'ed up attack that doesn't do damage because Vencabot is invincible.

ON THE OTHER HAND, if Invincible is first, then it prevents the initial damage from being done -- and since Hench checks AFTER that, it never sees that GoodVibe was doing an attack and, therefore, he never henches out.

This would be kind of solved if GoodVibe could get henched out before even proposing to do HP damage.

Like, if he chooses an attack, then he gets hench.

The problem with this is that it makes the 'damage multiplier' aspect of the Rule a lot dirtier. Because, at this point, before we deal damage, how do we know how to 'double' his damage. The only way I can think of would be to give each unit some kind of 'attack multiplier' attribute, which is sub-ideal. Just adds more complexity. I like the way it works now: when a unit is gonna deal damage, they can see how much damage they're gonna do and we can boost that.

BUT THERE'S ANOTHER PROBLEM. The problem is that, if we have a Rule that says, "When Vencabot chooses to Slap, his ATK goes up," we can currently only have his ATK go up AFTER he slaps and gets damage calculation.

We can't request a new damage calculation with Vencabot's newly-raised attack power. We could do that if we could catch 'slap' before it happens and then raise his attack power and re-slap.

It also strikes me, as I say this out loud, that, if we ONLY TRIGGER RULES BASED ON ATTRIBUTES CHANGING, which is our current system, we can NOT have certain rules trigger when a unit chooses to use a certain move, or a move from a certain class, or anything like that -- which could make for some very reasonable and interesting rules.

Because, there's no indication, in the DynamicEvent, of what Skill was used. We only know that a target unit had an attribute changed by a perpetrator.

But that's not a problem because 'perpetrator' can be a RULE (not just a unit), and I don't see why it couldn't be a SKILL. Perpetrator can be a skill, and then we can use that Skill's 'owner' attribute to figure out what the perpetrating unit is. Then we'll know what skill they were trying to use and we can use that as part of our checks for the rule.

The problem is a problem of ORDER. Order of operations. Especially when we're talking about PREVENTING or NEUTRALIZING or CANCELING things from happening before they happen. That's the problem.

How can you PREVENT something from happening, but make sure that all of the Rules that would have prevented it all get their chance to trigger.

The obvious thing would be to run that 'prevented' event through ALL of the rules that would've prevented it and only prevent the change from happening after that.

The problem with that is the RECURRENCE LIMIT. Let's say that 'Invincible' can only occur once per event phase. If Invincible triggers when GoodVibe tries to do damage to Vencabot, we COULD VERY WELL SAY, "that event is now prevented. However, continue to check other rules that would have been triggered."

That would seemingly solve our problem. HOWEVER.

When Hench is triggered, it CREATES ANOTHER DAMAGE EVENT. Invincible is at its recurrence limit, so IT WOULD NOT BE ABLE TO PREVENT THAT SECOND DAMAGE EVENT.

But I think I have a solution.

The solution is what I just described above: in the 'preemptive phase' of a DynamicAttribute being updated, we will run that event through EVERY Rule, EVEN IF it was prevented.

And, as I described above, that would cause a problem with the recurrence limit. In our example, that would cause Vencabot to take damage even though he's invincible. In fact, I'm going to demonstrate that right now.

The bug works as expected. Both Invincible and Hench are now given the opportunity to prevent the initial damage. The problem is that Hench, after preventing the damage, RE-TRIGGERS a new damage event (double damage), and, at that point, Invincible cannot protect Vencabot because its reached its recurrence limit.

Here's my solution. My solution is to tell preempting rules whether or not the event has already been prevented by the time it reaches them. After that, they can choose what they wanna do. Watch how I fix Hench with this.

So, Hench is apparently fixed, but I feel like we've made a bunch of new bugs by going toward this solution.

Hench's recurrence limit increases whether or not Hench actually deals damage. So, we have, surprise-surprise, an order-of-operations problem.

Let's make an example that doesn't involve invincibility.

I'm gonna make a new rule called ExtraDamage.

When Extra Damage stacks with Hench, you would expect the order to be significant:

Slap does 2 damage.
That's replaced by 3 damage when Extra triggers.
That's replaced by 6 damage when Hench triggers.

But if Hench triggers first:

Slap does 2 damage.
That's replaced by 4 damage when Hench triggers.
That's replaced by 5 damage when Extra triggers.

That makes sense. That's what you want.

The problem is, neither Hench nor Extra creates a new damage event if the triggering damage event was ALREADY PREVENTED. This wouldn't be an issue if not for the recurrence limit. But, before I lose my train thought, couldn't this be solved by the Rule giving itself a bonus to its recurrence limit at this point.

But let's demonstrate the bug.

Well, that didn't work like I expected, but now I see why it worked and that also means that there's a new FACTOR in this situation than I expected to have which might be a good thing or a bad thing (probably good).

What's happening is that Extra Damage is creating a new hp update (which is a new event), BEFORE the 'for loop' continues in the scope that first triggered Extra Damage. It's kind of abstract.

Basically, before the for loop that Extra Damage was triggered in can 'continue' (iterate), we're already triggering a new set of rules -- because, in our new system, rules are triggered at event-creation (essentially). I'm still thinking in terms of event queues, but that's wrong. Rules are triggered when a DynamicAttribute runs 'update'.

I THINK, although this provides me with a much more complex way to look at the relationship between Rules and the order that they operate, this is over-all a good thing. This actually makes things play out in an order that the player would expect.

so, before we call it quits, let's see how invincible plays with this.

I can already see that we... no, actually? We don't have a bug? it's kind of a bug.

It's the end of the stream, it's time for 3S. By giving DynamicEvents a 'prevented' attribute, we allow Rules to see whether the event that's triggering them is going to follow through or not and make decisions off of that. Maybe they'll say, "Okay, well, the damage that triggered is not going to occur, but I still wanna do SOMETHING." That's their prerogative, now.

I also think that the recurrence_limit isn't going to be a problem for a few reasons. One is that we've already seen that the scoping and recursion situation can solve some of these limit problems. But also, even if they couldn't, we could just have the Rule, itself, decrease its own recurrence counter. There's no reason it couldn't say to the game, "Oh hey, you thought I triggered and raised my recurrence counter. Well, I'm gonna manually lower my recurrence counter so that I can trigger again."

We still have order-of-operations bugs, although they aren't necessarily as severe. For instance, even if Vencabot is invincible, you would want for the damage he's GONNA take to be the FULL damage that GoodVibe would've otherwise done if he WASN'T invincible. That just stands to reason. That's what makes sense.

If GoodVibe would've done 10 damage and Vencabot is Invincible, of course he's taking zero damage -- but you would want for that 10 damage to be absorbed by Invincible.

You wouldn't have wanted only 4 damaged to be absorbed and the rest of the damage 'aborted' before it could even be born. Kind of an abstract problem -- kind of difficult to wrap you around, but the fact of the matter is that 'Invincible' sort of kills the damage BEFORE it can be multiplied -- think of it that way. If Invincible is in the Rule List BEFORE 'Extra Damage' and 'Hench,' it KILLS the damage BEFORE it can be multiplied.

However, if Extra Damage and Hench are BEFORE Invincible, then the damage multiplies and then the multiplied damage is killed by Invincible.

The latter situation is what you expect.

So, if we have Rules that would trigger if GoodVibe is fixin' to do 10 damage, they would NOT trigger if Invincible is higher than Hench and Extra Damage.

Sure, if Vencabot WASN'T invincible, then GoodVibe WOULD'VE BEEN FIXIN' to do 10 damage.

However, if Vencabot IS Invincible, then GoodVibe IS NEVER EVEN FIXIN' to do 10 damage, and that's the problem.

The amount of damage that GoodVibe is FIXIN' TO DO shouldn't change based on whether Vencabot is invincible or not, but it does.

But that's a problem for us to solve on Thursday.


04/01/19:
As I recall, the main issue we were facing last time is the same issue that we've always been facing: order of operations, especially in how we deal with 'neutralizing' events or 'preventing' things from happening. How does a rule prevent the very thing that triggered that rule?

My solution, which has been working okay, is to have some rules be triggered 'pre-emptively,' and, at that point, they can opt to 'prevent' the action that triggered them pre-emptively. That works okay until you start considering situations where more than one rule is triggered pre-emptively by the same event. If the first rule PREVENTS the event, then what is the second rule doing?

My solution was to give events a flag that explains whether they've already been prevented or not -- and then, when rules are triggered pre-emptively, they ALL get triggered. So, they can ALL attempt to prevent the same event (and they can read whether or not it's already been prevented), and they can adjust their behavior based on whether or not that event was already prevented -- such as re-incrementing their recurrence counter.

But this still has weaknesses, and I want to list a few here, including reviewing the one that we left on, last week: the 'hench damage'.

Let's examine the hench problem, again:

If GoodVibe is Hench, all of his attacks are supposed to do double damage.
If Vencabot is Invincible, he never takes any damage.

Both of those Rules are triggered pre-emptively on a 'damage event.' The damage event says, "GoodVibe is going to do 3 damage to Vencabot."

This triggers both Rules:
Hench sees that event and PREVENTS it, and then creates a NEW damage event which says, "GoodVibe is going to do 6 damage to Vencabot."

'Invincible' sees that first damage event and PREVENTS it entirely.

So, both of these Rules prevent the first damage event. So, the order of operations for these Rules becomes significant.

If 'Invincible' is triggered first, then 'Hench' should not trigger in such a way that it creates a new damage-event. Because, due to the recurrence-limit of 'Invincible,' it wouldn't be able to block the second damage-event.

If 'Hench' is triggered first, there's no problem: Hench prevents the first damage event and creates a second damage-event. Invincible doesn't worry about the first, prevented damage event and goes on to prevent the second one. Vencabot takes no damage.

So my solution, so far, to the problem of 'Invincible' triggering first has been for Hench to check to see if the damage-event that triggered it has already been prevented. If it's already been prevented, then Hench goes off VISUALLY, to satisfy the player, but it doesn't actually complete its task: it doesn't create the second damage-event that would do double damage.

So, in that respect, the problem is solved. However, the issue we have is that this creates internal consistency problems. Let's say that we have a rule that's supposed to trigger whenever GoodVibe is about to do 5 damage or more. If GoodVibe would normally do 3 damage and is henched out, you would expect that, on his next attack, he'd be "about to do 6 damage."

Of course, Vencabot is Invincible, so he's not going to take any damage. The issue is that, if 'Invincible' triggers FIRST, then no damage event is ever CREATED to trigger 'Rule 3' by prepping to do 6 damage. Even though he's Hench, GoodVibe's only Damage Event would've been for 3 damage. It's inconsistent.

It seems to me that the solution to this problem -- and any problem, in our system that relates to order-of-operations and negation of events -- is to create more phases for rules to proc in.

In our first version of this code, we only really had 'one' phase, and our order-of-operation problems were insurmountable.

I created this second version to address those problems by creating more phases, and our problems immediately became much less drastic.

Is the solution, here, to create more phases -- and, if so, how can I manage that and keep it sensible and consistent, internally? How many phases do we need. In an abstract sense, how do we keep an understandable pattern regarding when these phases occur.

In this phase 2 code, I've solved that problem (or so I thought) by having phases be tied to when an attribe (DynamicAttribute) changes. Whenever a DynamicAttribute is asked to change, it generates a few different phases: a pre-emptive to prevent the change, a phase that occurs after prevention and a phase that occurs after the change is made.

That seems sensible, but I'm not sure it's 100% workable. How can we add more phases into this to solve our problem.

First of all, WOULD that solve our problem.

Let's create a 'Hench' example that hypothetically works better:

Hench has to trigger before Invincible, always. That's the problem. What triggers 'Hench' to go off, and what triggers 'Invincible'? If not a proposal to do damage.

I love the idea of 'Hench' being triggered by a proposal to do HP damage because it means that we don't need to fuck around with whatever-skilled-was-used's damage calculation. We just take the final damage and double it. That makes sense to me.

Hench can't trigger if the event that triggered it has already been prevented. That's the problem.

I need to think outside of the box. I need, maybe, to get off of this 'prevent an event before it happens' train. Is there another solution that doesn't evolve going BACK IN TIME and preventing something that's already happened, essentially. The problem I'm having is that the very event that's triggering these rules is the event that we're trying to negate. How can I trigger these rules in a different way where we don't need to 'prevent' something from happening.

I think the real problem we're having, at the end of the day, is that we have two different rules that are pre-emptively responding to and preventing the same event. Because, they can't literally occur simultaneously: one has to occur first. If the first one has already prevented the event, then the second rule's job becomes very confusing.

Let me be clear about a solution we came up with last week. We could totally sell into the notion that order-of-operations is profoundly significant in our game's mechanics, and we can work Rules in such a way that it becomes more clear how they work, internally.

For instance, we could just describe 'Hench' as, "If GoodVibe would've done damage, that damage is doubled." That would be simplest solution: just simply word all of our Rules in such a way that it's communicated to the player that the order of things is important.

Maybe this problem would solve itself if we were to re-examine our 'DynamicAttribute' system and consider what rules COULD NOT WORK under these constraints, and decide on if we're okay with that or if we need to come up with new ways to make Rules work to accommodate these edge-cases.

What's a Rule that wouldn't work if the only way to trigger it was a proposal for something concrete to happen in the game-world. The way that 'DynamicAttributes' work is that something has to CHANGE. Something has to CHANGE, and then Rules start getting triggered. So what are some Rules that would need to trigger without the game world being changed in some way.

You couldn't have a Rule which would prevent the player from accessing their 'Items' menu. Because the Rule couldn't be triggered until an item is used -- then you could say, "Oh, you tried to use an item; let's prevent that from happening."

But, abstractly, that's not really a 'Rule' that would get 'triggered,' anyway. I mean, there are other Rules you could point out which might, for instance, halve a unit's max HP for a while. That Rule wouldn't really be 'triggered'; it's just always active until it wears off. So that's not really a problem. Our system accommodates those situations. You could basically say that some Rules have persistent affects and they're triggered as soon as they're inflicted.

One thing you couldn't do is have a Rule be triggered as soon as the player 'picks' an ability to use. But would we ever want to do that?

The problem, hypothetically, is that, by choosing an ability to use, you have not actually DONE anything. So we can't trigger anything at that point. We can only trigger a rule after you've chosen to EXECUTE that ability. Then, we propose some changes to some DynamicAttributes and that's what triggers our Rules.

So what sorts of Rules can we NOT do because we cannot trigger anything when an ability is chosen. I just can't think of anything that would need to be triggered after an ability is chosen but before it proposes its changes to the game.

So, in that respect, maybe the DynamicAttribute system really is a magic bullet for our problem. So, the only issue we have becomes one of order-or-operations. Maybe the solution is just to word our Rules in such a way that it's clear that order-of-operations is significant.

I'm just stuck on this idea that we could use more phases. But, CAN we cram more phases into this DynamicAttribute process? Right now, it's pretty cut-and-dry:

You have a phase BEFORE a change is made. You have a phase AFTER a change is made.

How many more phases can you logically fit in there?

We're done. We just need to word our Rules in such a way that the player understands that order-of-operations is significant. I'm not convinced there's a better solution.

Our game is going to be a monster-collecting JRPG in the style of Pokemon, or Robopon or Magi-Nation or any number of other clones and genre defining games. Like Pokemon, our battles are going to be one-on-one but with a team 'in the back row' that can be swapped in to replace the unit currently in the 'ring'.

In Pokemon, you have one monster that's fighting and you have 5 'in reserve,' and you can swap them in and out at will, but with tactical repercussions. In Pokemon, when you swap, you lose a turn unless you do so after a KO.

One difference for our game is that each team can take more than one action per turn. In Pokemon, turns go back-and-forth: I get one, you get one, I get one, and so-on. In our game, we're leaning on an equally-common JRPG trope of having an 'AP bar,' and your turn persists as long as you haven't run out of AP.

So, in our title you'll be able to attack maybe 4 times or more with your unit before the enemy gets a turn, or you could attack once, and then swap, and then attack again with your second unit.

But the real gimmick of our game is this 'Dynamic Rule' system where each team will have abilities that will impose new Rules upon the battle.

For instance, if I'm fighting a team that has a healer I might want to use a unit who has an ability to change the battle's rules. Let's say that one of the units on the enemy team is 'Reaperish,' and he's a real bad-ass. He's in the ring a lot and dealing a lot of damage -- and taking a lot of damage -- but he keeps getting healed up by the opponent's healer.

Maybe I have a unit who has an ability that adds a new Dynamic Rule to the battle like this: If Reaperish has his HP restored, the unit who restored his HP takes damage equal to the amount that they restored.

So now, if the healer wants to heal Reaperish, they're gonna take damage. I have a tactical advantage -- and that's the core gimmick of our combat system.

You could think of these 'Dynamic Rules' as being conceptual complex buffs and afflictions from other JRPGs. In other JRPGs, maybe the afflictions are simple as Poison -- "take 3 damage every turn." Or buffs are as simple as "Protect: you have 3 extra defense." We're sort of taking that notion of buffing and nerfing and trying to make it more tactically interesting.

Let's take that example we just described: if a unit heals Reaperish, that unit takes damage equal to the amount that Reaperish was healed.

With our current game-engine, we have a DynamicAttribute system which sort of manages the way that Rules behave. Basically, whenever a 'DynamicAttribute,' such as HP, is changed, we can ask the game's current Rules if they're interested in going off.

So, here's what would happen, internally:

Vencabot uses 'Heal' on Reaperish. It's gonna heal him for 15 health.
Reaperish's HP 'DynamicAttribute' gets 'updated,' and when you 'update' a DynamicAttribute the first thing it does is ask all of the game's rules if it's okay to update it. If it's not okay, then no change occurs.

So, the DynamicAttribute goes through all of the active rules and says, "Hey, Vencabot is about to heal Reaperish's HP. Do you guys want to prevent this? Do we have any Rules that prevent Reaperish from being healed, or prevent Vencabot from healing somebody?"

In this case, we don't, so we move on to phase 2 of HP being 'updated': the post-update phase. Now, Reaperish's HP has gone up, because we was healed for 15 health. Now, the DynamicAttribute goes through all of the active rules, again, and says, "Vencabot healed Reaperish's HP by 15. Do any of you want to do something about that?"

Our 'No Healing Allowed' rule then says, "Oh shit, somebody raised Reaperish's HP? Well then take the amount that he was healed and update Vencabot's HP downward by that amount."

So Vencabot's HP "DynamicAttribute" does the same thing. It says, "Hey, all the rules in the game: Vencabot's HP is about to be lowered by 15 by 'No Healing Allowed'. Do any of you guys want to prevent that from happening?" If we had a Rule which was like, "No Rules can do direct HP damage," or, "Vencabot is immune to damage done by Rules," then yeah, we would prevent that -- but in our case, no.

So now we enter the second phase of Vencabot's HP being updated: the phase after his HP is actually changed. Then the DynamicAttribute says, "Hey, Vencabot's HP was just lowered by 15 by 'No Healing Allowed'. Do any of you guys want to react to that?"

If we had a Rule in play that was like, "If Vencabot takes damage from a Rule, he gets pissed off and his ATK goes up," we would do that -- and the change to atk power would ALSO ask all of the rules if they want to react in some way.

I think that our DynamicRule system is complete. All we need to be conscious of is the wording of our Rules so that it's clear that order-of-operations is significant. We need to describe the rules to the player in a way that makes sense considering our 'preventative' system.

That being the case, I could probably go back and simplify our code to get rid of the 'rule can trigger even if the event has already been prevented' clause. I think that just makes things more confusing and is gonna cause problems. We can always bring it back later if I'm wrong.

Every unit (Pokemon) comes with a permanent rule attached to them. When you bring that unit into battle, then the battle has that rule.

Furthermore, certain abilities that your 'Pokemon' can use might add new rules to the battle or remove existing rules.

Combat is going to be a tug of war where both sides are trying to make sure that the rules are in their favor while working AROUND rules that are hampering them but which they might not necessarily be able to remove right away.

What if we allow EVERY RULE TO TRIGGER that would've been triggered by an event, even IF it was prevented, but with the caveat that, if a Rule is triggered by an event that was prevented, all that it can do is explain that to the player. To do anything else would almost certainly cause bugs: if this event was prevented, Rules that were triggered by it shouldn't really be able to do anything. But at least they could print a message (or, in the case of the graphical game, display some kind of visual effect to show that the rule failed to trigger).

We still have a problem with multi-prevention. I don't know what I'm talking about.

I like this new code. Why isn't Bloodlust getting a failure message when Vencabot is Invincible? Fix it.

