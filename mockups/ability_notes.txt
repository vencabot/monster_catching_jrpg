04/08/19

It's been a while since we talked about game-design. Over the past couple weeks, we've been doing some development -- some actual programming -- regarding the implementation of our game's Dynamic Rule System. Now that it's fully-functional, it's time to start developing other aspects of our game. The problem is that we need to review how we want for these aspects to behave.

I think our first order of business is to start working on 'abilities,' which are the actions your units can take in battle to consume AP. Think of these like the four 'moves' that Pokemon have.

To test the Dynamic Rule System, I created a very simple ability called 'Slap' which I think already nails down some CORE concepts about abilities, but we also had some more in-depth, complicated aspects that I'd like to review and attempt to development.

Let's review what we know about Abilities:
    * Abilities belong to 'classes'.
    * Abilities always consume the Leader's AP.
    * Abilities may consume resources from the unit or carry some cost.
    * A unit's 'MP' attribute is designed specifically as a resource for
      abilities to consume.
    * The use of abilities is the core of our combat gameplay. The idea is
      to choose them carefully and use them to give yourself an advantage in
      battle, and to use them over and over until you win.
    * Aside from dealing direct damage to enemy resources, abilities will
      also engage the Dynamic Rule System by implementing favorable rules
      for your party and disfavorable rules for the opponent party.
    * As a side-effect, some abilities may implement rules that are DIS-
      FAVORABLE for YOUR party or FAVORABLE for the ENEMY party. This could
      be the result of an ability 'backfiring' or just as a cost for an
      otherwise powerful ability.

    * We talked at depth before about how much 'chance' should play a role
      in the core mechanics of using abilities. One thing that we discussed
      was the idea of an 'effectiveness' gradient. Maybe this would be a
      good time to review that.
    * Every ability has 3 levels of effectiveness: 'glancing' effectiveness,
      'normal' effectiveness, and 'critical 'effectiveness.
    * When an ability is used, a dice is rolled to determine effectiveness.
    * Attributes on both the AGGRESSOR and DEFENDER will have an impact on
    * How wide the areas are for the dice-roll to land in any of those three
      levels.
    * These attributes are 'Skill' on the aggressor and 'Parry' on the
      defender (these names both suck, let's reconsider as time goes on).


I guess the moral of the story, today, is that we need to take our 'Slap' demonstrative ability and give it three effectiveness levels and see how we're gonna handle that dice-roll.

At first, we're not gonna fuck around with 'Skill' and 'Parry' attributes. We're just gonna roll a dice and choose a tier to activate when an ability is used.

Even at first, we want to determine a way to weight this randomness -- and that's something that I've had trouble with in the past: randomness weighting. There's many ways to do it and I've never been 100% satisfied that I've found the best way, programatically.

Enough developing: let's talk about DESIGN again. How are we going to calculate effectiveness. We have to change the weights of 'critical' and 'glancing' based on the interplay between the aggressor's Skill attribute and the defender's Parry attribute.

If an aggressor's Skill attribute is substantially higher than the defender's Parry attribute, we're going to have a HIGHER chance of getting a critical and a LOWER chance of getting a glancing hit.

If the defender's Parry attribute is substantially higher than the aggressor's Skill attribute, we're going to have a LOWER chance of getting a critical and a HIGHER chance of getting a glancing hit.

If they're even... Then we fall-back on some default weighting.

What if there was a MINIMUM CHANCE to GLANCE or CRIT. Let's say that we can simply get a 'interplay' value just from combining our 'parry' and 'skill':

Vencabot has 20 Skill
Kenny has 25 Parry

Effectiveness multiplier would be -5.

So, as this number goes into the negatives, we reduce our chance to crit UNTIL IT HITS ITS MINIMUM. You're gonna always have a chance to crit, but the chance bottoms out. Once that chance bottoms out, your chance to GLANCE goes UP. So, what we're really talking about is our chance to 'normal' shrinking. The more dramatic our 'effectiveness multiplier' becomes, the smaller our chance to 'normal' becomes.

Positive multipliers would work the opposite way: your chance to 'glance' would go down until IT hits a minimum, and then your chance to crit would start to go up, eating into your chance to 'normal'.

If our multiplier is 0 (Vencabot has 20 Skill and Kenny has 20 Parry), what are our default weights and how far are they from the MINIMUM weights?

I think, because we're working with a multiplier with 0 -- which is probably gonna be somewhat rare -- maybe we should have more dynamism: higher chances to glance and crit than we've been working with.

15% Glance (minimum 5%)
70% Normal
15% Crit (minimum 5%)

I wanna make a note that the WHOLE POINT of the 'effectiveness system' is to mitigate saltiness, because, unlike some RPGs where 'crit damage' is a pre-baked calculation, our abilities have THREE DIFFERENT FORMS: a 'glancing' form, a 'normal' form, and a 'crit' form, and all three are unique to every ability.

Therefore, you can always choose to use abilities where there isn't a whole lot of variance between the forms. Or you could choose to use abilities where there's a dramatic difference between the forms. So, it's in the player's hands how much they want to lean or be victim to the random effectiveness.

The downside of having lower 'default' values for Glancing and Crit would be that, as you grow your character to have higher Parry or Skill, there's less Crit and Glancing to TAKE AWAY.

The UPSIDE of having lower 'default' values for Glancing and Crit, is there they can grow MORE. It really depends on how extreme we expect the differences to be between an aggressor's Skill and a defender's Parry -- and what I will say is that, looking at how we've designed growth and attributes so far, it does seem somewhat likely that there could be a very large gap (multiplier). So perhaps it would make more sense to have the 'default' values be somewhat rare and then, as that multiplier goes up, we get higher likelihoods to get 'glancing' or 'crit'.

The next step would be to fine-tune the multiplier, but let's not fuck with that, because that really is dependent on character growth, which we haven't looked at yet: we don't know if a normal level for Skill would be '10' or '10,000'. We don't have a sense of scale.

So let's just mock this up and see where we're at.

For our mock-up, let's assume that '5' is a normal amount for Parry or Skill, and let's say that having twice the value of your opponent's attribute will give you a 50% chance to crit (or glance, depending on if you're attacking or defending).

We made some good progress: the next step will be to create a method which takes this 'effectiveness augmentor' (or whatever you want to call it) and returns weights. Since we're lowering ONE weight to a certain level before we start to RAISE the other weight, there's going to be a little bit of coding involved.

## side note: I forgot to fuck around with 'cure conditions' for our DynamicRule system. So, we're not really complete on that, yet.




04/15/2019

Let's make a to-do list for what I want to accomplish with the game this week.

So far, we've created a lot of mock-ups for the games most-complex mechanics (at least, seems to me). They've been proofs-of-concept just to demonstrate that some of this stuff is workable. Now, I want to look at battle in a more wholistic way; I want to actually start creating a full battle that can play out from start to finish with respect for the mechanics that we've discussed during our game-design streams.

So, a few things we're gonna need:

We're going to need Leaders, with their own attributes.

We're going to need to flesh out the Battle object with respect for which Units are in the 'ring' and in the back row.

We're going to need to flesh out the Units with more Attributes, including their slots for Dynamics.

Before we implement Leaders, let's flesh out our existing objects: Battles and Units.

I take that back. Let's get a very simple mock-up Leader object and use that for some Dynamics just to prove that it works. We're not gonna fuck around with giving them permanent Dynamics or AP limitations or their own abilities just yet.

## I'm not totally satisfied with the hierarchy of data in our battle so far. The 'BattleParty' needs a list of units, and the BattleUnits need to know their BattleParty. Futhermore, we're introducing a Leader object, which needs to know the Party that it's leading -- but, at the same time, the Party needs to know who its leader is. It'd be nice to come up with some way to make these objects less dependent on each other.

## Let's talk about hierarchy: it seems to me that, so far, the Battle object is the highest-level object we have (of course), and then, below that, we have the Parties. That makes sense to me: the units know what party they're a part of, but not what battle they're apart of (because we're managing state). The units don't need to know what battle they're a part of, because they know which party they belong to and the party knows what battle it belongs to.

## That being the case, the Leader doesn't really need to know what units it's leading or what battle it's a part of. As long as it knows its own BattleParty, it has access to the Battle object and the BattleUnits through that BattleParty. So, the hierarchy of data is sort of like this:

          Battle
            |
       BattleParty
           | |
BattleLeader BattleUnit

## Because the costs of using Abilities in our game can be so complex, it sort of necessitates not being able to abstract away the code of paying those costs. What I mean is, it would make sense, from an object-oriented standpoint, to give each Ability an 'ap_cost' attribute -- and then, when a BattleUnit tries to use an Ability, it could automatically subtract that AP cost from the Leader.

That makes sense. It would make sense if the gimmick our game wasn't that rules are so dynamic. Because, what if the costs of an ability change based on circumstance? What if you had an ability with a description like such:

Desperate Slap: If used when the leader's AP is at max, it costs 4 AP to use. If used when the leader's AP is below max, it costs 2 AP to use.

In that case -- and it seems very reasonable -- the Leader is punished for using Desperate Slap at the start of their turn. Because of dynamic systems like this one, I feel like we don't really have the luxury of implementing an 'ap_cost' attribute in an object-oriented way. Instead, it seems as though we need to implement the subtraction of costs into the actual code of using every individual Ability. That seems lame, from OOP standpoint, but it does make our mechanics more flexible.

I'm gonna make a new DynamicRule and we're gonna call it "NerdStamina." If the leader's AP drops below 3, every unit on their team loses 30% of their attack power. I'm trying to make a Rule that brings the new 'leaders' into play.

Right now, we've made our mock-up work under the assumption that we would only ever have one action take place in the battle. Now, we're taking more than one action per battle (as you would expect), and I'm finding that we need to reset the Battle's DynamicRule's recurrence_counter's. The question is, when is the best time to do that?

It would be done between player actions.

But how do we calculate that. How do we know when the player has done an action.

Well, it would be after the unit uses an ability. Leaders can also use abilities, including switching units. So... maybe... we need a better way to universally understand that a 'battle action' has taken place. We want to restore the Rules' recurrence_counter's after an action takes place.

Maybe, temporarily, it would just make sense to give the Battle object a 'reset_rule_counters' method that we can call between actions.

Final thoughts for the day: we implented a 'leader' object which has an AP value that we can consume when we use abilities. We made our first rule that cares about the leader and their AP, and we also, for the first time, took advantage of the fact that our DynamicRules are INSTANCES, which means that we can use them to save persistent data about how they've been triggered in the past to alter how they behave when triggered subsequently. So that's kind of cool.

We also implemented a method for our Battle objects to reset the recurrence counters of all of the rules to be called between 'actions'. It'd be nice to have this be automated, but, for that, we'd need a way to know when an action is being used.

I mean, fuck -- we could fix that right now. We should just append 'battle.reset_dynamic_recurrence' to the end of our battle_3.UnitAbility.use method.

For next time, we need to add a lot of attributes for BattleUnits and Battles, at the very least: including a 'ring' in the battle for units to populate and some slots for the BattleUnits to be under the influence of a LIMITED NUMBER of Dynamics. This is something that me and Kenny talked about as a way to balance the Dynamic system: have there be a limit to how many rules a single unit can be subject to.


04/17/19

First of all, I want to program a 'ring' into the 'Battle' object, so that we know which party members from each team are currently 'active' in the battle.

That means adding a new attribute to the Battle object (or would it be the 'Party' object??? It would be the Party object) and making some new Rules that would only target the unit in the ring.

I've mentioned in the past that a big difficulty with object-oriented programming is knowing how to divide and share responsibility. I think it'd make more sense for the 'ring' attribute to belong to the Party objects, in the long-term. It really is all about how you're deciding to abstract your ideas to make your current and future objects behave.

It would make more sense to give the 'in_ring' attribute to a Party object, because the Battle already has two parties and so figuring out who's in the ring would be as trivial as iterating through the Parties and reading their 'in_ring' attribute. What's cool about this is that it would work even if, hypothetically, we had 3 or 4 or 10 parties in the battle.

Furthermore, if the battle had a 'in_ring' attribute, it would need to be some kind of list, because we'd have two units in the ring for two teams. And then, to figure out which team those units are ON, we'd need to iterate through the in_ring list and read their .party attribute. It's just a little bit sloppier.

It makes more sense to have the 'in_ring' attribute belong to the Party objects.

Now that our BattleParty objects have a method for swapping units into the ring, we're going to expand upon that, later -- fuck it. Let's do it now.

Point_units have been implemented (in-ring units), so now we need to design some Rules that take advantage of this. I want 1 Rule that only affects the point_unit of a certain party, and so we want to change our point_unit mid-fight to see if the rule applies not to a PARTICULAR unit but to whoever is currently in the ring.

I want 1 Rule which only affects units who AREN'T in the ring.

I want 1 Rule which triggers when a painted unit is swapped INTO the ring.

Let's create a 'poison cloud' rule which subtracts HP from both point-units every turn? We don't have turns working yet. We could fix that first? Turns would be implemented at the Battle object level. The Battle would have an attribute: current_turn. Now, would current_turn refer to a Leader? Or a party? It doesn't really matter, but that's exactly why we need to consider this carefully: which would make more sense in the long-term.

The parties can't have a 'next_turn' method, because they don't strictly know (without going through their .battle attribute) what the other party is. So, if we're going to do a 'next_turn' method, it should definitely belong to the Battle object. Only the Battle object knows all of the parties.

I just had a horrible vision, dude. It strikes me that we probably want to have Rules that are triggered whenever leader AP is restored (never mind) by unnatural means, such as when an Ability is used that has a chance to restore AP when it crits. I don't want for these rules to get triggered when the turns roll over and the AP is restored back to maximum.

But that's fine, because DynamicEvents have 'perpetrators' for that very reason. If an AP restoration is perpetrated by an Ability, that would trigger the rule -- and it'd ignore the DynamicEvent if it was perpetrated by a turn-change.

It is REALLY ANNOYING that our 'DynamicAttributes' can't be read directly, because they're objects. To get the value of a DynamicAttribute, we have to use DynamicAttribute.value. That's pretty frustrating. Is there a way around that? I thought about it, before, and I couldn't think of a solution. for now, we'll continue using .value.

The thing to do to re-implement DynamicAttributes in a more readable way would be to override __setattr__ of the OWNER object -- NOT of the DynamicAttribute object, which would no longer even be necessary.

So, in object-oriented programming, Objects have 'attributes,' which are values that belong to that object.

So, if we have a 'protagonist' in a JRPG, he has an 'HP' attribute, and that value is constantly changing, but it belongs to the protagonist.

Because the gimmick of our game is that, wheenver a value changes in battle, it can trigger RULES, we created a new type of object which abstractly represents the same concept as an object attribute: a 'DynamicAttribute'.

This way, we can bind behavior to whenever the DynamicAttribute gets updated. So, instead of saying:

protagonist.hp = protagonist.hp - 10

We would say:

protagonist.hp = DynamicAttribute(self, "hp", 100)
protagonist.hp.update(protagonist.hp.value - 10, monster)

The problem with this is that we can't just say something simple like:
print(f"Your protagonist's health is currently at {protagonist.hp}.")

We can't say that because protagonist.hp is NOT an integer. It's a DynamicAttribute. So, instead, we need to say:

print(f"Your protagonist's health is currently at {protagonist.hp.value}.")

Because .value is an attribute of the DynamicAttribute object which refers to its current 'value'.

This works fine, but it's sort of confusing to read because we're intentionally abstracting away the default object-oriented behavior of the language. That's the problem. We're abstractly re-assigning a value, but we're not actually using Python's built-in assignment tools: we made our assignment tools that can trigger Rules. This necessitates an object with a method to do that, and so, when referring to the protagonist's actual HP integer, we need to refer to the 'value' attribute of this DynamicAttribute object -- and that's confusing, because we want to think of 'hp' as an integer.

But I think I have the solution. The solution would be to COMPLETELY GET RID OF the DynamicAttribute object and instead create a DynamicObject class which overrides __setattr__ . Whenever one of its attributes gets changed, it calls the method which has been, up to this point, DynamicAttribute.update().

We don't need an object which abstracts the idea of an 'attribute that can trigger things when changed.'

We need an object which says, 'if you change one of my attributes, things can get triggered'.

The problem with this idea is that, if we just use simple assignment to trigger Rules we don't have any way of knowing who perpetrated the change, and that's super important to our mechanisms.

If I say:

protagonist.hp.update(protagonist.hp.value - 10, monster)

We know that the monster lowered the protagonist's health.

However, if I just say,

protagonist.hp = protagonist.hp - 10

We don't have way of knowing how or why or who lowered that value, and that's super important to our mechanisms.

I'm not gonna have time to fix this today. Let's take a few minutes and think about if there's any solution to this issue. Can we possibly abstract away the DynamicAttribute object by replacing it with true Python object-oriented utilities via the __setattr__ method. Can we possibly have these Rules be triggered by __setattr__ when __setattr__'s only arguments are the NAME of the attribute ("hp") and the NEW VALUE (protagonist.hp - 10).

Is it important that we know WHO changed the protagonist's HP. The obvious answer is YES, obviously. We use DynamicAttribute.update to create these DynamicEvent objects which sort of act as reports to tell the rules what just happened.

With __setattr__, we could create and manage EVERY ASPECT of our current DynamicEvent report EXCEPT FOR the 'perpetrated_by' attribute.

We have to have the full report to make the rules work, and a huge part of that report is not only WHOSE value GOT changed, but WHO initiated that change.

If KReichJr attacks Vencabot and Vencabot's HP gets lowered, we're gonna need for Rules to know that Kenny is the attacker. That's pretty much the whole point of the dynamic system. We have this report that gets generated and which all of our Rules read to decide if they want to trigger or not. The report explains:

Who is the target of this change.
What attribute got changed.
What was that attribute's value, before.
What is that attribute's value, now.
Who initiated this change.

From __setattr__, we can get ALL of this data except for the last part.

I'm sad to say that it seems like our solution is the best solution for our problem considering our unique needs. In order to trigger rules whenever an attribute is changed, we need to generate this report which we're calling DynamicEvent. To generate that report, we just can't rely on a simple, vanilla, object-oriented attribute assignment.

If we say,

protagonist.hp = protagonist.hp - 10

We just can't load in information about HOW or WHY or WHO lowered that value. We NEED some kind of special object with special methods that simulate 'assignment'. In our case, we're using an object called DynamicAttribute which simulates a vanilla, object-oriented 'attribute' but which you DON'T assign using the assignment operator; instead, you assign it using a special method, 'update,' which requires that you supply the identity of whoever is 'perpetrating' that change.

I was really hoping to negate the necessity for 'protagonist.hp.value,' but it seems that we don't really have that luxury.

I mean, would it make more sense to just give 'DynamicObject' the method 'update(),' and then, when we changed the protagonist's health, it would be like this:

# This is what I want, but it doesn't supply a perpetrator.
protagonist.hp = protagonist.hp - 10

# We have this. The hp attribute is not an integer, but a DynamicAttribute.
protagonist.hp.update(protagonist.hp.value - 10, monster)

# We could do this, but it's the same issue, really.
# This way, we can access protagonist.hp as an integer, but we still can't
# assign directly to HP. It's the same problem, though; it's unintuitive.
# If, one time, you forget to call protagonist.update_attr and instead call
# protagonist.hp =, then Rules won't get triggered.
# This way makes more sense. It's more clear what's going on. It's saying
# very explicitly, "update this value but also do some other things (check
# rules)." Basically, we're creating our own __setattr__ method, except that
# it takes a perpetrator argument.
protagonist.update_attr("hp", protagonist.hp - 10, monster)

We gotta play 3rd Strike, but I guess, for our next sit-down with this, it probably would make sense to replace DynamicAttribute with DynamicObject. DynamicObjects can have their attributes updated through a method, 'update_attr', which explicitly checks rules.

protag.hp = protag.hp - perp.damage

That doesn't work because, to override __add__, we would need to override 'integer', in this case.

We gotta end the stream. We'll definitely sleep on it. I still think that the most elegant way is closer to what we've been doing, but maybe we would go toward having DynamicObjects with an update_attr method instead of DynamicAttributes with an update method.

But it's definitely worth looking at subclasses 'int' and seeing if we want to override the behavior of straight-up numbers so that we can add them together and get special information out of it. Worth looking at it.

04/18/19

Now that we've replaced the old 'DynamicAttribute' way of handling the rules with the 'DynamicObjects,' we've solved our problem of having to access attribute values using object.attribute_name.value .

So, the old way of updating an attribute in such a way that it would trigger rules was like this:

my_unit.hp.update(new_hp_value, enemy)

The problem with this was that, in order to see how much HP 'my_unit' currently had, we had to access it like this:

my_unit.hp.value

With this NEW way, if we want to update a value in such a way that it would trigger rules, we do it like this:

my_unit.update_w_rules("hp", new_hp_value, enemy)

And then we can access the unit's current HP like this:

my_unit.hp

I think that's a little more elegant. It's a little bit more clear what's going on. It's much easier to access attributes in a sensible way. The only downside is that we STILL can't just use vanilla assignment -- but that's probably for the best, really. I mean, it's very important with object-oriented programming to minimize 'side-effects' -- that's a danger of 'state'. When you start overriding 'addition' and 'subtraction' and, if we could, 'assignment' so that it does OTHER things aside from what you see on the tin, then that's probably not a good idea.

It probably makes sense to use an overt method for triggering rules when a value is changed. That way, anyone looking at the code can tell that's what it's supposed to do. Otherwise, if we COULD override assignment to do the same thing, it might be easier to read AT FIRST:

my_unit.hp = new_value

But then it might be confusing when crazy shit starts happening just because we made an assignment (if we could do that). So having a separate method probably makes sense.

DynamicObjects need to know their own list of Rules. The Rules are subservient to the Battle object. Does the Battle object need to be a DynamicObject.

Well, yes. Yes it does. Let's say that we could somehow re-construe 'active_party' as an attribute of the parties, themselves. Like, party.is_active = boolean. Even if we could do that, I don't think there's a way to have a Rule like this if the Battle is not a DynamicObject:

Status Quo: Whenever a new Rule is added by Party B, Party A gets their health restored.

For this reason, I think it makes sense for the Battle object to be a DynamicObject.

But. A problem arises. So far, our DynamicObject.update_w_rules method assumes that all of DynamicObject's attributes are immutable. It takes the old value and replaces it with a new value. That doesn't really work for mutable objects, such as lists, which might change and require rules to be triggered when a new value is appended to them. Is that going to be a problem?

Well, the first thought is that every attribute of a DynamicObject that's going to trigger rules MUST BE TREATED AS IMMUTABLE. This is a necessity because so much of the 'report' system, based on DynamicEvent, is founded on the idea of comparing the OLD VALUE to the NEW VALUE. We're always gonna need to know what the OLD VALUE was and what the NEW VALUE is. That's super important to the very basis of the Dynamic Rule system.

So, if you have something like a LIST -- like, let's say that you have a Rule that gets triggered whenever an item is added to the leader's inventory. In order to compare the old list to the new list, we need to have two different lists: so, we're talking about mutable objects being treated as immutable. We almost might as well just use tuples.

I'm not sure if that's a problem. I don't necessary THINK that's a problem, except for what I just got done saying about the DynamicObjects needing access to a permanent, mutable reference to the current battle's rules. THAT BEING SAID, we also just found out that the battle's 'list' of rules is actually a dictionary.

So, maybe the dictionary is what gets passed in to DynamicObject and the DICTIONARY never changes. It just contains a before and after phase.

The Battle object has a dictionary, 'Battle.rule_phases'. It's a dictionary of phase-names to the lists of DynamicRules that are checked on that phase.

As a DynamicObject, we could call 'update_w_rules' on it -- BUT WE COULD NOT use that method to change a List of rules, because the Lists of rules are not attributes of our DynamicObject: they're values in a Dict which is an attribute of our object.

So, as of right now, if we wanted for a Rule to trigger when a new rule is added to battle, it would need to work like this:

new_rule_phases = {}
new_rule_phases["before"] = battle.rule_phases["before"].copy()
new_rule_phases["after"] = battle.rule_phases["after"].copy()
new_rule_phases["after"].append(some_new_rule)
battle.update_w_rules("rule_phases", new_rule_phases, perpetrator)

We have to treat it as being immutable. We have to make a whole new dictionary with whole new lists and replace the old dictionary of lists.

It's kind of ugly, right now, but I think that's mostly because we have this dictionary, "rule_phases," when maybe we just need to use attributes. That's one major reason it looks ugly. Maybe we should do something more like this:

battle.before_rules
battle.after_rules

Instead of,

battle.rule_phases = {"before": [], "after": []}

Having a dictionary for rule_phases is kind of wasteful, because we're just matching a string to a value -- and that's exactly what object.__dict__ is for. If we're just matching a name to a value, we might as well make it a attribute. It's not like we're going to be dynamically adding in more keys to this dictionary.

On the other hand, I think that having a dictionary of phases makes it more clear how we process the rules. Because attributes have no order (technically, neither do dictionaries, but at least they have a visible order in the source code). We treat both phases equally, just one after the other. So, by having two totally separate attributes, you sort of lose that relationship -- abstractly, they're the same thing, just different phases.

Here's my idea: what we need is a new type of object, 'RuleSet'. RuleSet has attributes:

RuleSet.before
RuleSet.after

What's cool about RuleSet is that it can be a DynamicObject. So, when RuleSet.before or RuleSet.after is updated, we can trigger Rules. And, by virtue of being a classed object, RuleSet is mutable -- so we can pass in a RuleSet when defining a DynamicObject.

But hang on though. How do we pass the RuleSet as its own RuleSet.

Let's go implement that.

Today, in review, we really drastically changed the way that our dynamic_system library is laid out and the way that it behaves, internally. The result is that its API has effectively changed, although it works mostly similarly. The 'battle' library is completely broken by these changes and needs to be adapted to the new dynamic_system. Also, our actual mock-up at 'rules_and_events' mostly needs to have its example DynamicRules updates to match the method-name changes of dynamic_system.DynamicRule .

It should be a relatively quick porting job, but we don't really have time to do that right now. That'll be our project for Monday: get everything working again, so that it's as effective as it was BEFORE -- but with much cleaner internal code.



04/22/19

We have a problem. Understandably, our new Ruleset object has two attributes -- 'before' and 'after' -- which reference lists of DynamicRules to be checked on those phases.

To this end, we removed the old 'check_phase' attribute from the DynamicRules, themselves. They don't need to know their own check-phase.

But, if the DynamicRule object doesn't have a tag that we can use to find out its check-phase, how do we know which list of Ruleset to add that Rule to at the start of battle (or any other time).

It seems to me like the DynamicRules DO need to have some way to communicate when they're supposed to checked. So... That seems a bit redundant considering that our Rulesets also have 'before' and 'after' lists.

On the DynamicRules, the 'check_phase' attribute could be thought of as a 'tag,' because it's not an attribute in the sense that the Rule, ITSELF, will ever access that attribute. Usually when you have an object and it has attributes you're going to be using those attributes in the methods of that object.

In this case, it's just important that other objects which play with the DynamicRules be able to tell when that Rule is supposed to checked.

Let's review the basics of the 'dynamic rule system' and then talk about how our code is laid out.

In many JRPGs, characters can inflict and be inflicted with 'status changes': 'poison', 'paralyze', etc. Also, they can use 'buffs' to give themselves and their allies a temporary boost to some attribute.

The central gimmick of our game's combat system is that these status changes take on a much more significant role. For one thing, every status change can be complex beyond what we're used to seeing in JRPGs.

Instead of having a vanilla 'poison' attribute, we're talking about having a 'DynamicRule' that says something these along these lines, which some kind of 'rogue' class might have inflicted upon their opponent:

When the inflicted target uses any skill to heal an ally, they take damage equal to the amount that their ally recovered.

That's a 'dynamic rule'. The idea beyond inflicting these 'status changes' is to limit your opponent's options and to strengthen your own team's dynamic. Buffs behave the same way:

Whenever the target gains attack power, they also gain defense.

As you might imagine, implementing a system like this, in OOP (or otherwise), is an interesting challenge -- because we're talking about being able to dynamically alter the rules of the game, itself.

The solution that we've come up with is what I'm going to show on-screen right now.


This stream, today, hasn't been a huge success in terms of making progress, and a part of that is, coming back from the weekend, I'm not 100% sure of where the version 4 mock-up begins and the version 3 mock-up ends

The big changes in the version 4 mock-up are as follows:

DynamicAttributes are being traded for DynamicObjects.
We're implementing 'Ruleset' objects, which manage all of the rules in a battle.

Because of those two changes, we need to re-write all of our existing test DynamicRules: Invincible, Hench, ExtraDamage, Persistence, Rage, MagicMan, OldManGenes.

Where we're at, right now, is how do we append new DynamicRules to this Ruleset.

I think that DynamicRules still need a 'check_phase' attribute. They need this attribute because, when we add the rule to the game, we need to know what phase to append it to. It's kind of sloppy, it's kind of ugly, it's kind of redundant. I don't like it.

One solution, at least as far as REDUNDANCY, is to have the Rules in a Ruleset all be a part of 1 list -- and then, when you're checking the 'before' phase or the 'after' phase, you just use a list comprehension to create those phases.

Let's make a very simple "append rule" method and fix the DynamicRules to have a check_phase attribute.

Just to celebrate Penguin joining the stream (and because I'm on the fence myself), we'll go with having only one list of Rules.

I have a problem. When should the recurrence counters be reset?

The obvious solution would be to reset them once the 'after' phase is completed.

But I'm not sure that's what we want, because the main thing that DynamicRules do is CREATE OTHER UPDATES which, in turn TRIGGER OTHER RULES. So, if one update completes and the recurrence counters get reset, couldn't that cause bugs with other updates happening at the same time? I want to say yes, but I can't prove it.

If I have two rules that read as such:
"If Vencabot takes damage, he loses attack power."
"If Vencabot loses attack power, he takes damage."

That's an infinite loop, and that's why we implement the recurrence counter.

Let's draw up an order-of-operations for if the recurrence counters were reset after a successful update.

We propose an event where Vencabot takes damage.
Nothing triggers in the Before phase.
In the after Phase, we update Vencabot's attack power.
We propose a change to Vencabot's attack power.
Nothing triggers in the Before phase.
In the after Phase, we update Vencabot's HP.
In the before phase, nothing happens.
In the After phase, we try to reduce his attack power, but we're at the recurrence limit.
Now that Vencabot's attack power has been updated, recurrence counters get reset.

THE BUG HAPPENS RIGHT HERE. If we DID have more Rules than just those two, we would have a problem with recurrence counters being reset after his attack power was updated.

Now that Vencabot's HP has been updated, recurrence counters get reset.


But the 'update' happens in the SAME THREAD. So, we don't reach the end of the first 'After' phase until we're done processing this attack power update.

So, we can't reset recurrence_counters after a successful update. We have to reset them once all updates on all phases are complete.

So, this is a job for an object much greater than what we're working with, now. Basically, the recurrence_counters would need to be reset between unit turns -- and, right now, we don't have a mechanism for moving between unit turns or otherwise completing an entire action.

Well, I mean. That's a problem. We could implement this 'recurrence_counter reset' at the end of every Ability in the game. But, the problem with that is that we have actions the player can take which aren't strictly 'UnitAbilities', such as Swapping team members, using items -- attempting to flee from combat or whatever -- which should be able to trigger Rules (and, by extension, reset recurrence_counters).

Basically, we might need some kind of parent object which abstractly represents an entire 'action'. An action that can trigger rules -- and, when it's over, the recurrence_counters get reset.

For now -- for mock-up version 4 -- let's just reset them MANUALLY. We're gonna reset the recurrence_counters manually.

Our dynamic_system_4 library is complete for mock-up 4, as of now.
battle_4 objects need porting. They still use 'DynamicAttributes' instead of 'DynamicObjects'. That's our project for Wednesday.

Once that's ported over, we'll need to rewrite rules_and_events_4 somewhat drastically especially to change the way that our existing 'test rules' operate.
